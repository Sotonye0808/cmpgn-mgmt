Production Integration Plan — Prisma + Upstash Redis + Cloudinary
What we already have in place
@prisma/client + prisma already in package.json — no reinstall needed
DATABASE_URL (Prisma Accelerate) — dev and prod already in env files
UPSTASH_REDIS_REST_URL + UPSTASH_REDIS_REST_TOKEN — already in env files
CLOUDINARY_* env vars — already in env files
Every service already uses mockCache with a consistent API (get/set/del/invalidate/invalidatePattern) — designed for mechanical swap
Every service already uses mockDb.transaction() — designed to swap to prisma.$transaction()
Upload API already has a // Phase 14 swap: replace with Cloudinary SDK upload comment
Packages to install (additions only)
Package	Why
@upstash/redis	Upstash uses an HTTP REST API, not a TCP socket — ioredis won't work with it
cloudinary	Official Cloudinary Node SDK v2 for server-side signed uploads
@prisma/extension-accelerate	Required to use the prisma+postgres:// Accelerate connection string
No project/DB name is needed in Prisma or Upstash
Prisma Accelerate and Upstash both operate purely from the connection URL/token in env. No named config needed anywhere in code.

Step 1 — Prisma Schema (prisma/schema.prisma)
Full schema mapping every table in mockDb to a Prisma model. All 16 tables, full relations, indexes. Key design decisions:

Campaign.media → Json column (it's a CampaignMedia[] object array, not a relational child table — keeping it inline keeps queries simple and matches the current type shape)
Team.members → via User.teamId FK (proper relational instead of the mock's memberIds: string[] array)
Group.teamIds → via Team.groupId FK (same reason)
All enums declared in schema mirror global.d.ts const enums exactly — no changes to TypeScript types needed
All IDs: @id @default(cuid()) — cuid is universally unique and CRM-migration-safe
Donation.amount → Decimal @db.Decimal(12,2) — never store money as float
TrustScore.flags → TrustFlag[] — PostgreSQL supports native enum arrays
Proper @@index on every high-query field (userId, campaignId, status, createdAt, slug)
SmartLink.slug → @unique + @@index([slug]) — critical for fast redirect lookup at /c/[slug]
Models: User, Campaign, CampaignParticipation, SmartLink, LinkEvent, Referral, Donation, PointsLedgerEntry, LeaderboardSnapshot, TrustScore, AppNotification, ViewProof, Group, Team, TeamInviteLink, CampaignAuditEvent

Step 2 — Infrastructure Lib Singletons
Three new files, never imported by client components:

lib/prisma.ts
PrismaClient singleton pattern (prevents connection pool exhaustion in dev HMR). Uses withAccelerate() extension to support the prisma+postgres:// URL.

lib/redis.ts
Upstash Redis singleton. Critical: exposes the exact same API surface as mockCache so every mockCache.X call in services becomes redis.X with zero logic changes — purely a symbol rename per-file.

mockCache method	redis adapter method	Notes
set(key, val, ttlMs?)	set(key, val, ttlMs?)	Converts ms → seconds for Upstash ex option
get<T>(key)	get<T>(key)	Returns T \| null
del(key)	del(key)	Single key delete
invalidate(key)	invalidate(key)	Alias for del
invalidatePattern(prefix)	invalidatePattern(prefix)	Uses Upstash SCAN to find all matching keys then bulk DEL
Cache keys will be namespaced: dmhicc:v1:<domain>:<key> — e.g. dmhicc:v1:campaigns:list. This ensures no collision if this Upstash instance is ever shared with the future CRM project.

lib/cloudinary.ts
Cloudinary SDK configuration + a single uploadAsset() helper that routes files to the correct folder based on an AssetCategory enum. The API secret never leaves the server.

Cloudinary folder structure under the existing cmpgn-mgmt root folder:

The uploadAsset() helper signature:

Folder mapping is a typed config object (not a switch statement) — easy to add new folders. All uploads are signed (server-side only via API key+secret). The returned url and thumbnailUrl are what gets stored in the database.

Step 3 — Upload API Route Swap (route.ts)
The existing route already has the correct stub and validation. Changes:

Import uploadAsset from lib/cloudinary.ts
Accept a category: AssetCategory in the FormData
Replace the mock URL block with await uploadAsset(fileBuffer, category)
Return the real Cloudinary URL + thumbnailUrl
Step 4 — Service Layer Migration (12 modules)
Pattern per service file (mechanical, no logic changes):

import { mockDb } from "@/lib/data/mockDb" → import { prisma } from "@/lib/prisma"
import { mockCache } from "@/lib/data/mockCache" → import { redis } from "@/lib/redis"
mockDb.<table>.findMany(...) → prisma.<table>.findMany(...)
mockDb.<table>.findUnique(...) → prisma.<table>.findUnique(...)
mockDb.<table>.create({ data }) → prisma.<table>.create({ data })
mockDb.<table>.update({ where, data }) → prisma.<table>.update({ where, data })
mockDb.<table>.delete({ where }) → prisma.<table>.delete({ where })
mockDb.transaction(cb) → prisma.$transaction(cb)
mockDb.emit(...) → remove (handled by real-time layer, see below)
mockCache.* → redis.* (same method names)
Modules to migrate in order (dependency-safe sequence):

users — no cross-module deps
campaign — depends on users
links — depends on campaign + users
engagement — depends on links
referral — depends on links + users
points — depends on referral + engagement
leaderboard — depends on points
donation — depends on campaign + users
proofs — depends on campaign + links
trust — depends on users + engagement
analytics — depends on all above
teams — depends on users
Step 5 — Real-time Event Architecture Swap
mockDb.emit("table:changed") drives the useMockDbSubscription hook. In production WebSocket or SSE replaces this:

Short-term (production v1): Remove useMockDbSubscription calls from hooks; replace with polling (e.g. SWR or React Query with refetchInterval) — zero risk, works immediately
Medium-term: Add Next.js Route Handlers for SSE to push updates; Upstash Redis pub/sub can be used as the message bus
Long-term / CRM integration: Upstash Kafka or a proper event bus for cross-system sync
Step 6 — Prisma Seed (seed.ts)
Port the existing seed.ts fixture data to run against Prisma with upsert so it's safe to re-run. Add to package.json:

Run with: npx prisma db seed

Step 7 — Security & Reliability Hardening
Concern	Implementation
Signed uploads	All Cloudinary uploads go through the server-side API route — API secret never exposed client-side
File type validation	Maintained in upload route (whitelist of MIME types). Cloudinary also validates server-side
Rate limiting	Redis-backed rate limiter middleware (lib/middleware/rateLimit.ts) — keyed on ip:route, using Upstash atomic increment + TTL
SQL injection	Prisma uses parameterised queries by default — zero risk at ORM level
ACID	prisma.$transaction() maps directly from mockDb.transaction() — all existing multi-table writes become ACID-safe automatically
Secrets in env	Cloudinary secret, JWT secrets, DB URL — all server-only (no NEXT_PUBLIC_ prefix except cloud name)
Prisma Accelerate	Built-in connection pooling + edge caching — handles serverless cold-start connection limits
Redis key namespacing	dmhicc:v1: prefix on all keys — safe for future shared Redis with CRM
Step 8 — CRM Future-Proofing
Design Choice	CRM Migration Benefit
cuid() IDs everywhere	Globally unique — can be synced across DBs without collision
Donation.reference is @unique	Idempotent — same reference can't be double-imported
Cloudinary URLs stored in DB	Asset URLs are portable — CRM can read them directly
Redis keys namespaced dmhicc:v1:	Can share an Upstash instance with CRM using different namespaces
Prisma schema is standalone	One-command export to seed another DB: prisma db pull + prisma migrate deploy
Service layer is domain-isolated	Each module can be extracted into a microservice or CRM sub-module independently
Execution Order
Ready to start coding? I'd recommend beginning with Steps 1–3 (package install + schema + lib singletons) in a single pass, then running through services module by module. Say the word and I'll begin.

/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignParticipation
 * 
 */
export type CampaignParticipation = $Result.DefaultSelection<Prisma.$CampaignParticipationPayload>
/**
 * Model SmartLink
 * 
 */
export type SmartLink = $Result.DefaultSelection<Prisma.$SmartLinkPayload>
/**
 * Model LinkEvent
 * 
 */
export type LinkEvent = $Result.DefaultSelection<Prisma.$LinkEventPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model Donation
 * 
 */
export type Donation = $Result.DefaultSelection<Prisma.$DonationPayload>
/**
 * Model PointsLedgerEntry
 * 
 */
export type PointsLedgerEntry = $Result.DefaultSelection<Prisma.$PointsLedgerEntryPayload>
/**
 * Model LeaderboardSnapshot
 * 
 */
export type LeaderboardSnapshot = $Result.DefaultSelection<Prisma.$LeaderboardSnapshotPayload>
/**
 * Model TrustScore
 * 
 */
export type TrustScore = $Result.DefaultSelection<Prisma.$TrustScorePayload>
/**
 * Model AppNotification
 * 
 */
export type AppNotification = $Result.DefaultSelection<Prisma.$AppNotificationPayload>
/**
 * Model ViewProof
 * 
 */
export type ViewProof = $Result.DefaultSelection<Prisma.$ViewProofPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamInviteLink
 * 
 */
export type TeamInviteLink = $Result.DefaultSelection<Prisma.$TeamInviteLinkPayload>
/**
 * Model CampaignAuditEvent
 * 
 */
export type CampaignAuditEvent = $Result.DefaultSelection<Prisma.$CampaignAuditEventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  TEAM_LEAD: 'TEAM_LEAD',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const CampaignMediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  LINK: 'LINK',
  TEXT: 'TEXT'
};

export type CampaignMediaType = (typeof CampaignMediaType)[keyof typeof CampaignMediaType]


export const GoalType: {
  SHARES: 'SHARES',
  CLICKS: 'CLICKS',
  REFERRALS: 'REFERRALS',
  DONATIONS: 'DONATIONS',
  PARTICIPANTS: 'PARTICIPANTS'
};

export type GoalType = (typeof GoalType)[keyof typeof GoalType]


export const LinkEventType: {
  VIEW: 'VIEW',
  CLICK: 'CLICK',
  SHARE: 'SHARE',
  CONVERSION: 'CONVERSION',
  REFERRAL: 'REFERRAL'
};

export type LinkEventType = (typeof LinkEventType)[keyof typeof LinkEventType]


export const PointType: {
  IMPACT: 'IMPACT',
  CONSISTENCY: 'CONSISTENCY',
  LEADERSHIP: 'LEADERSHIP',
  RELIABILITY: 'RELIABILITY'
};

export type PointType = (typeof PointType)[keyof typeof PointType]


export const DonationStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  RECEIVED: 'RECEIVED',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type DonationStatus = (typeof DonationStatus)[keyof typeof DonationStatus]


export const TrustFlag: {
  DUPLICATE_ACTIVITY: 'DUPLICATE_ACTIVITY',
  ABNORMAL_CLICKS: 'ABNORMAL_CLICKS',
  SUSPICIOUS_DEVICE: 'SUSPICIOUS_DEVICE',
  RATE_LIMITED: 'RATE_LIMITED'
};

export type TrustFlag = (typeof TrustFlag)[keyof typeof TrustFlag]


export const SocialPlatform: {
  FACEBOOK: 'FACEBOOK',
  INSTAGRAM: 'INSTAGRAM',
  TWITTER_X: 'TWITTER_X',
  TIKTOK: 'TIKTOK',
  YOUTUBE: 'YOUTUBE',
  WHATSAPP: 'WHATSAPP',
  SNAPCHAT: 'SNAPCHAT'
};

export type SocialPlatform = (typeof SocialPlatform)[keyof typeof SocialPlatform]


export const ViewProofStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ViewProofStatus = (typeof ViewProofStatus)[keyof typeof ViewProofStatus]


export const CampaignAuditEventType: {
  CREATED: 'CREATED',
  STATUS_CHANGED: 'STATUS_CHANGED',
  FIELDS_UPDATED: 'FIELDS_UPDATED',
  PARTICIPANT_JOINED: 'PARTICIPANT_JOINED',
  DONATION_RECEIVED: 'DONATION_RECEIVED',
  GOAL_REACHED: 'GOAL_REACHED',
  ENDED: 'ENDED'
};

export type CampaignAuditEventType = (typeof CampaignAuditEventType)[keyof typeof CampaignAuditEventType]


export const NotificationType: {
  CAMPAIGN_UPDATE: 'CAMPAIGN_UPDATE',
  REFERRAL_JOINED: 'REFERRAL_JOINED',
  POINTS_EARNED: 'POINTS_EARNED',
  TRUST_FLAG: 'TRUST_FLAG',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type CampaignMediaType = $Enums.CampaignMediaType

export const CampaignMediaType: typeof $Enums.CampaignMediaType

export type GoalType = $Enums.GoalType

export const GoalType: typeof $Enums.GoalType

export type LinkEventType = $Enums.LinkEventType

export const LinkEventType: typeof $Enums.LinkEventType

export type PointType = $Enums.PointType

export const PointType: typeof $Enums.PointType

export type DonationStatus = $Enums.DonationStatus

export const DonationStatus: typeof $Enums.DonationStatus

export type TrustFlag = $Enums.TrustFlag

export const TrustFlag: typeof $Enums.TrustFlag

export type SocialPlatform = $Enums.SocialPlatform

export const SocialPlatform: typeof $Enums.SocialPlatform

export type ViewProofStatus = $Enums.ViewProofStatus

export const ViewProofStatus: typeof $Enums.ViewProofStatus

export type CampaignAuditEventType = $Enums.CampaignAuditEventType

export const CampaignAuditEventType: typeof $Enums.CampaignAuditEventType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient({
 *   adapter: new PrismaPg({ connectionString: process.env.DATABASE_URL })
 * })
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter: new PrismaPg({ connectionString: process.env.DATABASE_URL })
   * })
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignParticipation`: Exposes CRUD operations for the **CampaignParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignParticipations
    * const campaignParticipations = await prisma.campaignParticipation.findMany()
    * ```
    */
  get campaignParticipation(): Prisma.CampaignParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.smartLink`: Exposes CRUD operations for the **SmartLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmartLinks
    * const smartLinks = await prisma.smartLink.findMany()
    * ```
    */
  get smartLink(): Prisma.SmartLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linkEvent`: Exposes CRUD operations for the **LinkEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkEvents
    * const linkEvents = await prisma.linkEvent.findMany()
    * ```
    */
  get linkEvent(): Prisma.LinkEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.donation`: Exposes CRUD operations for the **Donation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donation.findMany()
    * ```
    */
  get donation(): Prisma.DonationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointsLedgerEntry`: Exposes CRUD operations for the **PointsLedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointsLedgerEntries
    * const pointsLedgerEntries = await prisma.pointsLedgerEntry.findMany()
    * ```
    */
  get pointsLedgerEntry(): Prisma.PointsLedgerEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaderboardSnapshot`: Exposes CRUD operations for the **LeaderboardSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaderboardSnapshots
    * const leaderboardSnapshots = await prisma.leaderboardSnapshot.findMany()
    * ```
    */
  get leaderboardSnapshot(): Prisma.LeaderboardSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trustScore`: Exposes CRUD operations for the **TrustScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrustScores
    * const trustScores = await prisma.trustScore.findMany()
    * ```
    */
  get trustScore(): Prisma.TrustScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appNotification`: Exposes CRUD operations for the **AppNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppNotifications
    * const appNotifications = await prisma.appNotification.findMany()
    * ```
    */
  get appNotification(): Prisma.AppNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewProof`: Exposes CRUD operations for the **ViewProof** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewProofs
    * const viewProofs = await prisma.viewProof.findMany()
    * ```
    */
  get viewProof(): Prisma.ViewProofDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamInviteLink`: Exposes CRUD operations for the **TeamInviteLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamInviteLinks
    * const teamInviteLinks = await prisma.teamInviteLink.findMany()
    * ```
    */
  get teamInviteLink(): Prisma.TeamInviteLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignAuditEvent`: Exposes CRUD operations for the **CampaignAuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignAuditEvents
    * const campaignAuditEvents = await prisma.campaignAuditEvent.findMany()
    * ```
    */
  get campaignAuditEvent(): Prisma.CampaignAuditEventDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.2
   * Query Engine version: 94a226be1cf2967af2541cca5529f0f7ba866919
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Campaign: 'Campaign',
    CampaignParticipation: 'CampaignParticipation',
    SmartLink: 'SmartLink',
    LinkEvent: 'LinkEvent',
    Referral: 'Referral',
    Donation: 'Donation',
    PointsLedgerEntry: 'PointsLedgerEntry',
    LeaderboardSnapshot: 'LeaderboardSnapshot',
    TrustScore: 'TrustScore',
    AppNotification: 'AppNotification',
    ViewProof: 'ViewProof',
    Group: 'Group',
    Team: 'Team',
    TeamInviteLink: 'TeamInviteLink',
    CampaignAuditEvent: 'CampaignAuditEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "campaign" | "campaignParticipation" | "smartLink" | "linkEvent" | "referral" | "donation" | "pointsLedgerEntry" | "leaderboardSnapshot" | "trustScore" | "appNotification" | "viewProof" | "group" | "team" | "teamInviteLink" | "campaignAuditEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignParticipation: {
        payload: Prisma.$CampaignParticipationPayload<ExtArgs>
        fields: Prisma.CampaignParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>
          }
          findFirst: {
            args: Prisma.CampaignParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>
          }
          findMany: {
            args: Prisma.CampaignParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>[]
          }
          create: {
            args: Prisma.CampaignParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>
          }
          createMany: {
            args: Prisma.CampaignParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>[]
          }
          delete: {
            args: Prisma.CampaignParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>
          }
          update: {
            args: Prisma.CampaignParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>
          }
          deleteMany: {
            args: Prisma.CampaignParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignParticipationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>[]
          }
          upsert: {
            args: Prisma.CampaignParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignParticipationPayload>
          }
          aggregate: {
            args: Prisma.CampaignParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignParticipation>
          }
          groupBy: {
            args: Prisma.CampaignParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignParticipationCountAggregateOutputType> | number
          }
        }
      }
      SmartLink: {
        payload: Prisma.$SmartLinkPayload<ExtArgs>
        fields: Prisma.SmartLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SmartLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SmartLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>
          }
          findFirst: {
            args: Prisma.SmartLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SmartLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>
          }
          findMany: {
            args: Prisma.SmartLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>[]
          }
          create: {
            args: Prisma.SmartLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>
          }
          createMany: {
            args: Prisma.SmartLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SmartLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>[]
          }
          delete: {
            args: Prisma.SmartLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>
          }
          update: {
            args: Prisma.SmartLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>
          }
          deleteMany: {
            args: Prisma.SmartLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SmartLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SmartLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>[]
          }
          upsert: {
            args: Prisma.SmartLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartLinkPayload>
          }
          aggregate: {
            args: Prisma.SmartLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSmartLink>
          }
          groupBy: {
            args: Prisma.SmartLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SmartLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SmartLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SmartLinkCountAggregateOutputType> | number
          }
        }
      }
      LinkEvent: {
        payload: Prisma.$LinkEventPayload<ExtArgs>
        fields: Prisma.LinkEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>
          }
          findFirst: {
            args: Prisma.LinkEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>
          }
          findMany: {
            args: Prisma.LinkEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>[]
          }
          create: {
            args: Prisma.LinkEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>
          }
          createMany: {
            args: Prisma.LinkEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>[]
          }
          delete: {
            args: Prisma.LinkEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>
          }
          update: {
            args: Prisma.LinkEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>
          }
          deleteMany: {
            args: Prisma.LinkEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinkEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>[]
          }
          upsert: {
            args: Prisma.LinkEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkEventPayload>
          }
          aggregate: {
            args: Prisma.LinkEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkEvent>
          }
          groupBy: {
            args: Prisma.LinkEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkEventCountArgs<ExtArgs>
            result: $Utils.Optional<LinkEventCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      Donation: {
        payload: Prisma.$DonationPayload<ExtArgs>
        fields: Prisma.DonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findFirst: {
            args: Prisma.DonationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findMany: {
            args: Prisma.DonationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          create: {
            args: Prisma.DonationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          createMany: {
            args: Prisma.DonationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DonationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          delete: {
            args: Prisma.DonationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          update: {
            args: Prisma.DonationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          deleteMany: {
            args: Prisma.DonationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DonationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DonationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          upsert: {
            args: Prisma.DonationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          aggregate: {
            args: Prisma.DonationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonation>
          }
          groupBy: {
            args: Prisma.DonationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DonationCountArgs<ExtArgs>
            result: $Utils.Optional<DonationCountAggregateOutputType> | number
          }
        }
      }
      PointsLedgerEntry: {
        payload: Prisma.$PointsLedgerEntryPayload<ExtArgs>
        fields: Prisma.PointsLedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointsLedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointsLedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.PointsLedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointsLedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>
          }
          findMany: {
            args: Prisma.PointsLedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>[]
          }
          create: {
            args: Prisma.PointsLedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>
          }
          createMany: {
            args: Prisma.PointsLedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointsLedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.PointsLedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>
          }
          update: {
            args: Prisma.PointsLedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.PointsLedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointsLedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointsLedgerEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>[]
          }
          upsert: {
            args: Prisma.PointsLedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsLedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.PointsLedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointsLedgerEntry>
          }
          groupBy: {
            args: Prisma.PointsLedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointsLedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointsLedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PointsLedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      LeaderboardSnapshot: {
        payload: Prisma.$LeaderboardSnapshotPayload<ExtArgs>
        fields: Prisma.LeaderboardSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>
          }
          findMany: {
            args: Prisma.LeaderboardSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>[]
          }
          create: {
            args: Prisma.LeaderboardSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>
          }
          createMany: {
            args: Prisma.LeaderboardSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>
          }
          update: {
            args: Prisma.LeaderboardSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaderboardSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.LeaderboardSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboardSnapshot>
          }
          groupBy: {
            args: Prisma.LeaderboardSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardSnapshotCountAggregateOutputType> | number
          }
        }
      }
      TrustScore: {
        payload: Prisma.$TrustScorePayload<ExtArgs>
        fields: Prisma.TrustScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrustScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrustScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          findFirst: {
            args: Prisma.TrustScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrustScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          findMany: {
            args: Prisma.TrustScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>[]
          }
          create: {
            args: Prisma.TrustScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          createMany: {
            args: Prisma.TrustScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrustScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>[]
          }
          delete: {
            args: Prisma.TrustScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          update: {
            args: Prisma.TrustScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          deleteMany: {
            args: Prisma.TrustScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrustScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrustScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>[]
          }
          upsert: {
            args: Prisma.TrustScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          aggregate: {
            args: Prisma.TrustScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrustScore>
          }
          groupBy: {
            args: Prisma.TrustScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrustScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrustScoreCountArgs<ExtArgs>
            result: $Utils.Optional<TrustScoreCountAggregateOutputType> | number
          }
        }
      }
      AppNotification: {
        payload: Prisma.$AppNotificationPayload<ExtArgs>
        fields: Prisma.AppNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>
          }
          findFirst: {
            args: Prisma.AppNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>
          }
          findMany: {
            args: Prisma.AppNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>[]
          }
          create: {
            args: Prisma.AppNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>
          }
          createMany: {
            args: Prisma.AppNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>[]
          }
          delete: {
            args: Prisma.AppNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>
          }
          update: {
            args: Prisma.AppNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>
          }
          deleteMany: {
            args: Prisma.AppNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>[]
          }
          upsert: {
            args: Prisma.AppNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppNotificationPayload>
          }
          aggregate: {
            args: Prisma.AppNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppNotification>
          }
          groupBy: {
            args: Prisma.AppNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<AppNotificationCountAggregateOutputType> | number
          }
        }
      }
      ViewProof: {
        payload: Prisma.$ViewProofPayload<ExtArgs>
        fields: Prisma.ViewProofFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewProofFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewProofFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>
          }
          findFirst: {
            args: Prisma.ViewProofFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewProofFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>
          }
          findMany: {
            args: Prisma.ViewProofFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>[]
          }
          create: {
            args: Prisma.ViewProofCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>
          }
          createMany: {
            args: Prisma.ViewProofCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewProofCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>[]
          }
          delete: {
            args: Prisma.ViewProofDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>
          }
          update: {
            args: Prisma.ViewProofUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>
          }
          deleteMany: {
            args: Prisma.ViewProofDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewProofUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewProofUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>[]
          }
          upsert: {
            args: Prisma.ViewProofUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewProofPayload>
          }
          aggregate: {
            args: Prisma.ViewProofAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewProof>
          }
          groupBy: {
            args: Prisma.ViewProofGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewProofGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewProofCountArgs<ExtArgs>
            result: $Utils.Optional<ViewProofCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamInviteLink: {
        payload: Prisma.$TeamInviteLinkPayload<ExtArgs>
        fields: Prisma.TeamInviteLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamInviteLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamInviteLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>
          }
          findFirst: {
            args: Prisma.TeamInviteLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamInviteLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>
          }
          findMany: {
            args: Prisma.TeamInviteLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>[]
          }
          create: {
            args: Prisma.TeamInviteLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>
          }
          createMany: {
            args: Prisma.TeamInviteLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamInviteLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>[]
          }
          delete: {
            args: Prisma.TeamInviteLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>
          }
          update: {
            args: Prisma.TeamInviteLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>
          }
          deleteMany: {
            args: Prisma.TeamInviteLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamInviteLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamInviteLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>[]
          }
          upsert: {
            args: Prisma.TeamInviteLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInviteLinkPayload>
          }
          aggregate: {
            args: Prisma.TeamInviteLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamInviteLink>
          }
          groupBy: {
            args: Prisma.TeamInviteLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamInviteLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamInviteLinkCountArgs<ExtArgs>
            result: $Utils.Optional<TeamInviteLinkCountAggregateOutputType> | number
          }
        }
      }
      CampaignAuditEvent: {
        payload: Prisma.$CampaignAuditEventPayload<ExtArgs>
        fields: Prisma.CampaignAuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignAuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignAuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>
          }
          findFirst: {
            args: Prisma.CampaignAuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignAuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>
          }
          findMany: {
            args: Prisma.CampaignAuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>[]
          }
          create: {
            args: Prisma.CampaignAuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>
          }
          createMany: {
            args: Prisma.CampaignAuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignAuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>[]
          }
          delete: {
            args: Prisma.CampaignAuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>
          }
          update: {
            args: Prisma.CampaignAuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>
          }
          deleteMany: {
            args: Prisma.CampaignAuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignAuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignAuditEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>[]
          }
          upsert: {
            args: Prisma.CampaignAuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAuditEventPayload>
          }
          aggregate: {
            args: Prisma.CampaignAuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignAuditEvent>
          }
          groupBy: {
            args: Prisma.CampaignAuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignAuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignAuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignAuditEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    campaign?: CampaignOmit
    campaignParticipation?: CampaignParticipationOmit
    smartLink?: SmartLinkOmit
    linkEvent?: LinkEventOmit
    referral?: ReferralOmit
    donation?: DonationOmit
    pointsLedgerEntry?: PointsLedgerEntryOmit
    leaderboardSnapshot?: LeaderboardSnapshotOmit
    trustScore?: TrustScoreOmit
    appNotification?: AppNotificationOmit
    viewProof?: ViewProofOmit
    group?: GroupOmit
    team?: TeamOmit
    teamInviteLink?: TeamInviteLinkOmit
    campaignAuditEvent?: CampaignAuditEventOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdCampaigns: number
    participations: number
    smartLinks: number
    referralsGiven: number
    referralsReceived: number
    donations: number
    verifiedDonations: number
    pointsLedger: number
    leaderboardEntries: number
    notifications: number
    viewProofs: number
    reviewedProofs: number
    teamInviteLinks: number
    auditEvents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdCampaigns?: boolean | UserCountOutputTypeCountCreatedCampaignsArgs
    participations?: boolean | UserCountOutputTypeCountParticipationsArgs
    smartLinks?: boolean | UserCountOutputTypeCountSmartLinksArgs
    referralsGiven?: boolean | UserCountOutputTypeCountReferralsGivenArgs
    referralsReceived?: boolean | UserCountOutputTypeCountReferralsReceivedArgs
    donations?: boolean | UserCountOutputTypeCountDonationsArgs
    verifiedDonations?: boolean | UserCountOutputTypeCountVerifiedDonationsArgs
    pointsLedger?: boolean | UserCountOutputTypeCountPointsLedgerArgs
    leaderboardEntries?: boolean | UserCountOutputTypeCountLeaderboardEntriesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    viewProofs?: boolean | UserCountOutputTypeCountViewProofsArgs
    reviewedProofs?: boolean | UserCountOutputTypeCountReviewedProofsArgs
    teamInviteLinks?: boolean | UserCountOutputTypeCountTeamInviteLinksArgs
    auditEvents?: boolean | UserCountOutputTypeCountAuditEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignParticipationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSmartLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmartLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsLedgerEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardSnapshotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViewProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewProofWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewProofWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInviteLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAuditEventWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    subCampaigns: number
    participations: number
    smartLinks: number
    referrals: number
    donations: number
    pointsLedger: number
    leaderboard: number
    viewProofs: number
    auditEvents: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCampaigns?: boolean | CampaignCountOutputTypeCountSubCampaignsArgs
    participations?: boolean | CampaignCountOutputTypeCountParticipationsArgs
    smartLinks?: boolean | CampaignCountOutputTypeCountSmartLinksArgs
    referrals?: boolean | CampaignCountOutputTypeCountReferralsArgs
    donations?: boolean | CampaignCountOutputTypeCountDonationsArgs
    pointsLedger?: boolean | CampaignCountOutputTypeCountPointsLedgerArgs
    leaderboard?: boolean | CampaignCountOutputTypeCountLeaderboardArgs
    viewProofs?: boolean | CampaignCountOutputTypeCountViewProofsArgs
    auditEvents?: boolean | CampaignCountOutputTypeCountAuditEventsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSubCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignParticipationWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSmartLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmartLinkWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountPointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsLedgerEntryWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardSnapshotWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountViewProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewProofWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAuditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAuditEventWhereInput
  }


  /**
   * Count Type SmartLinkCountOutputType
   */

  export type SmartLinkCountOutputType = {
    linkEvents: number
  }

  export type SmartLinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkEvents?: boolean | SmartLinkCountOutputTypeCountLinkEventsArgs
  }

  // Custom InputTypes
  /**
   * SmartLinkCountOutputType without action
   */
  export type SmartLinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLinkCountOutputType
     */
    select?: SmartLinkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SmartLinkCountOutputType without action
   */
  export type SmartLinkCountOutputTypeCountLinkEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkEventWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    teams: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | GroupCountOutputTypeCountTeamsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    teamInviteLinks: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    teamInviteLinks?: boolean | TeamCountOutputTypeCountTeamInviteLinksArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInviteLinkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    trustScore: number | null
  }

  export type UserSumAggregateOutputType = {
    trustScore: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    profilePicture: string | null
    whatsappNumber: string | null
    teamId: string | null
    trustScore: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    profilePicture: string | null
    whatsappNumber: string | null
    teamId: string | null
    trustScore: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    profilePicture: number
    whatsappNumber: number
    teamId: number
    trustScore: number
    isActive: number
    weaponsOfChoice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    trustScore?: true
  }

  export type UserSumAggregateInputType = {
    trustScore?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    profilePicture?: true
    whatsappNumber?: true
    teamId?: true
    trustScore?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    profilePicture?: true
    whatsappNumber?: true
    teamId?: true
    trustScore?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    profilePicture?: true
    whatsappNumber?: true
    teamId?: true
    trustScore?: true
    isActive?: true
    weaponsOfChoice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    profilePicture: string | null
    whatsappNumber: string | null
    teamId: string | null
    trustScore: number
    isActive: boolean
    weaponsOfChoice: $Enums.SocialPlatform[]
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    profilePicture?: boolean
    whatsappNumber?: boolean
    teamId?: boolean
    trustScore?: boolean
    isActive?: boolean
    weaponsOfChoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | User$teamArgs<ExtArgs>
    createdCampaigns?: boolean | User$createdCampaignsArgs<ExtArgs>
    participations?: boolean | User$participationsArgs<ExtArgs>
    smartLinks?: boolean | User$smartLinksArgs<ExtArgs>
    referralsGiven?: boolean | User$referralsGivenArgs<ExtArgs>
    referralsReceived?: boolean | User$referralsReceivedArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    verifiedDonations?: boolean | User$verifiedDonationsArgs<ExtArgs>
    pointsLedger?: boolean | User$pointsLedgerArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    trustScoreRecord?: boolean | User$trustScoreRecordArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    viewProofs?: boolean | User$viewProofsArgs<ExtArgs>
    reviewedProofs?: boolean | User$reviewedProofsArgs<ExtArgs>
    teamInviteLinks?: boolean | User$teamInviteLinksArgs<ExtArgs>
    auditEvents?: boolean | User$auditEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    profilePicture?: boolean
    whatsappNumber?: boolean
    teamId?: boolean
    trustScore?: boolean
    isActive?: boolean
    weaponsOfChoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | User$teamArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    profilePicture?: boolean
    whatsappNumber?: boolean
    teamId?: boolean
    trustScore?: boolean
    isActive?: boolean
    weaponsOfChoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | User$teamArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    profilePicture?: boolean
    whatsappNumber?: boolean
    teamId?: boolean
    trustScore?: boolean
    isActive?: boolean
    weaponsOfChoice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "firstName" | "lastName" | "role" | "profilePicture" | "whatsappNumber" | "teamId" | "trustScore" | "isActive" | "weaponsOfChoice" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | User$teamArgs<ExtArgs>
    createdCampaigns?: boolean | User$createdCampaignsArgs<ExtArgs>
    participations?: boolean | User$participationsArgs<ExtArgs>
    smartLinks?: boolean | User$smartLinksArgs<ExtArgs>
    referralsGiven?: boolean | User$referralsGivenArgs<ExtArgs>
    referralsReceived?: boolean | User$referralsReceivedArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    verifiedDonations?: boolean | User$verifiedDonationsArgs<ExtArgs>
    pointsLedger?: boolean | User$pointsLedgerArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    trustScoreRecord?: boolean | User$trustScoreRecordArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    viewProofs?: boolean | User$viewProofsArgs<ExtArgs>
    reviewedProofs?: boolean | User$reviewedProofsArgs<ExtArgs>
    teamInviteLinks?: boolean | User$teamInviteLinksArgs<ExtArgs>
    auditEvents?: boolean | User$auditEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | User$teamArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | User$teamArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs> | null
      createdCampaigns: Prisma.$CampaignPayload<ExtArgs>[]
      participations: Prisma.$CampaignParticipationPayload<ExtArgs>[]
      smartLinks: Prisma.$SmartLinkPayload<ExtArgs>[]
      referralsGiven: Prisma.$ReferralPayload<ExtArgs>[]
      referralsReceived: Prisma.$ReferralPayload<ExtArgs>[]
      donations: Prisma.$DonationPayload<ExtArgs>[]
      verifiedDonations: Prisma.$DonationPayload<ExtArgs>[]
      pointsLedger: Prisma.$PointsLedgerEntryPayload<ExtArgs>[]
      leaderboardEntries: Prisma.$LeaderboardSnapshotPayload<ExtArgs>[]
      trustScoreRecord: Prisma.$TrustScorePayload<ExtArgs> | null
      notifications: Prisma.$AppNotificationPayload<ExtArgs>[]
      viewProofs: Prisma.$ViewProofPayload<ExtArgs>[]
      reviewedProofs: Prisma.$ViewProofPayload<ExtArgs>[]
      teamInviteLinks: Prisma.$TeamInviteLinkPayload<ExtArgs>[]
      auditEvents: Prisma.$CampaignAuditEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      profilePicture: string | null
      whatsappNumber: string | null
      teamId: string | null
      trustScore: number
      isActive: boolean
      weaponsOfChoice: $Enums.SocialPlatform[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends User$teamArgs<ExtArgs> = {}>(args?: Subset<T, User$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdCampaigns<T extends User$createdCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participations<T extends User$participationsArgs<ExtArgs> = {}>(args?: Subset<T, User$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smartLinks<T extends User$smartLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$smartLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsGiven<T extends User$referralsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsReceived<T extends User$referralsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    donations<T extends User$donationsArgs<ExtArgs> = {}>(args?: Subset<T, User$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifiedDonations<T extends User$verifiedDonationsArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedDonationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointsLedger<T extends User$pointsLedgerArgs<ExtArgs> = {}>(args?: Subset<T, User$pointsLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboardEntries<T extends User$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trustScoreRecord<T extends User$trustScoreRecordArgs<ExtArgs> = {}>(args?: Subset<T, User$trustScoreRecordArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewProofs<T extends User$viewProofsArgs<ExtArgs> = {}>(args?: Subset<T, User$viewProofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewedProofs<T extends User$reviewedProofsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedProofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamInviteLinks<T extends User$teamInviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$teamInviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditEvents<T extends User$auditEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly whatsappNumber: FieldRef<"User", 'String'>
    readonly teamId: FieldRef<"User", 'String'>
    readonly trustScore: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly weaponsOfChoice: FieldRef<"User", 'SocialPlatform[]'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.team
   */
  export type User$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * User.createdCampaigns
   */
  export type User$createdCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.participations
   */
  export type User$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    where?: CampaignParticipationWhereInput
    orderBy?: CampaignParticipationOrderByWithRelationInput | CampaignParticipationOrderByWithRelationInput[]
    cursor?: CampaignParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignParticipationScalarFieldEnum | CampaignParticipationScalarFieldEnum[]
  }

  /**
   * User.smartLinks
   */
  export type User$smartLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    where?: SmartLinkWhereInput
    orderBy?: SmartLinkOrderByWithRelationInput | SmartLinkOrderByWithRelationInput[]
    cursor?: SmartLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SmartLinkScalarFieldEnum | SmartLinkScalarFieldEnum[]
  }

  /**
   * User.referralsGiven
   */
  export type User$referralsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referralsReceived
   */
  export type User$referralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.donations
   */
  export type User$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * User.verifiedDonations
   */
  export type User$verifiedDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * User.pointsLedger
   */
  export type User$pointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    where?: PointsLedgerEntryWhereInput
    orderBy?: PointsLedgerEntryOrderByWithRelationInput | PointsLedgerEntryOrderByWithRelationInput[]
    cursor?: PointsLedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointsLedgerEntryScalarFieldEnum | PointsLedgerEntryScalarFieldEnum[]
  }

  /**
   * User.leaderboardEntries
   */
  export type User$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    where?: LeaderboardSnapshotWhereInput
    orderBy?: LeaderboardSnapshotOrderByWithRelationInput | LeaderboardSnapshotOrderByWithRelationInput[]
    cursor?: LeaderboardSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[]
  }

  /**
   * User.trustScoreRecord
   */
  export type User$trustScoreRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    where?: TrustScoreWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    where?: AppNotificationWhereInput
    orderBy?: AppNotificationOrderByWithRelationInput | AppNotificationOrderByWithRelationInput[]
    cursor?: AppNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppNotificationScalarFieldEnum | AppNotificationScalarFieldEnum[]
  }

  /**
   * User.viewProofs
   */
  export type User$viewProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    where?: ViewProofWhereInput
    orderBy?: ViewProofOrderByWithRelationInput | ViewProofOrderByWithRelationInput[]
    cursor?: ViewProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewProofScalarFieldEnum | ViewProofScalarFieldEnum[]
  }

  /**
   * User.reviewedProofs
   */
  export type User$reviewedProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    where?: ViewProofWhereInput
    orderBy?: ViewProofOrderByWithRelationInput | ViewProofOrderByWithRelationInput[]
    cursor?: ViewProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewProofScalarFieldEnum | ViewProofScalarFieldEnum[]
  }

  /**
   * User.teamInviteLinks
   */
  export type User$teamInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    where?: TeamInviteLinkWhereInput
    orderBy?: TeamInviteLinkOrderByWithRelationInput | TeamInviteLinkOrderByWithRelationInput[]
    cursor?: TeamInviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamInviteLinkScalarFieldEnum | TeamInviteLinkScalarFieldEnum[]
  }

  /**
   * User.auditEvents
   */
  export type User$auditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    where?: CampaignAuditEventWhereInput
    orderBy?: CampaignAuditEventOrderByWithRelationInput | CampaignAuditEventOrderByWithRelationInput[]
    cursor?: CampaignAuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignAuditEventScalarFieldEnum | CampaignAuditEventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    goalTarget: number | null
    goalCurrent: number | null
    viewCount: number | null
    clickCount: number | null
    shareCount: number | null
    likeCount: number | null
    participantCount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    goalTarget: number | null
    goalCurrent: number | null
    viewCount: number | null
    clickCount: number | null
    shareCount: number | null
    likeCount: number | null
    participantCount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    mediaType: $Enums.CampaignMediaType | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    ctaText: string | null
    ctaUrl: string | null
    createdById: string | null
    status: $Enums.CampaignStatus | null
    goalType: $Enums.GoalType | null
    goalTarget: number | null
    goalCurrent: number | null
    startDate: Date | null
    endDate: Date | null
    publishedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaImage: string | null
    viewCount: number | null
    clickCount: number | null
    shareCount: number | null
    likeCount: number | null
    participantCount: number | null
    isMegaCampaign: boolean | null
    parentCampaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    mediaType: $Enums.CampaignMediaType | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    ctaText: string | null
    ctaUrl: string | null
    createdById: string | null
    status: $Enums.CampaignStatus | null
    goalType: $Enums.GoalType | null
    goalTarget: number | null
    goalCurrent: number | null
    startDate: Date | null
    endDate: Date | null
    publishedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaImage: string | null
    viewCount: number | null
    clickCount: number | null
    shareCount: number | null
    likeCount: number | null
    participantCount: number | null
    isMegaCampaign: boolean | null
    parentCampaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    media: number
    mediaType: number
    mediaUrl: number
    thumbnailUrl: number
    ctaText: number
    ctaUrl: number
    createdById: number
    status: number
    goalType: number
    goalTarget: number
    goalCurrent: number
    startDate: number
    endDate: number
    targetAudience: number
    publishedAt: number
    metaTitle: number
    metaDescription: number
    metaImage: number
    viewCount: number
    clickCount: number
    shareCount: number
    likeCount: number
    participantCount: number
    isMegaCampaign: number
    parentCampaignId: number
    bankAccountIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    goalTarget?: true
    goalCurrent?: true
    viewCount?: true
    clickCount?: true
    shareCount?: true
    likeCount?: true
    participantCount?: true
  }

  export type CampaignSumAggregateInputType = {
    goalTarget?: true
    goalCurrent?: true
    viewCount?: true
    clickCount?: true
    shareCount?: true
    likeCount?: true
    participantCount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    ctaText?: true
    ctaUrl?: true
    createdById?: true
    status?: true
    goalType?: true
    goalTarget?: true
    goalCurrent?: true
    startDate?: true
    endDate?: true
    publishedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaImage?: true
    viewCount?: true
    clickCount?: true
    shareCount?: true
    likeCount?: true
    participantCount?: true
    isMegaCampaign?: true
    parentCampaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    ctaText?: true
    ctaUrl?: true
    createdById?: true
    status?: true
    goalType?: true
    goalTarget?: true
    goalCurrent?: true
    startDate?: true
    endDate?: true
    publishedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaImage?: true
    viewCount?: true
    clickCount?: true
    shareCount?: true
    likeCount?: true
    participantCount?: true
    isMegaCampaign?: true
    parentCampaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    media?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    ctaText?: true
    ctaUrl?: true
    createdById?: true
    status?: true
    goalType?: true
    goalTarget?: true
    goalCurrent?: true
    startDate?: true
    endDate?: true
    targetAudience?: true
    publishedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaImage?: true
    viewCount?: true
    clickCount?: true
    shareCount?: true
    likeCount?: true
    participantCount?: true
    isMegaCampaign?: true
    parentCampaignId?: true
    bankAccountIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    title: string
    description: string
    content: string
    media: JsonValue
    mediaType: $Enums.CampaignMediaType | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    ctaText: string | null
    ctaUrl: string | null
    createdById: string
    status: $Enums.CampaignStatus
    goalType: $Enums.GoalType | null
    goalTarget: number | null
    goalCurrent: number | null
    startDate: Date | null
    endDate: Date | null
    targetAudience: string[]
    publishedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaImage: string | null
    viewCount: number
    clickCount: number
    shareCount: number
    likeCount: number | null
    participantCount: number | null
    isMegaCampaign: boolean | null
    parentCampaignId: string | null
    bankAccountIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    media?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    createdById?: boolean
    status?: boolean
    goalType?: boolean
    goalTarget?: boolean
    goalCurrent?: boolean
    startDate?: boolean
    endDate?: boolean
    targetAudience?: boolean
    publishedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaImage?: boolean
    viewCount?: boolean
    clickCount?: boolean
    shareCount?: boolean
    likeCount?: boolean
    participantCount?: boolean
    isMegaCampaign?: boolean
    parentCampaignId?: boolean
    bankAccountIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
    subCampaigns?: boolean | Campaign$subCampaignsArgs<ExtArgs>
    participations?: boolean | Campaign$participationsArgs<ExtArgs>
    smartLinks?: boolean | Campaign$smartLinksArgs<ExtArgs>
    referrals?: boolean | Campaign$referralsArgs<ExtArgs>
    donations?: boolean | Campaign$donationsArgs<ExtArgs>
    pointsLedger?: boolean | Campaign$pointsLedgerArgs<ExtArgs>
    leaderboard?: boolean | Campaign$leaderboardArgs<ExtArgs>
    viewProofs?: boolean | Campaign$viewProofsArgs<ExtArgs>
    auditEvents?: boolean | Campaign$auditEventsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    media?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    createdById?: boolean
    status?: boolean
    goalType?: boolean
    goalTarget?: boolean
    goalCurrent?: boolean
    startDate?: boolean
    endDate?: boolean
    targetAudience?: boolean
    publishedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaImage?: boolean
    viewCount?: boolean
    clickCount?: boolean
    shareCount?: boolean
    likeCount?: boolean
    participantCount?: boolean
    isMegaCampaign?: boolean
    parentCampaignId?: boolean
    bankAccountIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    media?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    createdById?: boolean
    status?: boolean
    goalType?: boolean
    goalTarget?: boolean
    goalCurrent?: boolean
    startDate?: boolean
    endDate?: boolean
    targetAudience?: boolean
    publishedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaImage?: boolean
    viewCount?: boolean
    clickCount?: boolean
    shareCount?: boolean
    likeCount?: boolean
    participantCount?: boolean
    isMegaCampaign?: boolean
    parentCampaignId?: boolean
    bankAccountIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    media?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    createdById?: boolean
    status?: boolean
    goalType?: boolean
    goalTarget?: boolean
    goalCurrent?: boolean
    startDate?: boolean
    endDate?: boolean
    targetAudience?: boolean
    publishedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaImage?: boolean
    viewCount?: boolean
    clickCount?: boolean
    shareCount?: boolean
    likeCount?: boolean
    participantCount?: boolean
    isMegaCampaign?: boolean
    parentCampaignId?: boolean
    bankAccountIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "media" | "mediaType" | "mediaUrl" | "thumbnailUrl" | "ctaText" | "ctaUrl" | "createdById" | "status" | "goalType" | "goalTarget" | "goalCurrent" | "startDate" | "endDate" | "targetAudience" | "publishedAt" | "metaTitle" | "metaDescription" | "metaImage" | "viewCount" | "clickCount" | "shareCount" | "likeCount" | "participantCount" | "isMegaCampaign" | "parentCampaignId" | "bankAccountIds" | "createdAt" | "updatedAt", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
    subCampaigns?: boolean | Campaign$subCampaignsArgs<ExtArgs>
    participations?: boolean | Campaign$participationsArgs<ExtArgs>
    smartLinks?: boolean | Campaign$smartLinksArgs<ExtArgs>
    referrals?: boolean | Campaign$referralsArgs<ExtArgs>
    donations?: boolean | Campaign$donationsArgs<ExtArgs>
    pointsLedger?: boolean | Campaign$pointsLedgerArgs<ExtArgs>
    leaderboard?: boolean | Campaign$leaderboardArgs<ExtArgs>
    viewProofs?: boolean | Campaign$viewProofsArgs<ExtArgs>
    auditEvents?: boolean | Campaign$auditEventsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentCampaign?: boolean | Campaign$parentCampaignArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      parentCampaign: Prisma.$CampaignPayload<ExtArgs> | null
      subCampaigns: Prisma.$CampaignPayload<ExtArgs>[]
      participations: Prisma.$CampaignParticipationPayload<ExtArgs>[]
      smartLinks: Prisma.$SmartLinkPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      donations: Prisma.$DonationPayload<ExtArgs>[]
      pointsLedger: Prisma.$PointsLedgerEntryPayload<ExtArgs>[]
      leaderboard: Prisma.$LeaderboardSnapshotPayload<ExtArgs>[]
      viewProofs: Prisma.$ViewProofPayload<ExtArgs>[]
      auditEvents: Prisma.$CampaignAuditEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      content: string
      media: Prisma.JsonValue
      mediaType: $Enums.CampaignMediaType | null
      mediaUrl: string | null
      thumbnailUrl: string | null
      ctaText: string | null
      ctaUrl: string | null
      createdById: string
      status: $Enums.CampaignStatus
      goalType: $Enums.GoalType | null
      goalTarget: number | null
      goalCurrent: number | null
      startDate: Date | null
      endDate: Date | null
      targetAudience: string[]
      publishedAt: Date | null
      metaTitle: string | null
      metaDescription: string | null
      metaImage: string | null
      viewCount: number
      clickCount: number
      shareCount: number
      likeCount: number | null
      participantCount: number | null
      isMegaCampaign: boolean | null
      parentCampaignId: string | null
      bankAccountIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentCampaign<T extends Campaign$parentCampaignArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$parentCampaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subCampaigns<T extends Campaign$subCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$subCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participations<T extends Campaign$participationsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smartLinks<T extends Campaign$smartLinksArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$smartLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends Campaign$referralsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    donations<T extends Campaign$donationsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointsLedger<T extends Campaign$pointsLedgerArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$pointsLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboard<T extends Campaign$leaderboardArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$leaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewProofs<T extends Campaign$viewProofsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$viewProofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditEvents<T extends Campaign$auditEventsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$auditEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly title: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly content: FieldRef<"Campaign", 'String'>
    readonly media: FieldRef<"Campaign", 'Json'>
    readonly mediaType: FieldRef<"Campaign", 'CampaignMediaType'>
    readonly mediaUrl: FieldRef<"Campaign", 'String'>
    readonly thumbnailUrl: FieldRef<"Campaign", 'String'>
    readonly ctaText: FieldRef<"Campaign", 'String'>
    readonly ctaUrl: FieldRef<"Campaign", 'String'>
    readonly createdById: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly goalType: FieldRef<"Campaign", 'GoalType'>
    readonly goalTarget: FieldRef<"Campaign", 'Int'>
    readonly goalCurrent: FieldRef<"Campaign", 'Int'>
    readonly startDate: FieldRef<"Campaign", 'DateTime'>
    readonly endDate: FieldRef<"Campaign", 'DateTime'>
    readonly targetAudience: FieldRef<"Campaign", 'String[]'>
    readonly publishedAt: FieldRef<"Campaign", 'DateTime'>
    readonly metaTitle: FieldRef<"Campaign", 'String'>
    readonly metaDescription: FieldRef<"Campaign", 'String'>
    readonly metaImage: FieldRef<"Campaign", 'String'>
    readonly viewCount: FieldRef<"Campaign", 'Int'>
    readonly clickCount: FieldRef<"Campaign", 'Int'>
    readonly shareCount: FieldRef<"Campaign", 'Int'>
    readonly likeCount: FieldRef<"Campaign", 'Int'>
    readonly participantCount: FieldRef<"Campaign", 'Int'>
    readonly isMegaCampaign: FieldRef<"Campaign", 'Boolean'>
    readonly parentCampaignId: FieldRef<"Campaign", 'String'>
    readonly bankAccountIds: FieldRef<"Campaign", 'String[]'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.parentCampaign
   */
  export type Campaign$parentCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * Campaign.subCampaigns
   */
  export type Campaign$subCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign.participations
   */
  export type Campaign$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    where?: CampaignParticipationWhereInput
    orderBy?: CampaignParticipationOrderByWithRelationInput | CampaignParticipationOrderByWithRelationInput[]
    cursor?: CampaignParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignParticipationScalarFieldEnum | CampaignParticipationScalarFieldEnum[]
  }

  /**
   * Campaign.smartLinks
   */
  export type Campaign$smartLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    where?: SmartLinkWhereInput
    orderBy?: SmartLinkOrderByWithRelationInput | SmartLinkOrderByWithRelationInput[]
    cursor?: SmartLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SmartLinkScalarFieldEnum | SmartLinkScalarFieldEnum[]
  }

  /**
   * Campaign.referrals
   */
  export type Campaign$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Campaign.donations
   */
  export type Campaign$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Campaign.pointsLedger
   */
  export type Campaign$pointsLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    where?: PointsLedgerEntryWhereInput
    orderBy?: PointsLedgerEntryOrderByWithRelationInput | PointsLedgerEntryOrderByWithRelationInput[]
    cursor?: PointsLedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointsLedgerEntryScalarFieldEnum | PointsLedgerEntryScalarFieldEnum[]
  }

  /**
   * Campaign.leaderboard
   */
  export type Campaign$leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    where?: LeaderboardSnapshotWhereInput
    orderBy?: LeaderboardSnapshotOrderByWithRelationInput | LeaderboardSnapshotOrderByWithRelationInput[]
    cursor?: LeaderboardSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[]
  }

  /**
   * Campaign.viewProofs
   */
  export type Campaign$viewProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    where?: ViewProofWhereInput
    orderBy?: ViewProofOrderByWithRelationInput | ViewProofOrderByWithRelationInput[]
    cursor?: ViewProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewProofScalarFieldEnum | ViewProofScalarFieldEnum[]
  }

  /**
   * Campaign.auditEvents
   */
  export type Campaign$auditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    where?: CampaignAuditEventWhereInput
    orderBy?: CampaignAuditEventOrderByWithRelationInput | CampaignAuditEventOrderByWithRelationInput[]
    cursor?: CampaignAuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignAuditEventScalarFieldEnum | CampaignAuditEventScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignParticipation
   */

  export type AggregateCampaignParticipation = {
    _count: CampaignParticipationCountAggregateOutputType | null
    _min: CampaignParticipationMinAggregateOutputType | null
    _max: CampaignParticipationMaxAggregateOutputType | null
  }

  export type CampaignParticipationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    joinedAt: Date | null
    smartLinkId: string | null
  }

  export type CampaignParticipationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    joinedAt: Date | null
    smartLinkId: string | null
  }

  export type CampaignParticipationCountAggregateOutputType = {
    id: number
    userId: number
    campaignId: number
    joinedAt: number
    smartLinkId: number
    _all: number
  }


  export type CampaignParticipationMinAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    joinedAt?: true
    smartLinkId?: true
  }

  export type CampaignParticipationMaxAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    joinedAt?: true
    smartLinkId?: true
  }

  export type CampaignParticipationCountAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    joinedAt?: true
    smartLinkId?: true
    _all?: true
  }

  export type CampaignParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignParticipation to aggregate.
     */
    where?: CampaignParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipations to fetch.
     */
    orderBy?: CampaignParticipationOrderByWithRelationInput | CampaignParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignParticipations
    **/
    _count?: true | CampaignParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignParticipationMaxAggregateInputType
  }

  export type GetCampaignParticipationAggregateType<T extends CampaignParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignParticipation[P]>
      : GetScalarType<T[P], AggregateCampaignParticipation[P]>
  }




  export type CampaignParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignParticipationWhereInput
    orderBy?: CampaignParticipationOrderByWithAggregationInput | CampaignParticipationOrderByWithAggregationInput[]
    by: CampaignParticipationScalarFieldEnum[] | CampaignParticipationScalarFieldEnum
    having?: CampaignParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignParticipationCountAggregateInputType | true
    _min?: CampaignParticipationMinAggregateInputType
    _max?: CampaignParticipationMaxAggregateInputType
  }

  export type CampaignParticipationGroupByOutputType = {
    id: string
    userId: string
    campaignId: string
    joinedAt: Date
    smartLinkId: string | null
    _count: CampaignParticipationCountAggregateOutputType | null
    _min: CampaignParticipationMinAggregateOutputType | null
    _max: CampaignParticipationMaxAggregateOutputType | null
  }

  type GetCampaignParticipationGroupByPayload<T extends CampaignParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignParticipationGroupByOutputType[P]>
        }
      >
    >


  export type CampaignParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    joinedAt?: boolean
    smartLinkId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignParticipation"]>

  export type CampaignParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    joinedAt?: boolean
    smartLinkId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignParticipation"]>

  export type CampaignParticipationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    joinedAt?: boolean
    smartLinkId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignParticipation"]>

  export type CampaignParticipationSelectScalar = {
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    joinedAt?: boolean
    smartLinkId?: boolean
  }

  export type CampaignParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "campaignId" | "joinedAt" | "smartLinkId", ExtArgs["result"]["campaignParticipation"]>
  export type CampaignParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignParticipationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignParticipation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      campaignId: string
      joinedAt: Date
      smartLinkId: string | null
    }, ExtArgs["result"]["campaignParticipation"]>
    composites: {}
  }

  type CampaignParticipationGetPayload<S extends boolean | null | undefined | CampaignParticipationDefaultArgs> = $Result.GetResult<Prisma.$CampaignParticipationPayload, S>

  type CampaignParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignParticipationCountAggregateInputType | true
    }

  export interface CampaignParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignParticipation'], meta: { name: 'CampaignParticipation' } }
    /**
     * Find zero or one CampaignParticipation that matches the filter.
     * @param {CampaignParticipationFindUniqueArgs} args - Arguments to find a CampaignParticipation
     * @example
     * // Get one CampaignParticipation
     * const campaignParticipation = await prisma.campaignParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignParticipationFindUniqueArgs>(args: SelectSubset<T, CampaignParticipationFindUniqueArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignParticipationFindUniqueOrThrowArgs} args - Arguments to find a CampaignParticipation
     * @example
     * // Get one CampaignParticipation
     * const campaignParticipation = await prisma.campaignParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipationFindFirstArgs} args - Arguments to find a CampaignParticipation
     * @example
     * // Get one CampaignParticipation
     * const campaignParticipation = await prisma.campaignParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignParticipationFindFirstArgs>(args?: SelectSubset<T, CampaignParticipationFindFirstArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipationFindFirstOrThrowArgs} args - Arguments to find a CampaignParticipation
     * @example
     * // Get one CampaignParticipation
     * const campaignParticipation = await prisma.campaignParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignParticipations
     * const campaignParticipations = await prisma.campaignParticipation.findMany()
     * 
     * // Get first 10 CampaignParticipations
     * const campaignParticipations = await prisma.campaignParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignParticipationWithIdOnly = await prisma.campaignParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignParticipationFindManyArgs>(args?: SelectSubset<T, CampaignParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignParticipation.
     * @param {CampaignParticipationCreateArgs} args - Arguments to create a CampaignParticipation.
     * @example
     * // Create one CampaignParticipation
     * const CampaignParticipation = await prisma.campaignParticipation.create({
     *   data: {
     *     // ... data to create a CampaignParticipation
     *   }
     * })
     * 
     */
    create<T extends CampaignParticipationCreateArgs>(args: SelectSubset<T, CampaignParticipationCreateArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignParticipations.
     * @param {CampaignParticipationCreateManyArgs} args - Arguments to create many CampaignParticipations.
     * @example
     * // Create many CampaignParticipations
     * const campaignParticipation = await prisma.campaignParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignParticipationCreateManyArgs>(args?: SelectSubset<T, CampaignParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignParticipations and returns the data saved in the database.
     * @param {CampaignParticipationCreateManyAndReturnArgs} args - Arguments to create many CampaignParticipations.
     * @example
     * // Create many CampaignParticipations
     * const campaignParticipation = await prisma.campaignParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignParticipations and only return the `id`
     * const campaignParticipationWithIdOnly = await prisma.campaignParticipation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignParticipation.
     * @param {CampaignParticipationDeleteArgs} args - Arguments to delete one CampaignParticipation.
     * @example
     * // Delete one CampaignParticipation
     * const CampaignParticipation = await prisma.campaignParticipation.delete({
     *   where: {
     *     // ... filter to delete one CampaignParticipation
     *   }
     * })
     * 
     */
    delete<T extends CampaignParticipationDeleteArgs>(args: SelectSubset<T, CampaignParticipationDeleteArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignParticipation.
     * @param {CampaignParticipationUpdateArgs} args - Arguments to update one CampaignParticipation.
     * @example
     * // Update one CampaignParticipation
     * const campaignParticipation = await prisma.campaignParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignParticipationUpdateArgs>(args: SelectSubset<T, CampaignParticipationUpdateArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignParticipations.
     * @param {CampaignParticipationDeleteManyArgs} args - Arguments to filter CampaignParticipations to delete.
     * @example
     * // Delete a few CampaignParticipations
     * const { count } = await prisma.campaignParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignParticipationDeleteManyArgs>(args?: SelectSubset<T, CampaignParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignParticipations
     * const campaignParticipation = await prisma.campaignParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignParticipationUpdateManyArgs>(args: SelectSubset<T, CampaignParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignParticipations and returns the data updated in the database.
     * @param {CampaignParticipationUpdateManyAndReturnArgs} args - Arguments to update many CampaignParticipations.
     * @example
     * // Update many CampaignParticipations
     * const campaignParticipation = await prisma.campaignParticipation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignParticipations and only return the `id`
     * const campaignParticipationWithIdOnly = await prisma.campaignParticipation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignParticipationUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignParticipationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignParticipation.
     * @param {CampaignParticipationUpsertArgs} args - Arguments to update or create a CampaignParticipation.
     * @example
     * // Update or create a CampaignParticipation
     * const campaignParticipation = await prisma.campaignParticipation.upsert({
     *   create: {
     *     // ... data to create a CampaignParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignParticipation we want to update
     *   }
     * })
     */
    upsert<T extends CampaignParticipationUpsertArgs>(args: SelectSubset<T, CampaignParticipationUpsertArgs<ExtArgs>>): Prisma__CampaignParticipationClient<$Result.GetResult<Prisma.$CampaignParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipationCountArgs} args - Arguments to filter CampaignParticipations to count.
     * @example
     * // Count the number of CampaignParticipations
     * const count = await prisma.campaignParticipation.count({
     *   where: {
     *     // ... the filter for the CampaignParticipations we want to count
     *   }
     * })
    **/
    count<T extends CampaignParticipationCountArgs>(
      args?: Subset<T, CampaignParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignParticipationAggregateArgs>(args: Subset<T, CampaignParticipationAggregateArgs>): Prisma.PrismaPromise<GetCampaignParticipationAggregateType<T>>

    /**
     * Group by CampaignParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignParticipationGroupByArgs['orderBy'] }
        : { orderBy?: CampaignParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignParticipation model
   */
  readonly fields: CampaignParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignParticipation model
   */
  interface CampaignParticipationFieldRefs {
    readonly id: FieldRef<"CampaignParticipation", 'String'>
    readonly userId: FieldRef<"CampaignParticipation", 'String'>
    readonly campaignId: FieldRef<"CampaignParticipation", 'String'>
    readonly joinedAt: FieldRef<"CampaignParticipation", 'DateTime'>
    readonly smartLinkId: FieldRef<"CampaignParticipation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CampaignParticipation findUnique
   */
  export type CampaignParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignParticipation to fetch.
     */
    where: CampaignParticipationWhereUniqueInput
  }

  /**
   * CampaignParticipation findUniqueOrThrow
   */
  export type CampaignParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignParticipation to fetch.
     */
    where: CampaignParticipationWhereUniqueInput
  }

  /**
   * CampaignParticipation findFirst
   */
  export type CampaignParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignParticipation to fetch.
     */
    where?: CampaignParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipations to fetch.
     */
    orderBy?: CampaignParticipationOrderByWithRelationInput | CampaignParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignParticipations.
     */
    cursor?: CampaignParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignParticipations.
     */
    distinct?: CampaignParticipationScalarFieldEnum | CampaignParticipationScalarFieldEnum[]
  }

  /**
   * CampaignParticipation findFirstOrThrow
   */
  export type CampaignParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignParticipation to fetch.
     */
    where?: CampaignParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipations to fetch.
     */
    orderBy?: CampaignParticipationOrderByWithRelationInput | CampaignParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignParticipations.
     */
    cursor?: CampaignParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignParticipations.
     */
    distinct?: CampaignParticipationScalarFieldEnum | CampaignParticipationScalarFieldEnum[]
  }

  /**
   * CampaignParticipation findMany
   */
  export type CampaignParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * Filter, which CampaignParticipations to fetch.
     */
    where?: CampaignParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipations to fetch.
     */
    orderBy?: CampaignParticipationOrderByWithRelationInput | CampaignParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignParticipations.
     */
    cursor?: CampaignParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipations.
     */
    skip?: number
    distinct?: CampaignParticipationScalarFieldEnum | CampaignParticipationScalarFieldEnum[]
  }

  /**
   * CampaignParticipation create
   */
  export type CampaignParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignParticipation.
     */
    data: XOR<CampaignParticipationCreateInput, CampaignParticipationUncheckedCreateInput>
  }

  /**
   * CampaignParticipation createMany
   */
  export type CampaignParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignParticipations.
     */
    data: CampaignParticipationCreateManyInput | CampaignParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignParticipation createManyAndReturn
   */
  export type CampaignParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignParticipations.
     */
    data: CampaignParticipationCreateManyInput | CampaignParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignParticipation update
   */
  export type CampaignParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignParticipation.
     */
    data: XOR<CampaignParticipationUpdateInput, CampaignParticipationUncheckedUpdateInput>
    /**
     * Choose, which CampaignParticipation to update.
     */
    where: CampaignParticipationWhereUniqueInput
  }

  /**
   * CampaignParticipation updateMany
   */
  export type CampaignParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignParticipations.
     */
    data: XOR<CampaignParticipationUpdateManyMutationInput, CampaignParticipationUncheckedUpdateManyInput>
    /**
     * Filter which CampaignParticipations to update
     */
    where?: CampaignParticipationWhereInput
    /**
     * Limit how many CampaignParticipations to update.
     */
    limit?: number
  }

  /**
   * CampaignParticipation updateManyAndReturn
   */
  export type CampaignParticipationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * The data used to update CampaignParticipations.
     */
    data: XOR<CampaignParticipationUpdateManyMutationInput, CampaignParticipationUncheckedUpdateManyInput>
    /**
     * Filter which CampaignParticipations to update
     */
    where?: CampaignParticipationWhereInput
    /**
     * Limit how many CampaignParticipations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignParticipation upsert
   */
  export type CampaignParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignParticipation to update in case it exists.
     */
    where: CampaignParticipationWhereUniqueInput
    /**
     * In case the CampaignParticipation found by the `where` argument doesn't exist, create a new CampaignParticipation with this data.
     */
    create: XOR<CampaignParticipationCreateInput, CampaignParticipationUncheckedCreateInput>
    /**
     * In case the CampaignParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignParticipationUpdateInput, CampaignParticipationUncheckedUpdateInput>
  }

  /**
   * CampaignParticipation delete
   */
  export type CampaignParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
    /**
     * Filter which CampaignParticipation to delete.
     */
    where: CampaignParticipationWhereUniqueInput
  }

  /**
   * CampaignParticipation deleteMany
   */
  export type CampaignParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignParticipations to delete
     */
    where?: CampaignParticipationWhereInput
    /**
     * Limit how many CampaignParticipations to delete.
     */
    limit?: number
  }

  /**
   * CampaignParticipation without action
   */
  export type CampaignParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignParticipation
     */
    select?: CampaignParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignParticipation
     */
    omit?: CampaignParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignParticipationInclude<ExtArgs> | null
  }


  /**
   * Model SmartLink
   */

  export type AggregateSmartLink = {
    _count: SmartLinkCountAggregateOutputType | null
    _avg: SmartLinkAvgAggregateOutputType | null
    _sum: SmartLinkSumAggregateOutputType | null
    _min: SmartLinkMinAggregateOutputType | null
    _max: SmartLinkMaxAggregateOutputType | null
  }

  export type SmartLinkAvgAggregateOutputType = {
    clickCount: number | null
    uniqueClickCount: number | null
    conversionCount: number | null
  }

  export type SmartLinkSumAggregateOutputType = {
    clickCount: number | null
    uniqueClickCount: number | null
    conversionCount: number | null
  }

  export type SmartLinkMinAggregateOutputType = {
    id: string | null
    slug: string | null
    userId: string | null
    campaignId: string | null
    originalUrl: string | null
    clickCount: number | null
    uniqueClickCount: number | null
    conversionCount: number | null
    isActive: boolean | null
    isExpired: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SmartLinkMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    userId: string | null
    campaignId: string | null
    originalUrl: string | null
    clickCount: number | null
    uniqueClickCount: number | null
    conversionCount: number | null
    isActive: boolean | null
    isExpired: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SmartLinkCountAggregateOutputType = {
    id: number
    slug: number
    userId: number
    campaignId: number
    originalUrl: number
    clickCount: number
    uniqueClickCount: number
    conversionCount: number
    isActive: number
    isExpired: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SmartLinkAvgAggregateInputType = {
    clickCount?: true
    uniqueClickCount?: true
    conversionCount?: true
  }

  export type SmartLinkSumAggregateInputType = {
    clickCount?: true
    uniqueClickCount?: true
    conversionCount?: true
  }

  export type SmartLinkMinAggregateInputType = {
    id?: true
    slug?: true
    userId?: true
    campaignId?: true
    originalUrl?: true
    clickCount?: true
    uniqueClickCount?: true
    conversionCount?: true
    isActive?: true
    isExpired?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SmartLinkMaxAggregateInputType = {
    id?: true
    slug?: true
    userId?: true
    campaignId?: true
    originalUrl?: true
    clickCount?: true
    uniqueClickCount?: true
    conversionCount?: true
    isActive?: true
    isExpired?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SmartLinkCountAggregateInputType = {
    id?: true
    slug?: true
    userId?: true
    campaignId?: true
    originalUrl?: true
    clickCount?: true
    uniqueClickCount?: true
    conversionCount?: true
    isActive?: true
    isExpired?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SmartLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmartLink to aggregate.
     */
    where?: SmartLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartLinks to fetch.
     */
    orderBy?: SmartLinkOrderByWithRelationInput | SmartLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SmartLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmartLinks
    **/
    _count?: true | SmartLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SmartLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SmartLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmartLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmartLinkMaxAggregateInputType
  }

  export type GetSmartLinkAggregateType<T extends SmartLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSmartLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmartLink[P]>
      : GetScalarType<T[P], AggregateSmartLink[P]>
  }




  export type SmartLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmartLinkWhereInput
    orderBy?: SmartLinkOrderByWithAggregationInput | SmartLinkOrderByWithAggregationInput[]
    by: SmartLinkScalarFieldEnum[] | SmartLinkScalarFieldEnum
    having?: SmartLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmartLinkCountAggregateInputType | true
    _avg?: SmartLinkAvgAggregateInputType
    _sum?: SmartLinkSumAggregateInputType
    _min?: SmartLinkMinAggregateInputType
    _max?: SmartLinkMaxAggregateInputType
  }

  export type SmartLinkGroupByOutputType = {
    id: string
    slug: string
    userId: string
    campaignId: string
    originalUrl: string
    clickCount: number
    uniqueClickCount: number
    conversionCount: number
    isActive: boolean
    isExpired: boolean
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SmartLinkCountAggregateOutputType | null
    _avg: SmartLinkAvgAggregateOutputType | null
    _sum: SmartLinkSumAggregateOutputType | null
    _min: SmartLinkMinAggregateOutputType | null
    _max: SmartLinkMaxAggregateOutputType | null
  }

  type GetSmartLinkGroupByPayload<T extends SmartLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SmartLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmartLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmartLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SmartLinkGroupByOutputType[P]>
        }
      >
    >


  export type SmartLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    userId?: boolean
    campaignId?: boolean
    originalUrl?: boolean
    clickCount?: boolean
    uniqueClickCount?: boolean
    conversionCount?: boolean
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    linkEvents?: boolean | SmartLink$linkEventsArgs<ExtArgs>
    _count?: boolean | SmartLinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smartLink"]>

  export type SmartLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    userId?: boolean
    campaignId?: boolean
    originalUrl?: boolean
    clickCount?: boolean
    uniqueClickCount?: boolean
    conversionCount?: boolean
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smartLink"]>

  export type SmartLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    userId?: boolean
    campaignId?: boolean
    originalUrl?: boolean
    clickCount?: boolean
    uniqueClickCount?: boolean
    conversionCount?: boolean
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smartLink"]>

  export type SmartLinkSelectScalar = {
    id?: boolean
    slug?: boolean
    userId?: boolean
    campaignId?: boolean
    originalUrl?: boolean
    clickCount?: boolean
    uniqueClickCount?: boolean
    conversionCount?: boolean
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SmartLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "userId" | "campaignId" | "originalUrl" | "clickCount" | "uniqueClickCount" | "conversionCount" | "isActive" | "isExpired" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["smartLink"]>
  export type SmartLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    linkEvents?: boolean | SmartLink$linkEventsArgs<ExtArgs>
    _count?: boolean | SmartLinkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SmartLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type SmartLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $SmartLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SmartLink"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
      linkEvents: Prisma.$LinkEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      userId: string
      campaignId: string
      originalUrl: string
      clickCount: number
      uniqueClickCount: number
      conversionCount: number
      isActive: boolean
      isExpired: boolean
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["smartLink"]>
    composites: {}
  }

  type SmartLinkGetPayload<S extends boolean | null | undefined | SmartLinkDefaultArgs> = $Result.GetResult<Prisma.$SmartLinkPayload, S>

  type SmartLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SmartLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SmartLinkCountAggregateInputType | true
    }

  export interface SmartLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SmartLink'], meta: { name: 'SmartLink' } }
    /**
     * Find zero or one SmartLink that matches the filter.
     * @param {SmartLinkFindUniqueArgs} args - Arguments to find a SmartLink
     * @example
     * // Get one SmartLink
     * const smartLink = await prisma.smartLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SmartLinkFindUniqueArgs>(args: SelectSubset<T, SmartLinkFindUniqueArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SmartLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SmartLinkFindUniqueOrThrowArgs} args - Arguments to find a SmartLink
     * @example
     * // Get one SmartLink
     * const smartLink = await prisma.smartLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SmartLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SmartLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmartLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartLinkFindFirstArgs} args - Arguments to find a SmartLink
     * @example
     * // Get one SmartLink
     * const smartLink = await prisma.smartLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SmartLinkFindFirstArgs>(args?: SelectSubset<T, SmartLinkFindFirstArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmartLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartLinkFindFirstOrThrowArgs} args - Arguments to find a SmartLink
     * @example
     * // Get one SmartLink
     * const smartLink = await prisma.smartLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SmartLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SmartLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SmartLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmartLinks
     * const smartLinks = await prisma.smartLink.findMany()
     * 
     * // Get first 10 SmartLinks
     * const smartLinks = await prisma.smartLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smartLinkWithIdOnly = await prisma.smartLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SmartLinkFindManyArgs>(args?: SelectSubset<T, SmartLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SmartLink.
     * @param {SmartLinkCreateArgs} args - Arguments to create a SmartLink.
     * @example
     * // Create one SmartLink
     * const SmartLink = await prisma.smartLink.create({
     *   data: {
     *     // ... data to create a SmartLink
     *   }
     * })
     * 
     */
    create<T extends SmartLinkCreateArgs>(args: SelectSubset<T, SmartLinkCreateArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SmartLinks.
     * @param {SmartLinkCreateManyArgs} args - Arguments to create many SmartLinks.
     * @example
     * // Create many SmartLinks
     * const smartLink = await prisma.smartLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SmartLinkCreateManyArgs>(args?: SelectSubset<T, SmartLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SmartLinks and returns the data saved in the database.
     * @param {SmartLinkCreateManyAndReturnArgs} args - Arguments to create many SmartLinks.
     * @example
     * // Create many SmartLinks
     * const smartLink = await prisma.smartLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SmartLinks and only return the `id`
     * const smartLinkWithIdOnly = await prisma.smartLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SmartLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, SmartLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SmartLink.
     * @param {SmartLinkDeleteArgs} args - Arguments to delete one SmartLink.
     * @example
     * // Delete one SmartLink
     * const SmartLink = await prisma.smartLink.delete({
     *   where: {
     *     // ... filter to delete one SmartLink
     *   }
     * })
     * 
     */
    delete<T extends SmartLinkDeleteArgs>(args: SelectSubset<T, SmartLinkDeleteArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SmartLink.
     * @param {SmartLinkUpdateArgs} args - Arguments to update one SmartLink.
     * @example
     * // Update one SmartLink
     * const smartLink = await prisma.smartLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SmartLinkUpdateArgs>(args: SelectSubset<T, SmartLinkUpdateArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SmartLinks.
     * @param {SmartLinkDeleteManyArgs} args - Arguments to filter SmartLinks to delete.
     * @example
     * // Delete a few SmartLinks
     * const { count } = await prisma.smartLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SmartLinkDeleteManyArgs>(args?: SelectSubset<T, SmartLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmartLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmartLinks
     * const smartLink = await prisma.smartLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SmartLinkUpdateManyArgs>(args: SelectSubset<T, SmartLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmartLinks and returns the data updated in the database.
     * @param {SmartLinkUpdateManyAndReturnArgs} args - Arguments to update many SmartLinks.
     * @example
     * // Update many SmartLinks
     * const smartLink = await prisma.smartLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SmartLinks and only return the `id`
     * const smartLinkWithIdOnly = await prisma.smartLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SmartLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, SmartLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SmartLink.
     * @param {SmartLinkUpsertArgs} args - Arguments to update or create a SmartLink.
     * @example
     * // Update or create a SmartLink
     * const smartLink = await prisma.smartLink.upsert({
     *   create: {
     *     // ... data to create a SmartLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmartLink we want to update
     *   }
     * })
     */
    upsert<T extends SmartLinkUpsertArgs>(args: SelectSubset<T, SmartLinkUpsertArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SmartLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartLinkCountArgs} args - Arguments to filter SmartLinks to count.
     * @example
     * // Count the number of SmartLinks
     * const count = await prisma.smartLink.count({
     *   where: {
     *     // ... the filter for the SmartLinks we want to count
     *   }
     * })
    **/
    count<T extends SmartLinkCountArgs>(
      args?: Subset<T, SmartLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmartLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmartLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmartLinkAggregateArgs>(args: Subset<T, SmartLinkAggregateArgs>): Prisma.PrismaPromise<GetSmartLinkAggregateType<T>>

    /**
     * Group by SmartLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmartLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmartLinkGroupByArgs['orderBy'] }
        : { orderBy?: SmartLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmartLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmartLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SmartLink model
   */
  readonly fields: SmartLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SmartLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SmartLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    linkEvents<T extends SmartLink$linkEventsArgs<ExtArgs> = {}>(args?: Subset<T, SmartLink$linkEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SmartLink model
   */
  interface SmartLinkFieldRefs {
    readonly id: FieldRef<"SmartLink", 'String'>
    readonly slug: FieldRef<"SmartLink", 'String'>
    readonly userId: FieldRef<"SmartLink", 'String'>
    readonly campaignId: FieldRef<"SmartLink", 'String'>
    readonly originalUrl: FieldRef<"SmartLink", 'String'>
    readonly clickCount: FieldRef<"SmartLink", 'Int'>
    readonly uniqueClickCount: FieldRef<"SmartLink", 'Int'>
    readonly conversionCount: FieldRef<"SmartLink", 'Int'>
    readonly isActive: FieldRef<"SmartLink", 'Boolean'>
    readonly isExpired: FieldRef<"SmartLink", 'Boolean'>
    readonly expiresAt: FieldRef<"SmartLink", 'DateTime'>
    readonly createdAt: FieldRef<"SmartLink", 'DateTime'>
    readonly updatedAt: FieldRef<"SmartLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SmartLink findUnique
   */
  export type SmartLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * Filter, which SmartLink to fetch.
     */
    where: SmartLinkWhereUniqueInput
  }

  /**
   * SmartLink findUniqueOrThrow
   */
  export type SmartLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * Filter, which SmartLink to fetch.
     */
    where: SmartLinkWhereUniqueInput
  }

  /**
   * SmartLink findFirst
   */
  export type SmartLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * Filter, which SmartLink to fetch.
     */
    where?: SmartLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartLinks to fetch.
     */
    orderBy?: SmartLinkOrderByWithRelationInput | SmartLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmartLinks.
     */
    cursor?: SmartLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmartLinks.
     */
    distinct?: SmartLinkScalarFieldEnum | SmartLinkScalarFieldEnum[]
  }

  /**
   * SmartLink findFirstOrThrow
   */
  export type SmartLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * Filter, which SmartLink to fetch.
     */
    where?: SmartLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartLinks to fetch.
     */
    orderBy?: SmartLinkOrderByWithRelationInput | SmartLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmartLinks.
     */
    cursor?: SmartLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmartLinks.
     */
    distinct?: SmartLinkScalarFieldEnum | SmartLinkScalarFieldEnum[]
  }

  /**
   * SmartLink findMany
   */
  export type SmartLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * Filter, which SmartLinks to fetch.
     */
    where?: SmartLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartLinks to fetch.
     */
    orderBy?: SmartLinkOrderByWithRelationInput | SmartLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmartLinks.
     */
    cursor?: SmartLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartLinks.
     */
    skip?: number
    distinct?: SmartLinkScalarFieldEnum | SmartLinkScalarFieldEnum[]
  }

  /**
   * SmartLink create
   */
  export type SmartLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SmartLink.
     */
    data: XOR<SmartLinkCreateInput, SmartLinkUncheckedCreateInput>
  }

  /**
   * SmartLink createMany
   */
  export type SmartLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SmartLinks.
     */
    data: SmartLinkCreateManyInput | SmartLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmartLink createManyAndReturn
   */
  export type SmartLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * The data used to create many SmartLinks.
     */
    data: SmartLinkCreateManyInput | SmartLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SmartLink update
   */
  export type SmartLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SmartLink.
     */
    data: XOR<SmartLinkUpdateInput, SmartLinkUncheckedUpdateInput>
    /**
     * Choose, which SmartLink to update.
     */
    where: SmartLinkWhereUniqueInput
  }

  /**
   * SmartLink updateMany
   */
  export type SmartLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SmartLinks.
     */
    data: XOR<SmartLinkUpdateManyMutationInput, SmartLinkUncheckedUpdateManyInput>
    /**
     * Filter which SmartLinks to update
     */
    where?: SmartLinkWhereInput
    /**
     * Limit how many SmartLinks to update.
     */
    limit?: number
  }

  /**
   * SmartLink updateManyAndReturn
   */
  export type SmartLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * The data used to update SmartLinks.
     */
    data: XOR<SmartLinkUpdateManyMutationInput, SmartLinkUncheckedUpdateManyInput>
    /**
     * Filter which SmartLinks to update
     */
    where?: SmartLinkWhereInput
    /**
     * Limit how many SmartLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SmartLink upsert
   */
  export type SmartLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SmartLink to update in case it exists.
     */
    where: SmartLinkWhereUniqueInput
    /**
     * In case the SmartLink found by the `where` argument doesn't exist, create a new SmartLink with this data.
     */
    create: XOR<SmartLinkCreateInput, SmartLinkUncheckedCreateInput>
    /**
     * In case the SmartLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmartLinkUpdateInput, SmartLinkUncheckedUpdateInput>
  }

  /**
   * SmartLink delete
   */
  export type SmartLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
    /**
     * Filter which SmartLink to delete.
     */
    where: SmartLinkWhereUniqueInput
  }

  /**
   * SmartLink deleteMany
   */
  export type SmartLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmartLinks to delete
     */
    where?: SmartLinkWhereInput
    /**
     * Limit how many SmartLinks to delete.
     */
    limit?: number
  }

  /**
   * SmartLink.linkEvents
   */
  export type SmartLink$linkEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    where?: LinkEventWhereInput
    orderBy?: LinkEventOrderByWithRelationInput | LinkEventOrderByWithRelationInput[]
    cursor?: LinkEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkEventScalarFieldEnum | LinkEventScalarFieldEnum[]
  }

  /**
   * SmartLink without action
   */
  export type SmartLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartLink
     */
    select?: SmartLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartLink
     */
    omit?: SmartLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SmartLinkInclude<ExtArgs> | null
  }


  /**
   * Model LinkEvent
   */

  export type AggregateLinkEvent = {
    _count: LinkEventCountAggregateOutputType | null
    _min: LinkEventMinAggregateOutputType | null
    _max: LinkEventMaxAggregateOutputType | null
  }

  export type LinkEventMinAggregateOutputType = {
    id: string | null
    linkId: string | null
    smartLinkId: string | null
    slug: string | null
    eventType: $Enums.LinkEventType | null
    type: $Enums.LinkEventType | null
    userId: string | null
    ipAddress: string | null
    ipHash: string | null
    userAgent: string | null
    referrer: string | null
    referer: string | null
    country: string | null
    createdAt: Date | null
  }

  export type LinkEventMaxAggregateOutputType = {
    id: string | null
    linkId: string | null
    smartLinkId: string | null
    slug: string | null
    eventType: $Enums.LinkEventType | null
    type: $Enums.LinkEventType | null
    userId: string | null
    ipAddress: string | null
    ipHash: string | null
    userAgent: string | null
    referrer: string | null
    referer: string | null
    country: string | null
    createdAt: Date | null
  }

  export type LinkEventCountAggregateOutputType = {
    id: number
    linkId: number
    smartLinkId: number
    slug: number
    eventType: number
    type: number
    userId: number
    ipAddress: number
    ipHash: number
    userAgent: number
    referrer: number
    referer: number
    country: number
    createdAt: number
    _all: number
  }


  export type LinkEventMinAggregateInputType = {
    id?: true
    linkId?: true
    smartLinkId?: true
    slug?: true
    eventType?: true
    type?: true
    userId?: true
    ipAddress?: true
    ipHash?: true
    userAgent?: true
    referrer?: true
    referer?: true
    country?: true
    createdAt?: true
  }

  export type LinkEventMaxAggregateInputType = {
    id?: true
    linkId?: true
    smartLinkId?: true
    slug?: true
    eventType?: true
    type?: true
    userId?: true
    ipAddress?: true
    ipHash?: true
    userAgent?: true
    referrer?: true
    referer?: true
    country?: true
    createdAt?: true
  }

  export type LinkEventCountAggregateInputType = {
    id?: true
    linkId?: true
    smartLinkId?: true
    slug?: true
    eventType?: true
    type?: true
    userId?: true
    ipAddress?: true
    ipHash?: true
    userAgent?: true
    referrer?: true
    referer?: true
    country?: true
    createdAt?: true
    _all?: true
  }

  export type LinkEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkEvent to aggregate.
     */
    where?: LinkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkEvents to fetch.
     */
    orderBy?: LinkEventOrderByWithRelationInput | LinkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkEvents
    **/
    _count?: true | LinkEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkEventMaxAggregateInputType
  }

  export type GetLinkEventAggregateType<T extends LinkEventAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkEvent[P]>
      : GetScalarType<T[P], AggregateLinkEvent[P]>
  }




  export type LinkEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkEventWhereInput
    orderBy?: LinkEventOrderByWithAggregationInput | LinkEventOrderByWithAggregationInput[]
    by: LinkEventScalarFieldEnum[] | LinkEventScalarFieldEnum
    having?: LinkEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkEventCountAggregateInputType | true
    _min?: LinkEventMinAggregateInputType
    _max?: LinkEventMaxAggregateInputType
  }

  export type LinkEventGroupByOutputType = {
    id: string
    linkId: string
    smartLinkId: string | null
    slug: string | null
    eventType: $Enums.LinkEventType
    type: $Enums.LinkEventType | null
    userId: string | null
    ipAddress: string | null
    ipHash: string | null
    userAgent: string | null
    referrer: string | null
    referer: string | null
    country: string | null
    createdAt: Date
    _count: LinkEventCountAggregateOutputType | null
    _min: LinkEventMinAggregateOutputType | null
    _max: LinkEventMaxAggregateOutputType | null
  }

  type GetLinkEventGroupByPayload<T extends LinkEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkEventGroupByOutputType[P]>
            : GetScalarType<T[P], LinkEventGroupByOutputType[P]>
        }
      >
    >


  export type LinkEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    smartLinkId?: boolean
    slug?: boolean
    eventType?: boolean
    type?: boolean
    userId?: boolean
    ipAddress?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    referer?: boolean
    country?: boolean
    createdAt?: boolean
    smartLink?: boolean | SmartLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkEvent"]>

  export type LinkEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    smartLinkId?: boolean
    slug?: boolean
    eventType?: boolean
    type?: boolean
    userId?: boolean
    ipAddress?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    referer?: boolean
    country?: boolean
    createdAt?: boolean
    smartLink?: boolean | SmartLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkEvent"]>

  export type LinkEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    smartLinkId?: boolean
    slug?: boolean
    eventType?: boolean
    type?: boolean
    userId?: boolean
    ipAddress?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    referer?: boolean
    country?: boolean
    createdAt?: boolean
    smartLink?: boolean | SmartLinkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkEvent"]>

  export type LinkEventSelectScalar = {
    id?: boolean
    linkId?: boolean
    smartLinkId?: boolean
    slug?: boolean
    eventType?: boolean
    type?: boolean
    userId?: boolean
    ipAddress?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    referer?: boolean
    country?: boolean
    createdAt?: boolean
  }

  export type LinkEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "linkId" | "smartLinkId" | "slug" | "eventType" | "type" | "userId" | "ipAddress" | "ipHash" | "userAgent" | "referrer" | "referer" | "country" | "createdAt", ExtArgs["result"]["linkEvent"]>
  export type LinkEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    smartLink?: boolean | SmartLinkDefaultArgs<ExtArgs>
  }
  export type LinkEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    smartLink?: boolean | SmartLinkDefaultArgs<ExtArgs>
  }
  export type LinkEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    smartLink?: boolean | SmartLinkDefaultArgs<ExtArgs>
  }

  export type $LinkEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkEvent"
    objects: {
      smartLink: Prisma.$SmartLinkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      linkId: string
      smartLinkId: string | null
      slug: string | null
      eventType: $Enums.LinkEventType
      type: $Enums.LinkEventType | null
      userId: string | null
      ipAddress: string | null
      ipHash: string | null
      userAgent: string | null
      referrer: string | null
      referer: string | null
      country: string | null
      createdAt: Date
    }, ExtArgs["result"]["linkEvent"]>
    composites: {}
  }

  type LinkEventGetPayload<S extends boolean | null | undefined | LinkEventDefaultArgs> = $Result.GetResult<Prisma.$LinkEventPayload, S>

  type LinkEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkEventCountAggregateInputType | true
    }

  export interface LinkEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkEvent'], meta: { name: 'LinkEvent' } }
    /**
     * Find zero or one LinkEvent that matches the filter.
     * @param {LinkEventFindUniqueArgs} args - Arguments to find a LinkEvent
     * @example
     * // Get one LinkEvent
     * const linkEvent = await prisma.linkEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkEventFindUniqueArgs>(args: SelectSubset<T, LinkEventFindUniqueArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinkEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkEventFindUniqueOrThrowArgs} args - Arguments to find a LinkEvent
     * @example
     * // Get one LinkEvent
     * const linkEvent = await prisma.linkEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkEventFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkEventFindFirstArgs} args - Arguments to find a LinkEvent
     * @example
     * // Get one LinkEvent
     * const linkEvent = await prisma.linkEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkEventFindFirstArgs>(args?: SelectSubset<T, LinkEventFindFirstArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkEventFindFirstOrThrowArgs} args - Arguments to find a LinkEvent
     * @example
     * // Get one LinkEvent
     * const linkEvent = await prisma.linkEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkEventFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinkEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkEvents
     * const linkEvents = await prisma.linkEvent.findMany()
     * 
     * // Get first 10 LinkEvents
     * const linkEvents = await prisma.linkEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkEventWithIdOnly = await prisma.linkEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkEventFindManyArgs>(args?: SelectSubset<T, LinkEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinkEvent.
     * @param {LinkEventCreateArgs} args - Arguments to create a LinkEvent.
     * @example
     * // Create one LinkEvent
     * const LinkEvent = await prisma.linkEvent.create({
     *   data: {
     *     // ... data to create a LinkEvent
     *   }
     * })
     * 
     */
    create<T extends LinkEventCreateArgs>(args: SelectSubset<T, LinkEventCreateArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinkEvents.
     * @param {LinkEventCreateManyArgs} args - Arguments to create many LinkEvents.
     * @example
     * // Create many LinkEvents
     * const linkEvent = await prisma.linkEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkEventCreateManyArgs>(args?: SelectSubset<T, LinkEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkEvents and returns the data saved in the database.
     * @param {LinkEventCreateManyAndReturnArgs} args - Arguments to create many LinkEvents.
     * @example
     * // Create many LinkEvents
     * const linkEvent = await prisma.linkEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkEvents and only return the `id`
     * const linkEventWithIdOnly = await prisma.linkEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkEventCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinkEvent.
     * @param {LinkEventDeleteArgs} args - Arguments to delete one LinkEvent.
     * @example
     * // Delete one LinkEvent
     * const LinkEvent = await prisma.linkEvent.delete({
     *   where: {
     *     // ... filter to delete one LinkEvent
     *   }
     * })
     * 
     */
    delete<T extends LinkEventDeleteArgs>(args: SelectSubset<T, LinkEventDeleteArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinkEvent.
     * @param {LinkEventUpdateArgs} args - Arguments to update one LinkEvent.
     * @example
     * // Update one LinkEvent
     * const linkEvent = await prisma.linkEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkEventUpdateArgs>(args: SelectSubset<T, LinkEventUpdateArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinkEvents.
     * @param {LinkEventDeleteManyArgs} args - Arguments to filter LinkEvents to delete.
     * @example
     * // Delete a few LinkEvents
     * const { count } = await prisma.linkEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkEventDeleteManyArgs>(args?: SelectSubset<T, LinkEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkEvents
     * const linkEvent = await prisma.linkEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkEventUpdateManyArgs>(args: SelectSubset<T, LinkEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkEvents and returns the data updated in the database.
     * @param {LinkEventUpdateManyAndReturnArgs} args - Arguments to update many LinkEvents.
     * @example
     * // Update many LinkEvents
     * const linkEvent = await prisma.linkEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkEvents and only return the `id`
     * const linkEventWithIdOnly = await prisma.linkEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkEventUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinkEvent.
     * @param {LinkEventUpsertArgs} args - Arguments to update or create a LinkEvent.
     * @example
     * // Update or create a LinkEvent
     * const linkEvent = await prisma.linkEvent.upsert({
     *   create: {
     *     // ... data to create a LinkEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkEvent we want to update
     *   }
     * })
     */
    upsert<T extends LinkEventUpsertArgs>(args: SelectSubset<T, LinkEventUpsertArgs<ExtArgs>>): Prisma__LinkEventClient<$Result.GetResult<Prisma.$LinkEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinkEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkEventCountArgs} args - Arguments to filter LinkEvents to count.
     * @example
     * // Count the number of LinkEvents
     * const count = await prisma.linkEvent.count({
     *   where: {
     *     // ... the filter for the LinkEvents we want to count
     *   }
     * })
    **/
    count<T extends LinkEventCountArgs>(
      args?: Subset<T, LinkEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkEventAggregateArgs>(args: Subset<T, LinkEventAggregateArgs>): Prisma.PrismaPromise<GetLinkEventAggregateType<T>>

    /**
     * Group by LinkEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkEventGroupByArgs['orderBy'] }
        : { orderBy?: LinkEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkEvent model
   */
  readonly fields: LinkEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    smartLink<T extends SmartLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SmartLinkDefaultArgs<ExtArgs>>): Prisma__SmartLinkClient<$Result.GetResult<Prisma.$SmartLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkEvent model
   */
  interface LinkEventFieldRefs {
    readonly id: FieldRef<"LinkEvent", 'String'>
    readonly linkId: FieldRef<"LinkEvent", 'String'>
    readonly smartLinkId: FieldRef<"LinkEvent", 'String'>
    readonly slug: FieldRef<"LinkEvent", 'String'>
    readonly eventType: FieldRef<"LinkEvent", 'LinkEventType'>
    readonly type: FieldRef<"LinkEvent", 'LinkEventType'>
    readonly userId: FieldRef<"LinkEvent", 'String'>
    readonly ipAddress: FieldRef<"LinkEvent", 'String'>
    readonly ipHash: FieldRef<"LinkEvent", 'String'>
    readonly userAgent: FieldRef<"LinkEvent", 'String'>
    readonly referrer: FieldRef<"LinkEvent", 'String'>
    readonly referer: FieldRef<"LinkEvent", 'String'>
    readonly country: FieldRef<"LinkEvent", 'String'>
    readonly createdAt: FieldRef<"LinkEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinkEvent findUnique
   */
  export type LinkEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * Filter, which LinkEvent to fetch.
     */
    where: LinkEventWhereUniqueInput
  }

  /**
   * LinkEvent findUniqueOrThrow
   */
  export type LinkEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * Filter, which LinkEvent to fetch.
     */
    where: LinkEventWhereUniqueInput
  }

  /**
   * LinkEvent findFirst
   */
  export type LinkEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * Filter, which LinkEvent to fetch.
     */
    where?: LinkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkEvents to fetch.
     */
    orderBy?: LinkEventOrderByWithRelationInput | LinkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkEvents.
     */
    cursor?: LinkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkEvents.
     */
    distinct?: LinkEventScalarFieldEnum | LinkEventScalarFieldEnum[]
  }

  /**
   * LinkEvent findFirstOrThrow
   */
  export type LinkEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * Filter, which LinkEvent to fetch.
     */
    where?: LinkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkEvents to fetch.
     */
    orderBy?: LinkEventOrderByWithRelationInput | LinkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkEvents.
     */
    cursor?: LinkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkEvents.
     */
    distinct?: LinkEventScalarFieldEnum | LinkEventScalarFieldEnum[]
  }

  /**
   * LinkEvent findMany
   */
  export type LinkEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * Filter, which LinkEvents to fetch.
     */
    where?: LinkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkEvents to fetch.
     */
    orderBy?: LinkEventOrderByWithRelationInput | LinkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkEvents.
     */
    cursor?: LinkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkEvents.
     */
    skip?: number
    distinct?: LinkEventScalarFieldEnum | LinkEventScalarFieldEnum[]
  }

  /**
   * LinkEvent create
   */
  export type LinkEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkEvent.
     */
    data: XOR<LinkEventCreateInput, LinkEventUncheckedCreateInput>
  }

  /**
   * LinkEvent createMany
   */
  export type LinkEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkEvents.
     */
    data: LinkEventCreateManyInput | LinkEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkEvent createManyAndReturn
   */
  export type LinkEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * The data used to create many LinkEvents.
     */
    data: LinkEventCreateManyInput | LinkEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkEvent update
   */
  export type LinkEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkEvent.
     */
    data: XOR<LinkEventUpdateInput, LinkEventUncheckedUpdateInput>
    /**
     * Choose, which LinkEvent to update.
     */
    where: LinkEventWhereUniqueInput
  }

  /**
   * LinkEvent updateMany
   */
  export type LinkEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkEvents.
     */
    data: XOR<LinkEventUpdateManyMutationInput, LinkEventUncheckedUpdateManyInput>
    /**
     * Filter which LinkEvents to update
     */
    where?: LinkEventWhereInput
    /**
     * Limit how many LinkEvents to update.
     */
    limit?: number
  }

  /**
   * LinkEvent updateManyAndReturn
   */
  export type LinkEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * The data used to update LinkEvents.
     */
    data: XOR<LinkEventUpdateManyMutationInput, LinkEventUncheckedUpdateManyInput>
    /**
     * Filter which LinkEvents to update
     */
    where?: LinkEventWhereInput
    /**
     * Limit how many LinkEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkEvent upsert
   */
  export type LinkEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkEvent to update in case it exists.
     */
    where: LinkEventWhereUniqueInput
    /**
     * In case the LinkEvent found by the `where` argument doesn't exist, create a new LinkEvent with this data.
     */
    create: XOR<LinkEventCreateInput, LinkEventUncheckedCreateInput>
    /**
     * In case the LinkEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkEventUpdateInput, LinkEventUncheckedUpdateInput>
  }

  /**
   * LinkEvent delete
   */
  export type LinkEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
    /**
     * Filter which LinkEvent to delete.
     */
    where: LinkEventWhereUniqueInput
  }

  /**
   * LinkEvent deleteMany
   */
  export type LinkEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkEvents to delete
     */
    where?: LinkEventWhereInput
    /**
     * Limit how many LinkEvents to delete.
     */
    limit?: number
  }

  /**
   * LinkEvent without action
   */
  export type LinkEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkEvent
     */
    select?: LinkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkEvent
     */
    omit?: LinkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkEventInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    inviterId: string | null
    inviteeId: string | null
    campaignId: string | null
    slug: string | null
    createdAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    inviterId: string | null
    inviteeId: string | null
    campaignId: string | null
    slug: string | null
    createdAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    inviterId: number
    inviteeId: number
    campaignId: number
    slug: number
    createdAt: number
    _all: number
  }


  export type ReferralMinAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    campaignId?: true
    slug?: true
    createdAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    campaignId?: true
    slug?: true
    createdAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    inviterId?: true
    inviteeId?: true
    campaignId?: true
    slug?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    inviterId: string
    inviteeId: string
    campaignId: string
    slug: string
    createdAt: Date
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    campaignId?: boolean
    slug?: boolean
    createdAt?: boolean
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitee?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    campaignId?: boolean
    slug?: boolean
    createdAt?: boolean
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitee?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    campaignId?: boolean
    slug?: boolean
    createdAt?: boolean
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitee?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    inviterId?: boolean
    inviteeId?: boolean
    campaignId?: boolean
    slug?: boolean
    createdAt?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inviterId" | "inviteeId" | "campaignId" | "slug" | "createdAt", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitee?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitee?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invitee?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      inviter: Prisma.$UserPayload<ExtArgs>
      invitee: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inviterId: string
      inviteeId: string
      campaignId: string
      slug: string
      createdAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly inviterId: FieldRef<"Referral", 'String'>
    readonly inviteeId: FieldRef<"Referral", 'String'>
    readonly campaignId: FieldRef<"Referral", 'String'>
    readonly slug: FieldRef<"Referral", 'String'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model Donation
   */

  export type AggregateDonation = {
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  export type DonationAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type DonationSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type DonationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.DonationStatus | null
    reference: string | null
    bankAccountId: string | null
    proofScreenshotUrl: string | null
    verifiedById: string | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.DonationStatus | null
    reference: string | null
    bankAccountId: string | null
    proofScreenshotUrl: string | null
    verifiedById: string | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationCountAggregateOutputType = {
    id: number
    userId: number
    campaignId: number
    amount: number
    currency: number
    status: number
    reference: number
    bankAccountId: number
    proofScreenshotUrl: number
    verifiedById: number
    verifiedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DonationAvgAggregateInputType = {
    amount?: true
  }

  export type DonationSumAggregateInputType = {
    amount?: true
  }

  export type DonationMinAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    amount?: true
    currency?: true
    status?: true
    reference?: true
    bankAccountId?: true
    proofScreenshotUrl?: true
    verifiedById?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationMaxAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    amount?: true
    currency?: true
    status?: true
    reference?: true
    bankAccountId?: true
    proofScreenshotUrl?: true
    verifiedById?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationCountAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    amount?: true
    currency?: true
    status?: true
    reference?: true
    bankAccountId?: true
    proofScreenshotUrl?: true
    verifiedById?: true
    verifiedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DonationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donation to aggregate.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donations
    **/
    _count?: true | DonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationMaxAggregateInputType
  }

  export type GetDonationAggregateType<T extends DonationAggregateArgs> = {
        [P in keyof T & keyof AggregateDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonation[P]>
      : GetScalarType<T[P], AggregateDonation[P]>
  }




  export type DonationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithAggregationInput | DonationOrderByWithAggregationInput[]
    by: DonationScalarFieldEnum[] | DonationScalarFieldEnum
    having?: DonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationCountAggregateInputType | true
    _avg?: DonationAvgAggregateInputType
    _sum?: DonationSumAggregateInputType
    _min?: DonationMinAggregateInputType
    _max?: DonationMaxAggregateInputType
  }

  export type DonationGroupByOutputType = {
    id: string
    userId: string
    campaignId: string
    amount: Decimal
    currency: string
    status: $Enums.DonationStatus
    reference: string
    bankAccountId: string | null
    proofScreenshotUrl: string | null
    verifiedById: string | null
    verifiedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  type GetDonationGroupByPayload<T extends DonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationGroupByOutputType[P]>
            : GetScalarType<T[P], DonationGroupByOutputType[P]>
        }
      >
    >


  export type DonationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    reference?: boolean
    bankAccountId?: boolean
    proofScreenshotUrl?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    verifiedBy?: boolean | Donation$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    reference?: boolean
    bankAccountId?: boolean
    proofScreenshotUrl?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    verifiedBy?: boolean | Donation$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    reference?: boolean
    bankAccountId?: boolean
    proofScreenshotUrl?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    verifiedBy?: boolean | Donation$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectScalar = {
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    reference?: boolean
    bankAccountId?: boolean
    proofScreenshotUrl?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DonationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "campaignId" | "amount" | "currency" | "status" | "reference" | "bankAccountId" | "proofScreenshotUrl" | "verifiedById" | "verifiedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["donation"]>
  export type DonationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    verifiedBy?: boolean | Donation$verifiedByArgs<ExtArgs>
  }
  export type DonationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    verifiedBy?: boolean | Donation$verifiedByArgs<ExtArgs>
  }
  export type DonationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    verifiedBy?: boolean | Donation$verifiedByArgs<ExtArgs>
  }

  export type $DonationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Donation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
      verifiedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      campaignId: string
      amount: Prisma.Decimal
      currency: string
      status: $Enums.DonationStatus
      reference: string
      bankAccountId: string | null
      proofScreenshotUrl: string | null
      verifiedById: string | null
      verifiedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["donation"]>
    composites: {}
  }

  type DonationGetPayload<S extends boolean | null | undefined | DonationDefaultArgs> = $Result.GetResult<Prisma.$DonationPayload, S>

  type DonationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DonationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonationCountAggregateInputType | true
    }

  export interface DonationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donation'], meta: { name: 'Donation' } }
    /**
     * Find zero or one Donation that matches the filter.
     * @param {DonationFindUniqueArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DonationFindUniqueArgs>(args: SelectSubset<T, DonationFindUniqueArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DonationFindUniqueOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DonationFindUniqueOrThrowArgs>(args: SelectSubset<T, DonationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DonationFindFirstArgs>(args?: SelectSubset<T, DonationFindFirstArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DonationFindFirstOrThrowArgs>(args?: SelectSubset<T, DonationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donation.findMany()
     * 
     * // Get first 10 Donations
     * const donations = await prisma.donation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationWithIdOnly = await prisma.donation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DonationFindManyArgs>(args?: SelectSubset<T, DonationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donation.
     * @param {DonationCreateArgs} args - Arguments to create a Donation.
     * @example
     * // Create one Donation
     * const Donation = await prisma.donation.create({
     *   data: {
     *     // ... data to create a Donation
     *   }
     * })
     * 
     */
    create<T extends DonationCreateArgs>(args: SelectSubset<T, DonationCreateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donations.
     * @param {DonationCreateManyArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donation = await prisma.donation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DonationCreateManyArgs>(args?: SelectSubset<T, DonationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Donations and returns the data saved in the database.
     * @param {DonationCreateManyAndReturnArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donation = await prisma.donation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Donations and only return the `id`
     * const donationWithIdOnly = await prisma.donation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DonationCreateManyAndReturnArgs>(args?: SelectSubset<T, DonationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Donation.
     * @param {DonationDeleteArgs} args - Arguments to delete one Donation.
     * @example
     * // Delete one Donation
     * const Donation = await prisma.donation.delete({
     *   where: {
     *     // ... filter to delete one Donation
     *   }
     * })
     * 
     */
    delete<T extends DonationDeleteArgs>(args: SelectSubset<T, DonationDeleteArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donation.
     * @param {DonationUpdateArgs} args - Arguments to update one Donation.
     * @example
     * // Update one Donation
     * const donation = await prisma.donation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DonationUpdateArgs>(args: SelectSubset<T, DonationUpdateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donations.
     * @param {DonationDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DonationDeleteManyArgs>(args?: SelectSubset<T, DonationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DonationUpdateManyArgs>(args: SelectSubset<T, DonationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations and returns the data updated in the database.
     * @param {DonationUpdateManyAndReturnArgs} args - Arguments to update many Donations.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Donations and only return the `id`
     * const donationWithIdOnly = await prisma.donation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DonationUpdateManyAndReturnArgs>(args: SelectSubset<T, DonationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Donation.
     * @param {DonationUpsertArgs} args - Arguments to update or create a Donation.
     * @example
     * // Update or create a Donation
     * const donation = await prisma.donation.upsert({
     *   create: {
     *     // ... data to create a Donation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donation we want to update
     *   }
     * })
     */
    upsert<T extends DonationUpsertArgs>(args: SelectSubset<T, DonationUpsertArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donation.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends DonationCountArgs>(
      args?: Subset<T, DonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationAggregateArgs>(args: Subset<T, DonationAggregateArgs>): Prisma.PrismaPromise<GetDonationAggregateType<T>>

    /**
     * Group by Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonationGroupByArgs['orderBy'] }
        : { orderBy?: DonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donation model
   */
  readonly fields: DonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verifiedBy<T extends Donation$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, Donation$verifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Donation model
   */
  interface DonationFieldRefs {
    readonly id: FieldRef<"Donation", 'String'>
    readonly userId: FieldRef<"Donation", 'String'>
    readonly campaignId: FieldRef<"Donation", 'String'>
    readonly amount: FieldRef<"Donation", 'Decimal'>
    readonly currency: FieldRef<"Donation", 'String'>
    readonly status: FieldRef<"Donation", 'DonationStatus'>
    readonly reference: FieldRef<"Donation", 'String'>
    readonly bankAccountId: FieldRef<"Donation", 'String'>
    readonly proofScreenshotUrl: FieldRef<"Donation", 'String'>
    readonly verifiedById: FieldRef<"Donation", 'String'>
    readonly verifiedAt: FieldRef<"Donation", 'DateTime'>
    readonly notes: FieldRef<"Donation", 'String'>
    readonly createdAt: FieldRef<"Donation", 'DateTime'>
    readonly updatedAt: FieldRef<"Donation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Donation findUnique
   */
  export type DonationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findUniqueOrThrow
   */
  export type DonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findFirst
   */
  export type DonationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findFirstOrThrow
   */
  export type DonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findMany
   */
  export type DonationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donations to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation create
   */
  export type DonationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to create a Donation.
     */
    data: XOR<DonationCreateInput, DonationUncheckedCreateInput>
  }

  /**
   * Donation createMany
   */
  export type DonationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donation createManyAndReturn
   */
  export type DonationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donation update
   */
  export type DonationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to update a Donation.
     */
    data: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
    /**
     * Choose, which Donation to update.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation updateMany
   */
  export type DonationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to update.
     */
    limit?: number
  }

  /**
   * Donation updateManyAndReturn
   */
  export type DonationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donation upsert
   */
  export type DonationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The filter to search for the Donation to update in case it exists.
     */
    where: DonationWhereUniqueInput
    /**
     * In case the Donation found by the `where` argument doesn't exist, create a new Donation with this data.
     */
    create: XOR<DonationCreateInput, DonationUncheckedCreateInput>
    /**
     * In case the Donation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
  }

  /**
   * Donation delete
   */
  export type DonationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter which Donation to delete.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation deleteMany
   */
  export type DonationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donations to delete
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to delete.
     */
    limit?: number
  }

  /**
   * Donation.verifiedBy
   */
  export type Donation$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Donation without action
   */
  export type DonationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
  }


  /**
   * Model PointsLedgerEntry
   */

  export type AggregatePointsLedgerEntry = {
    _count: PointsLedgerEntryCountAggregateOutputType | null
    _avg: PointsLedgerEntryAvgAggregateOutputType | null
    _sum: PointsLedgerEntrySumAggregateOutputType | null
    _min: PointsLedgerEntryMinAggregateOutputType | null
    _max: PointsLedgerEntryMaxAggregateOutputType | null
  }

  export type PointsLedgerEntryAvgAggregateOutputType = {
    value: number | null
  }

  export type PointsLedgerEntrySumAggregateOutputType = {
    value: number | null
  }

  export type PointsLedgerEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    type: $Enums.PointType | null
    value: number | null
    description: string | null
    referenceId: string | null
    createdAt: Date | null
  }

  export type PointsLedgerEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    type: $Enums.PointType | null
    value: number | null
    description: string | null
    referenceId: string | null
    createdAt: Date | null
  }

  export type PointsLedgerEntryCountAggregateOutputType = {
    id: number
    userId: number
    campaignId: number
    type: number
    value: number
    description: number
    referenceId: number
    createdAt: number
    _all: number
  }


  export type PointsLedgerEntryAvgAggregateInputType = {
    value?: true
  }

  export type PointsLedgerEntrySumAggregateInputType = {
    value?: true
  }

  export type PointsLedgerEntryMinAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    type?: true
    value?: true
    description?: true
    referenceId?: true
    createdAt?: true
  }

  export type PointsLedgerEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    type?: true
    value?: true
    description?: true
    referenceId?: true
    createdAt?: true
  }

  export type PointsLedgerEntryCountAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    type?: true
    value?: true
    description?: true
    referenceId?: true
    createdAt?: true
    _all?: true
  }

  export type PointsLedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsLedgerEntry to aggregate.
     */
    where?: PointsLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgerEntries to fetch.
     */
    orderBy?: PointsLedgerEntryOrderByWithRelationInput | PointsLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointsLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointsLedgerEntries
    **/
    _count?: true | PointsLedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointsLedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointsLedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointsLedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointsLedgerEntryMaxAggregateInputType
  }

  export type GetPointsLedgerEntryAggregateType<T extends PointsLedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePointsLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointsLedgerEntry[P]>
      : GetScalarType<T[P], AggregatePointsLedgerEntry[P]>
  }




  export type PointsLedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsLedgerEntryWhereInput
    orderBy?: PointsLedgerEntryOrderByWithAggregationInput | PointsLedgerEntryOrderByWithAggregationInput[]
    by: PointsLedgerEntryScalarFieldEnum[] | PointsLedgerEntryScalarFieldEnum
    having?: PointsLedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointsLedgerEntryCountAggregateInputType | true
    _avg?: PointsLedgerEntryAvgAggregateInputType
    _sum?: PointsLedgerEntrySumAggregateInputType
    _min?: PointsLedgerEntryMinAggregateInputType
    _max?: PointsLedgerEntryMaxAggregateInputType
  }

  export type PointsLedgerEntryGroupByOutputType = {
    id: string
    userId: string
    campaignId: string | null
    type: $Enums.PointType
    value: number
    description: string
    referenceId: string | null
    createdAt: Date
    _count: PointsLedgerEntryCountAggregateOutputType | null
    _avg: PointsLedgerEntryAvgAggregateOutputType | null
    _sum: PointsLedgerEntrySumAggregateOutputType | null
    _min: PointsLedgerEntryMinAggregateOutputType | null
    _max: PointsLedgerEntryMaxAggregateOutputType | null
  }

  type GetPointsLedgerEntryGroupByPayload<T extends PointsLedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointsLedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointsLedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointsLedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PointsLedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type PointsLedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | PointsLedgerEntry$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["pointsLedgerEntry"]>

  export type PointsLedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | PointsLedgerEntry$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["pointsLedgerEntry"]>

  export type PointsLedgerEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | PointsLedgerEntry$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["pointsLedgerEntry"]>

  export type PointsLedgerEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
  }

  export type PointsLedgerEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "campaignId" | "type" | "value" | "description" | "referenceId" | "createdAt", ExtArgs["result"]["pointsLedgerEntry"]>
  export type PointsLedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | PointsLedgerEntry$campaignArgs<ExtArgs>
  }
  export type PointsLedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | PointsLedgerEntry$campaignArgs<ExtArgs>
  }
  export type PointsLedgerEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | PointsLedgerEntry$campaignArgs<ExtArgs>
  }

  export type $PointsLedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointsLedgerEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      campaignId: string | null
      type: $Enums.PointType
      value: number
      description: string
      referenceId: string | null
      createdAt: Date
    }, ExtArgs["result"]["pointsLedgerEntry"]>
    composites: {}
  }

  type PointsLedgerEntryGetPayload<S extends boolean | null | undefined | PointsLedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$PointsLedgerEntryPayload, S>

  type PointsLedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointsLedgerEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointsLedgerEntryCountAggregateInputType | true
    }

  export interface PointsLedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointsLedgerEntry'], meta: { name: 'PointsLedgerEntry' } }
    /**
     * Find zero or one PointsLedgerEntry that matches the filter.
     * @param {PointsLedgerEntryFindUniqueArgs} args - Arguments to find a PointsLedgerEntry
     * @example
     * // Get one PointsLedgerEntry
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointsLedgerEntryFindUniqueArgs>(args: SelectSubset<T, PointsLedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointsLedgerEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointsLedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a PointsLedgerEntry
     * @example
     * // Get one PointsLedgerEntry
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointsLedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PointsLedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointsLedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerEntryFindFirstArgs} args - Arguments to find a PointsLedgerEntry
     * @example
     * // Get one PointsLedgerEntry
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointsLedgerEntryFindFirstArgs>(args?: SelectSubset<T, PointsLedgerEntryFindFirstArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointsLedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerEntryFindFirstOrThrowArgs} args - Arguments to find a PointsLedgerEntry
     * @example
     * // Get one PointsLedgerEntry
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointsLedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PointsLedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointsLedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointsLedgerEntries
     * const pointsLedgerEntries = await prisma.pointsLedgerEntry.findMany()
     * 
     * // Get first 10 PointsLedgerEntries
     * const pointsLedgerEntries = await prisma.pointsLedgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointsLedgerEntryWithIdOnly = await prisma.pointsLedgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointsLedgerEntryFindManyArgs>(args?: SelectSubset<T, PointsLedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointsLedgerEntry.
     * @param {PointsLedgerEntryCreateArgs} args - Arguments to create a PointsLedgerEntry.
     * @example
     * // Create one PointsLedgerEntry
     * const PointsLedgerEntry = await prisma.pointsLedgerEntry.create({
     *   data: {
     *     // ... data to create a PointsLedgerEntry
     *   }
     * })
     * 
     */
    create<T extends PointsLedgerEntryCreateArgs>(args: SelectSubset<T, PointsLedgerEntryCreateArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointsLedgerEntries.
     * @param {PointsLedgerEntryCreateManyArgs} args - Arguments to create many PointsLedgerEntries.
     * @example
     * // Create many PointsLedgerEntries
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointsLedgerEntryCreateManyArgs>(args?: SelectSubset<T, PointsLedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointsLedgerEntries and returns the data saved in the database.
     * @param {PointsLedgerEntryCreateManyAndReturnArgs} args - Arguments to create many PointsLedgerEntries.
     * @example
     * // Create many PointsLedgerEntries
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointsLedgerEntries and only return the `id`
     * const pointsLedgerEntryWithIdOnly = await prisma.pointsLedgerEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointsLedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, PointsLedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointsLedgerEntry.
     * @param {PointsLedgerEntryDeleteArgs} args - Arguments to delete one PointsLedgerEntry.
     * @example
     * // Delete one PointsLedgerEntry
     * const PointsLedgerEntry = await prisma.pointsLedgerEntry.delete({
     *   where: {
     *     // ... filter to delete one PointsLedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends PointsLedgerEntryDeleteArgs>(args: SelectSubset<T, PointsLedgerEntryDeleteArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointsLedgerEntry.
     * @param {PointsLedgerEntryUpdateArgs} args - Arguments to update one PointsLedgerEntry.
     * @example
     * // Update one PointsLedgerEntry
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointsLedgerEntryUpdateArgs>(args: SelectSubset<T, PointsLedgerEntryUpdateArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointsLedgerEntries.
     * @param {PointsLedgerEntryDeleteManyArgs} args - Arguments to filter PointsLedgerEntries to delete.
     * @example
     * // Delete a few PointsLedgerEntries
     * const { count } = await prisma.pointsLedgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointsLedgerEntryDeleteManyArgs>(args?: SelectSubset<T, PointsLedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointsLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointsLedgerEntries
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointsLedgerEntryUpdateManyArgs>(args: SelectSubset<T, PointsLedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointsLedgerEntries and returns the data updated in the database.
     * @param {PointsLedgerEntryUpdateManyAndReturnArgs} args - Arguments to update many PointsLedgerEntries.
     * @example
     * // Update many PointsLedgerEntries
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointsLedgerEntries and only return the `id`
     * const pointsLedgerEntryWithIdOnly = await prisma.pointsLedgerEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointsLedgerEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, PointsLedgerEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointsLedgerEntry.
     * @param {PointsLedgerEntryUpsertArgs} args - Arguments to update or create a PointsLedgerEntry.
     * @example
     * // Update or create a PointsLedgerEntry
     * const pointsLedgerEntry = await prisma.pointsLedgerEntry.upsert({
     *   create: {
     *     // ... data to create a PointsLedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointsLedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends PointsLedgerEntryUpsertArgs>(args: SelectSubset<T, PointsLedgerEntryUpsertArgs<ExtArgs>>): Prisma__PointsLedgerEntryClient<$Result.GetResult<Prisma.$PointsLedgerEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointsLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerEntryCountArgs} args - Arguments to filter PointsLedgerEntries to count.
     * @example
     * // Count the number of PointsLedgerEntries
     * const count = await prisma.pointsLedgerEntry.count({
     *   where: {
     *     // ... the filter for the PointsLedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends PointsLedgerEntryCountArgs>(
      args?: Subset<T, PointsLedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointsLedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointsLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointsLedgerEntryAggregateArgs>(args: Subset<T, PointsLedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetPointsLedgerEntryAggregateType<T>>

    /**
     * Group by PointsLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsLedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointsLedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointsLedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: PointsLedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointsLedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointsLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointsLedgerEntry model
   */
  readonly fields: PointsLedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointsLedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointsLedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends PointsLedgerEntry$campaignArgs<ExtArgs> = {}>(args?: Subset<T, PointsLedgerEntry$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointsLedgerEntry model
   */
  interface PointsLedgerEntryFieldRefs {
    readonly id: FieldRef<"PointsLedgerEntry", 'String'>
    readonly userId: FieldRef<"PointsLedgerEntry", 'String'>
    readonly campaignId: FieldRef<"PointsLedgerEntry", 'String'>
    readonly type: FieldRef<"PointsLedgerEntry", 'PointType'>
    readonly value: FieldRef<"PointsLedgerEntry", 'Int'>
    readonly description: FieldRef<"PointsLedgerEntry", 'String'>
    readonly referenceId: FieldRef<"PointsLedgerEntry", 'String'>
    readonly createdAt: FieldRef<"PointsLedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointsLedgerEntry findUnique
   */
  export type PointsLedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedgerEntry to fetch.
     */
    where: PointsLedgerEntryWhereUniqueInput
  }

  /**
   * PointsLedgerEntry findUniqueOrThrow
   */
  export type PointsLedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedgerEntry to fetch.
     */
    where: PointsLedgerEntryWhereUniqueInput
  }

  /**
   * PointsLedgerEntry findFirst
   */
  export type PointsLedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedgerEntry to fetch.
     */
    where?: PointsLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgerEntries to fetch.
     */
    orderBy?: PointsLedgerEntryOrderByWithRelationInput | PointsLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsLedgerEntries.
     */
    cursor?: PointsLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsLedgerEntries.
     */
    distinct?: PointsLedgerEntryScalarFieldEnum | PointsLedgerEntryScalarFieldEnum[]
  }

  /**
   * PointsLedgerEntry findFirstOrThrow
   */
  export type PointsLedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedgerEntry to fetch.
     */
    where?: PointsLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgerEntries to fetch.
     */
    orderBy?: PointsLedgerEntryOrderByWithRelationInput | PointsLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsLedgerEntries.
     */
    cursor?: PointsLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsLedgerEntries.
     */
    distinct?: PointsLedgerEntryScalarFieldEnum | PointsLedgerEntryScalarFieldEnum[]
  }

  /**
   * PointsLedgerEntry findMany
   */
  export type PointsLedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which PointsLedgerEntries to fetch.
     */
    where?: PointsLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsLedgerEntries to fetch.
     */
    orderBy?: PointsLedgerEntryOrderByWithRelationInput | PointsLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointsLedgerEntries.
     */
    cursor?: PointsLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsLedgerEntries.
     */
    skip?: number
    distinct?: PointsLedgerEntryScalarFieldEnum | PointsLedgerEntryScalarFieldEnum[]
  }

  /**
   * PointsLedgerEntry create
   */
  export type PointsLedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a PointsLedgerEntry.
     */
    data: XOR<PointsLedgerEntryCreateInput, PointsLedgerEntryUncheckedCreateInput>
  }

  /**
   * PointsLedgerEntry createMany
   */
  export type PointsLedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointsLedgerEntries.
     */
    data: PointsLedgerEntryCreateManyInput | PointsLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointsLedgerEntry createManyAndReturn
   */
  export type PointsLedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to create many PointsLedgerEntries.
     */
    data: PointsLedgerEntryCreateManyInput | PointsLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointsLedgerEntry update
   */
  export type PointsLedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a PointsLedgerEntry.
     */
    data: XOR<PointsLedgerEntryUpdateInput, PointsLedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which PointsLedgerEntry to update.
     */
    where: PointsLedgerEntryWhereUniqueInput
  }

  /**
   * PointsLedgerEntry updateMany
   */
  export type PointsLedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointsLedgerEntries.
     */
    data: XOR<PointsLedgerEntryUpdateManyMutationInput, PointsLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which PointsLedgerEntries to update
     */
    where?: PointsLedgerEntryWhereInput
    /**
     * Limit how many PointsLedgerEntries to update.
     */
    limit?: number
  }

  /**
   * PointsLedgerEntry updateManyAndReturn
   */
  export type PointsLedgerEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to update PointsLedgerEntries.
     */
    data: XOR<PointsLedgerEntryUpdateManyMutationInput, PointsLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which PointsLedgerEntries to update
     */
    where?: PointsLedgerEntryWhereInput
    /**
     * Limit how many PointsLedgerEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointsLedgerEntry upsert
   */
  export type PointsLedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the PointsLedgerEntry to update in case it exists.
     */
    where: PointsLedgerEntryWhereUniqueInput
    /**
     * In case the PointsLedgerEntry found by the `where` argument doesn't exist, create a new PointsLedgerEntry with this data.
     */
    create: XOR<PointsLedgerEntryCreateInput, PointsLedgerEntryUncheckedCreateInput>
    /**
     * In case the PointsLedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointsLedgerEntryUpdateInput, PointsLedgerEntryUncheckedUpdateInput>
  }

  /**
   * PointsLedgerEntry delete
   */
  export type PointsLedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which PointsLedgerEntry to delete.
     */
    where: PointsLedgerEntryWhereUniqueInput
  }

  /**
   * PointsLedgerEntry deleteMany
   */
  export type PointsLedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsLedgerEntries to delete
     */
    where?: PointsLedgerEntryWhereInput
    /**
     * Limit how many PointsLedgerEntries to delete.
     */
    limit?: number
  }

  /**
   * PointsLedgerEntry.campaign
   */
  export type PointsLedgerEntry$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * PointsLedgerEntry without action
   */
  export type PointsLedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsLedgerEntry
     */
    select?: PointsLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointsLedgerEntry
     */
    omit?: PointsLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointsLedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model LeaderboardSnapshot
   */

  export type AggregateLeaderboardSnapshot = {
    _count: LeaderboardSnapshotCountAggregateOutputType | null
    _avg: LeaderboardSnapshotAvgAggregateOutputType | null
    _sum: LeaderboardSnapshotSumAggregateOutputType | null
    _min: LeaderboardSnapshotMinAggregateOutputType | null
    _max: LeaderboardSnapshotMaxAggregateOutputType | null
  }

  export type LeaderboardSnapshotAvgAggregateOutputType = {
    rank: number | null
    score: number | null
  }

  export type LeaderboardSnapshotSumAggregateOutputType = {
    rank: number | null
    score: number | null
  }

  export type LeaderboardSnapshotMinAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    period: string | null
    rank: number | null
    score: number | null
    createdAt: Date | null
  }

  export type LeaderboardSnapshotMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    period: string | null
    rank: number | null
    score: number | null
    createdAt: Date | null
  }

  export type LeaderboardSnapshotCountAggregateOutputType = {
    id: number
    userId: number
    campaignId: number
    period: number
    rank: number
    score: number
    createdAt: number
    _all: number
  }


  export type LeaderboardSnapshotAvgAggregateInputType = {
    rank?: true
    score?: true
  }

  export type LeaderboardSnapshotSumAggregateInputType = {
    rank?: true
    score?: true
  }

  export type LeaderboardSnapshotMinAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    period?: true
    rank?: true
    score?: true
    createdAt?: true
  }

  export type LeaderboardSnapshotMaxAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    period?: true
    rank?: true
    score?: true
    createdAt?: true
  }

  export type LeaderboardSnapshotCountAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    period?: true
    rank?: true
    score?: true
    createdAt?: true
    _all?: true
  }

  export type LeaderboardSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardSnapshot to aggregate.
     */
    where?: LeaderboardSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?: LeaderboardSnapshotOrderByWithRelationInput | LeaderboardSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaderboardSnapshots
    **/
    _count?: true | LeaderboardSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardSnapshotMaxAggregateInputType
  }

  export type GetLeaderboardSnapshotAggregateType<T extends LeaderboardSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboardSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardSnapshot[P]>
      : GetScalarType<T[P], AggregateLeaderboardSnapshot[P]>
  }




  export type LeaderboardSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardSnapshotWhereInput
    orderBy?: LeaderboardSnapshotOrderByWithAggregationInput | LeaderboardSnapshotOrderByWithAggregationInput[]
    by: LeaderboardSnapshotScalarFieldEnum[] | LeaderboardSnapshotScalarFieldEnum
    having?: LeaderboardSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardSnapshotCountAggregateInputType | true
    _avg?: LeaderboardSnapshotAvgAggregateInputType
    _sum?: LeaderboardSnapshotSumAggregateInputType
    _min?: LeaderboardSnapshotMinAggregateInputType
    _max?: LeaderboardSnapshotMaxAggregateInputType
  }

  export type LeaderboardSnapshotGroupByOutputType = {
    id: string
    userId: string
    campaignId: string | null
    period: string
    rank: number
    score: number
    createdAt: Date
    _count: LeaderboardSnapshotCountAggregateOutputType | null
    _avg: LeaderboardSnapshotAvgAggregateOutputType | null
    _sum: LeaderboardSnapshotSumAggregateOutputType | null
    _min: LeaderboardSnapshotMinAggregateOutputType | null
    _max: LeaderboardSnapshotMaxAggregateOutputType | null
  }

  type GetLeaderboardSnapshotGroupByPayload<T extends LeaderboardSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    period?: boolean
    rank?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | LeaderboardSnapshot$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardSnapshot"]>

  export type LeaderboardSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    period?: boolean
    rank?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | LeaderboardSnapshot$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardSnapshot"]>

  export type LeaderboardSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    period?: boolean
    rank?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | LeaderboardSnapshot$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboardSnapshot"]>

  export type LeaderboardSnapshotSelectScalar = {
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    period?: boolean
    rank?: boolean
    score?: boolean
    createdAt?: boolean
  }

  export type LeaderboardSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "campaignId" | "period" | "rank" | "score" | "createdAt", ExtArgs["result"]["leaderboardSnapshot"]>
  export type LeaderboardSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | LeaderboardSnapshot$campaignArgs<ExtArgs>
  }
  export type LeaderboardSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | LeaderboardSnapshot$campaignArgs<ExtArgs>
  }
  export type LeaderboardSnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | LeaderboardSnapshot$campaignArgs<ExtArgs>
  }

  export type $LeaderboardSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaderboardSnapshot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      campaignId: string | null
      period: string
      rank: number
      score: number
      createdAt: Date
    }, ExtArgs["result"]["leaderboardSnapshot"]>
    composites: {}
  }

  type LeaderboardSnapshotGetPayload<S extends boolean | null | undefined | LeaderboardSnapshotDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardSnapshotPayload, S>

  type LeaderboardSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaderboardSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaderboardSnapshotCountAggregateInputType | true
    }

  export interface LeaderboardSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardSnapshot'], meta: { name: 'LeaderboardSnapshot' } }
    /**
     * Find zero or one LeaderboardSnapshot that matches the filter.
     * @param {LeaderboardSnapshotFindUniqueArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardSnapshotFindUniqueArgs>(args: SelectSubset<T, LeaderboardSnapshotFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaderboardSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaderboardSnapshotFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaderboardSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotFindFirstArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardSnapshotFindFirstArgs>(args?: SelectSubset<T, LeaderboardSnapshotFindFirstArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaderboardSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotFindFirstOrThrowArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaderboardSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardSnapshots
     * const leaderboardSnapshots = await prisma.leaderboardSnapshot.findMany()
     * 
     * // Get first 10 LeaderboardSnapshots
     * const leaderboardSnapshots = await prisma.leaderboardSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardSnapshotWithIdOnly = await prisma.leaderboardSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderboardSnapshotFindManyArgs>(args?: SelectSubset<T, LeaderboardSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaderboardSnapshot.
     * @param {LeaderboardSnapshotCreateArgs} args - Arguments to create a LeaderboardSnapshot.
     * @example
     * // Create one LeaderboardSnapshot
     * const LeaderboardSnapshot = await prisma.leaderboardSnapshot.create({
     *   data: {
     *     // ... data to create a LeaderboardSnapshot
     *   }
     * })
     * 
     */
    create<T extends LeaderboardSnapshotCreateArgs>(args: SelectSubset<T, LeaderboardSnapshotCreateArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaderboardSnapshots.
     * @param {LeaderboardSnapshotCreateManyArgs} args - Arguments to create many LeaderboardSnapshots.
     * @example
     * // Create many LeaderboardSnapshots
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardSnapshotCreateManyArgs>(args?: SelectSubset<T, LeaderboardSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaderboardSnapshots and returns the data saved in the database.
     * @param {LeaderboardSnapshotCreateManyAndReturnArgs} args - Arguments to create many LeaderboardSnapshots.
     * @example
     * // Create many LeaderboardSnapshots
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaderboardSnapshots and only return the `id`
     * const leaderboardSnapshotWithIdOnly = await prisma.leaderboardSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaderboardSnapshot.
     * @param {LeaderboardSnapshotDeleteArgs} args - Arguments to delete one LeaderboardSnapshot.
     * @example
     * // Delete one LeaderboardSnapshot
     * const LeaderboardSnapshot = await prisma.leaderboardSnapshot.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardSnapshot
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardSnapshotDeleteArgs>(args: SelectSubset<T, LeaderboardSnapshotDeleteArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaderboardSnapshot.
     * @param {LeaderboardSnapshotUpdateArgs} args - Arguments to update one LeaderboardSnapshot.
     * @example
     * // Update one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardSnapshotUpdateArgs>(args: SelectSubset<T, LeaderboardSnapshotUpdateArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaderboardSnapshots.
     * @param {LeaderboardSnapshotDeleteManyArgs} args - Arguments to filter LeaderboardSnapshots to delete.
     * @example
     * // Delete a few LeaderboardSnapshots
     * const { count } = await prisma.leaderboardSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardSnapshotDeleteManyArgs>(args?: SelectSubset<T, LeaderboardSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardSnapshots
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardSnapshotUpdateManyArgs>(args: SelectSubset<T, LeaderboardSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaderboardSnapshots and returns the data updated in the database.
     * @param {LeaderboardSnapshotUpdateManyAndReturnArgs} args - Arguments to update many LeaderboardSnapshots.
     * @example
     * // Update many LeaderboardSnapshots
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaderboardSnapshots and only return the `id`
     * const leaderboardSnapshotWithIdOnly = await prisma.leaderboardSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaderboardSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaderboardSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaderboardSnapshot.
     * @param {LeaderboardSnapshotUpsertArgs} args - Arguments to update or create a LeaderboardSnapshot.
     * @example
     * // Update or create a LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.upsert({
     *   create: {
     *     // ... data to create a LeaderboardSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardSnapshotUpsertArgs>(args: SelectSubset<T, LeaderboardSnapshotUpsertArgs<ExtArgs>>): Prisma__LeaderboardSnapshotClient<$Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaderboardSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotCountArgs} args - Arguments to filter LeaderboardSnapshots to count.
     * @example
     * // Count the number of LeaderboardSnapshots
     * const count = await prisma.leaderboardSnapshot.count({
     *   where: {
     *     // ... the filter for the LeaderboardSnapshots we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardSnapshotCountArgs>(
      args?: Subset<T, LeaderboardSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaderboardSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardSnapshotAggregateArgs>(args: Subset<T, LeaderboardSnapshotAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardSnapshotAggregateType<T>>

    /**
     * Group by LeaderboardSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaderboardSnapshot model
   */
  readonly fields: LeaderboardSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends LeaderboardSnapshot$campaignArgs<ExtArgs> = {}>(args?: Subset<T, LeaderboardSnapshot$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaderboardSnapshot model
   */
  interface LeaderboardSnapshotFieldRefs {
    readonly id: FieldRef<"LeaderboardSnapshot", 'String'>
    readonly userId: FieldRef<"LeaderboardSnapshot", 'String'>
    readonly campaignId: FieldRef<"LeaderboardSnapshot", 'String'>
    readonly period: FieldRef<"LeaderboardSnapshot", 'String'>
    readonly rank: FieldRef<"LeaderboardSnapshot", 'Int'>
    readonly score: FieldRef<"LeaderboardSnapshot", 'Int'>
    readonly createdAt: FieldRef<"LeaderboardSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaderboardSnapshot findUnique
   */
  export type LeaderboardSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where: LeaderboardSnapshotWhereUniqueInput
  }

  /**
   * LeaderboardSnapshot findUniqueOrThrow
   */
  export type LeaderboardSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where: LeaderboardSnapshotWhereUniqueInput
  }

  /**
   * LeaderboardSnapshot findFirst
   */
  export type LeaderboardSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where?: LeaderboardSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?: LeaderboardSnapshotOrderByWithRelationInput | LeaderboardSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardSnapshots.
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardSnapshots.
     */
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[]
  }

  /**
   * LeaderboardSnapshot findFirstOrThrow
   */
  export type LeaderboardSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where?: LeaderboardSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?: LeaderboardSnapshotOrderByWithRelationInput | LeaderboardSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaderboardSnapshots.
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaderboardSnapshots.
     */
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[]
  }

  /**
   * LeaderboardSnapshot findMany
   */
  export type LeaderboardSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which LeaderboardSnapshots to fetch.
     */
    where?: LeaderboardSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?: LeaderboardSnapshotOrderByWithRelationInput | LeaderboardSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaderboardSnapshots.
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[]
  }

  /**
   * LeaderboardSnapshot create
   */
  export type LeaderboardSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaderboardSnapshot.
     */
    data: XOR<LeaderboardSnapshotCreateInput, LeaderboardSnapshotUncheckedCreateInput>
  }

  /**
   * LeaderboardSnapshot createMany
   */
  export type LeaderboardSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaderboardSnapshots.
     */
    data: LeaderboardSnapshotCreateManyInput | LeaderboardSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaderboardSnapshot createManyAndReturn
   */
  export type LeaderboardSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many LeaderboardSnapshots.
     */
    data: LeaderboardSnapshotCreateManyInput | LeaderboardSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaderboardSnapshot update
   */
  export type LeaderboardSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaderboardSnapshot.
     */
    data: XOR<LeaderboardSnapshotUpdateInput, LeaderboardSnapshotUncheckedUpdateInput>
    /**
     * Choose, which LeaderboardSnapshot to update.
     */
    where: LeaderboardSnapshotWhereUniqueInput
  }

  /**
   * LeaderboardSnapshot updateMany
   */
  export type LeaderboardSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaderboardSnapshots.
     */
    data: XOR<LeaderboardSnapshotUpdateManyMutationInput, LeaderboardSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardSnapshots to update
     */
    where?: LeaderboardSnapshotWhereInput
    /**
     * Limit how many LeaderboardSnapshots to update.
     */
    limit?: number
  }

  /**
   * LeaderboardSnapshot updateManyAndReturn
   */
  export type LeaderboardSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update LeaderboardSnapshots.
     */
    data: XOR<LeaderboardSnapshotUpdateManyMutationInput, LeaderboardSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which LeaderboardSnapshots to update
     */
    where?: LeaderboardSnapshotWhereInput
    /**
     * Limit how many LeaderboardSnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaderboardSnapshot upsert
   */
  export type LeaderboardSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaderboardSnapshot to update in case it exists.
     */
    where: LeaderboardSnapshotWhereUniqueInput
    /**
     * In case the LeaderboardSnapshot found by the `where` argument doesn't exist, create a new LeaderboardSnapshot with this data.
     */
    create: XOR<LeaderboardSnapshotCreateInput, LeaderboardSnapshotUncheckedCreateInput>
    /**
     * In case the LeaderboardSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardSnapshotUpdateInput, LeaderboardSnapshotUncheckedUpdateInput>
  }

  /**
   * LeaderboardSnapshot delete
   */
  export type LeaderboardSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
    /**
     * Filter which LeaderboardSnapshot to delete.
     */
    where: LeaderboardSnapshotWhereUniqueInput
  }

  /**
   * LeaderboardSnapshot deleteMany
   */
  export type LeaderboardSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaderboardSnapshots to delete
     */
    where?: LeaderboardSnapshotWhereInput
    /**
     * Limit how many LeaderboardSnapshots to delete.
     */
    limit?: number
  }

  /**
   * LeaderboardSnapshot.campaign
   */
  export type LeaderboardSnapshot$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * LeaderboardSnapshot without action
   */
  export type LeaderboardSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaderboardSnapshot
     */
    omit?: LeaderboardSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model TrustScore
   */

  export type AggregateTrustScore = {
    _count: TrustScoreCountAggregateOutputType | null
    _avg: TrustScoreAvgAggregateOutputType | null
    _sum: TrustScoreSumAggregateOutputType | null
    _min: TrustScoreMinAggregateOutputType | null
    _max: TrustScoreMaxAggregateOutputType | null
  }

  export type TrustScoreAvgAggregateOutputType = {
    score: number | null
  }

  export type TrustScoreSumAggregateOutputType = {
    score: number | null
  }

  export type TrustScoreMinAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
    lastReviewedAt: Date | null
    updatedAt: Date | null
  }

  export type TrustScoreMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
    lastReviewedAt: Date | null
    updatedAt: Date | null
  }

  export type TrustScoreCountAggregateOutputType = {
    id: number
    userId: number
    score: number
    flags: number
    lastReviewedAt: number
    updatedAt: number
    _all: number
  }


  export type TrustScoreAvgAggregateInputType = {
    score?: true
  }

  export type TrustScoreSumAggregateInputType = {
    score?: true
  }

  export type TrustScoreMinAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    lastReviewedAt?: true
    updatedAt?: true
  }

  export type TrustScoreMaxAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    lastReviewedAt?: true
    updatedAt?: true
  }

  export type TrustScoreCountAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    flags?: true
    lastReviewedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrustScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustScore to aggregate.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrustScores
    **/
    _count?: true | TrustScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrustScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrustScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrustScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrustScoreMaxAggregateInputType
  }

  export type GetTrustScoreAggregateType<T extends TrustScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateTrustScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrustScore[P]>
      : GetScalarType<T[P], AggregateTrustScore[P]>
  }




  export type TrustScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustScoreWhereInput
    orderBy?: TrustScoreOrderByWithAggregationInput | TrustScoreOrderByWithAggregationInput[]
    by: TrustScoreScalarFieldEnum[] | TrustScoreScalarFieldEnum
    having?: TrustScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrustScoreCountAggregateInputType | true
    _avg?: TrustScoreAvgAggregateInputType
    _sum?: TrustScoreSumAggregateInputType
    _min?: TrustScoreMinAggregateInputType
    _max?: TrustScoreMaxAggregateInputType
  }

  export type TrustScoreGroupByOutputType = {
    id: string
    userId: string
    score: number
    flags: $Enums.TrustFlag[]
    lastReviewedAt: Date | null
    updatedAt: Date
    _count: TrustScoreCountAggregateOutputType | null
    _avg: TrustScoreAvgAggregateOutputType | null
    _sum: TrustScoreSumAggregateOutputType | null
    _min: TrustScoreMinAggregateOutputType | null
    _max: TrustScoreMaxAggregateOutputType | null
  }

  type GetTrustScoreGroupByPayload<T extends TrustScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrustScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrustScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrustScoreGroupByOutputType[P]>
            : GetScalarType<T[P], TrustScoreGroupByOutputType[P]>
        }
      >
    >


  export type TrustScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    flags?: boolean
    lastReviewedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustScore"]>

  export type TrustScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    flags?: boolean
    lastReviewedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustScore"]>

  export type TrustScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    flags?: boolean
    lastReviewedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustScore"]>

  export type TrustScoreSelectScalar = {
    id?: boolean
    userId?: boolean
    score?: boolean
    flags?: boolean
    lastReviewedAt?: boolean
    updatedAt?: boolean
  }

  export type TrustScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "score" | "flags" | "lastReviewedAt" | "updatedAt", ExtArgs["result"]["trustScore"]>
  export type TrustScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrustScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrustScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrustScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrustScore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      score: number
      flags: $Enums.TrustFlag[]
      lastReviewedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["trustScore"]>
    composites: {}
  }

  type TrustScoreGetPayload<S extends boolean | null | undefined | TrustScoreDefaultArgs> = $Result.GetResult<Prisma.$TrustScorePayload, S>

  type TrustScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrustScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrustScoreCountAggregateInputType | true
    }

  export interface TrustScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrustScore'], meta: { name: 'TrustScore' } }
    /**
     * Find zero or one TrustScore that matches the filter.
     * @param {TrustScoreFindUniqueArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrustScoreFindUniqueArgs>(args: SelectSubset<T, TrustScoreFindUniqueArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrustScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrustScoreFindUniqueOrThrowArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrustScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, TrustScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreFindFirstArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrustScoreFindFirstArgs>(args?: SelectSubset<T, TrustScoreFindFirstArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrustScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreFindFirstOrThrowArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrustScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, TrustScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrustScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrustScores
     * const trustScores = await prisma.trustScore.findMany()
     * 
     * // Get first 10 TrustScores
     * const trustScores = await prisma.trustScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trustScoreWithIdOnly = await prisma.trustScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrustScoreFindManyArgs>(args?: SelectSubset<T, TrustScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrustScore.
     * @param {TrustScoreCreateArgs} args - Arguments to create a TrustScore.
     * @example
     * // Create one TrustScore
     * const TrustScore = await prisma.trustScore.create({
     *   data: {
     *     // ... data to create a TrustScore
     *   }
     * })
     * 
     */
    create<T extends TrustScoreCreateArgs>(args: SelectSubset<T, TrustScoreCreateArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrustScores.
     * @param {TrustScoreCreateManyArgs} args - Arguments to create many TrustScores.
     * @example
     * // Create many TrustScores
     * const trustScore = await prisma.trustScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrustScoreCreateManyArgs>(args?: SelectSubset<T, TrustScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrustScores and returns the data saved in the database.
     * @param {TrustScoreCreateManyAndReturnArgs} args - Arguments to create many TrustScores.
     * @example
     * // Create many TrustScores
     * const trustScore = await prisma.trustScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrustScores and only return the `id`
     * const trustScoreWithIdOnly = await prisma.trustScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrustScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, TrustScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrustScore.
     * @param {TrustScoreDeleteArgs} args - Arguments to delete one TrustScore.
     * @example
     * // Delete one TrustScore
     * const TrustScore = await prisma.trustScore.delete({
     *   where: {
     *     // ... filter to delete one TrustScore
     *   }
     * })
     * 
     */
    delete<T extends TrustScoreDeleteArgs>(args: SelectSubset<T, TrustScoreDeleteArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrustScore.
     * @param {TrustScoreUpdateArgs} args - Arguments to update one TrustScore.
     * @example
     * // Update one TrustScore
     * const trustScore = await prisma.trustScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrustScoreUpdateArgs>(args: SelectSubset<T, TrustScoreUpdateArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrustScores.
     * @param {TrustScoreDeleteManyArgs} args - Arguments to filter TrustScores to delete.
     * @example
     * // Delete a few TrustScores
     * const { count } = await prisma.trustScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrustScoreDeleteManyArgs>(args?: SelectSubset<T, TrustScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrustScores
     * const trustScore = await prisma.trustScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrustScoreUpdateManyArgs>(args: SelectSubset<T, TrustScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustScores and returns the data updated in the database.
     * @param {TrustScoreUpdateManyAndReturnArgs} args - Arguments to update many TrustScores.
     * @example
     * // Update many TrustScores
     * const trustScore = await prisma.trustScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrustScores and only return the `id`
     * const trustScoreWithIdOnly = await prisma.trustScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrustScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, TrustScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrustScore.
     * @param {TrustScoreUpsertArgs} args - Arguments to update or create a TrustScore.
     * @example
     * // Update or create a TrustScore
     * const trustScore = await prisma.trustScore.upsert({
     *   create: {
     *     // ... data to create a TrustScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrustScore we want to update
     *   }
     * })
     */
    upsert<T extends TrustScoreUpsertArgs>(args: SelectSubset<T, TrustScoreUpsertArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrustScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreCountArgs} args - Arguments to filter TrustScores to count.
     * @example
     * // Count the number of TrustScores
     * const count = await prisma.trustScore.count({
     *   where: {
     *     // ... the filter for the TrustScores we want to count
     *   }
     * })
    **/
    count<T extends TrustScoreCountArgs>(
      args?: Subset<T, TrustScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrustScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrustScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrustScoreAggregateArgs>(args: Subset<T, TrustScoreAggregateArgs>): Prisma.PrismaPromise<GetTrustScoreAggregateType<T>>

    /**
     * Group by TrustScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrustScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrustScoreGroupByArgs['orderBy'] }
        : { orderBy?: TrustScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrustScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrustScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrustScore model
   */
  readonly fields: TrustScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrustScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrustScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrustScore model
   */
  interface TrustScoreFieldRefs {
    readonly id: FieldRef<"TrustScore", 'String'>
    readonly userId: FieldRef<"TrustScore", 'String'>
    readonly score: FieldRef<"TrustScore", 'Int'>
    readonly flags: FieldRef<"TrustScore", 'TrustFlag[]'>
    readonly lastReviewedAt: FieldRef<"TrustScore", 'DateTime'>
    readonly updatedAt: FieldRef<"TrustScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrustScore findUnique
   */
  export type TrustScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore findUniqueOrThrow
   */
  export type TrustScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore findFirst
   */
  export type TrustScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustScores.
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustScores.
     */
    distinct?: TrustScoreScalarFieldEnum | TrustScoreScalarFieldEnum[]
  }

  /**
   * TrustScore findFirstOrThrow
   */
  export type TrustScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustScores.
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustScores.
     */
    distinct?: TrustScoreScalarFieldEnum | TrustScoreScalarFieldEnum[]
  }

  /**
   * TrustScore findMany
   */
  export type TrustScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScores to fetch.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrustScores.
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    distinct?: TrustScoreScalarFieldEnum | TrustScoreScalarFieldEnum[]
  }

  /**
   * TrustScore create
   */
  export type TrustScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a TrustScore.
     */
    data: XOR<TrustScoreCreateInput, TrustScoreUncheckedCreateInput>
  }

  /**
   * TrustScore createMany
   */
  export type TrustScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrustScores.
     */
    data: TrustScoreCreateManyInput | TrustScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrustScore createManyAndReturn
   */
  export type TrustScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * The data used to create many TrustScores.
     */
    data: TrustScoreCreateManyInput | TrustScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrustScore update
   */
  export type TrustScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a TrustScore.
     */
    data: XOR<TrustScoreUpdateInput, TrustScoreUncheckedUpdateInput>
    /**
     * Choose, which TrustScore to update.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore updateMany
   */
  export type TrustScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrustScores.
     */
    data: XOR<TrustScoreUpdateManyMutationInput, TrustScoreUncheckedUpdateManyInput>
    /**
     * Filter which TrustScores to update
     */
    where?: TrustScoreWhereInput
    /**
     * Limit how many TrustScores to update.
     */
    limit?: number
  }

  /**
   * TrustScore updateManyAndReturn
   */
  export type TrustScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * The data used to update TrustScores.
     */
    data: XOR<TrustScoreUpdateManyMutationInput, TrustScoreUncheckedUpdateManyInput>
    /**
     * Filter which TrustScores to update
     */
    where?: TrustScoreWhereInput
    /**
     * Limit how many TrustScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrustScore upsert
   */
  export type TrustScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the TrustScore to update in case it exists.
     */
    where: TrustScoreWhereUniqueInput
    /**
     * In case the TrustScore found by the `where` argument doesn't exist, create a new TrustScore with this data.
     */
    create: XOR<TrustScoreCreateInput, TrustScoreUncheckedCreateInput>
    /**
     * In case the TrustScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrustScoreUpdateInput, TrustScoreUncheckedUpdateInput>
  }

  /**
   * TrustScore delete
   */
  export type TrustScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter which TrustScore to delete.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore deleteMany
   */
  export type TrustScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustScores to delete
     */
    where?: TrustScoreWhereInput
    /**
     * Limit how many TrustScores to delete.
     */
    limit?: number
  }

  /**
   * TrustScore without action
   */
  export type TrustScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrustScore
     */
    omit?: TrustScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
  }


  /**
   * Model AppNotification
   */

  export type AggregateAppNotification = {
    _count: AppNotificationCountAggregateOutputType | null
    _min: AppNotificationMinAggregateOutputType | null
    _max: AppNotificationMaxAggregateOutputType | null
  }

  export type AppNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    body: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type AppNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    body: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type AppNotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    body: number
    isRead: number
    link: number
    createdAt: number
    _all: number
  }


  export type AppNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    isRead?: true
    link?: true
    createdAt?: true
  }

  export type AppNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    isRead?: true
    link?: true
    createdAt?: true
  }

  export type AppNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    isRead?: true
    link?: true
    createdAt?: true
    _all?: true
  }

  export type AppNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppNotification to aggregate.
     */
    where?: AppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppNotifications to fetch.
     */
    orderBy?: AppNotificationOrderByWithRelationInput | AppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppNotifications
    **/
    _count?: true | AppNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppNotificationMaxAggregateInputType
  }

  export type GetAppNotificationAggregateType<T extends AppNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateAppNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppNotification[P]>
      : GetScalarType<T[P], AggregateAppNotification[P]>
  }




  export type AppNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppNotificationWhereInput
    orderBy?: AppNotificationOrderByWithAggregationInput | AppNotificationOrderByWithAggregationInput[]
    by: AppNotificationScalarFieldEnum[] | AppNotificationScalarFieldEnum
    having?: AppNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppNotificationCountAggregateInputType | true
    _min?: AppNotificationMinAggregateInputType
    _max?: AppNotificationMaxAggregateInputType
  }

  export type AppNotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    body: string
    isRead: boolean
    link: string | null
    createdAt: Date
    _count: AppNotificationCountAggregateOutputType | null
    _min: AppNotificationMinAggregateOutputType | null
    _max: AppNotificationMaxAggregateOutputType | null
  }

  type GetAppNotificationGroupByPayload<T extends AppNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], AppNotificationGroupByOutputType[P]>
        }
      >
    >


  export type AppNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appNotification"]>

  export type AppNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appNotification"]>

  export type AppNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appNotification"]>

  export type AppNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    isRead?: boolean
    link?: boolean
    createdAt?: boolean
  }

  export type AppNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "body" | "isRead" | "link" | "createdAt", ExtArgs["result"]["appNotification"]>
  export type AppNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AppNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AppNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AppNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      body: string
      isRead: boolean
      link: string | null
      createdAt: Date
    }, ExtArgs["result"]["appNotification"]>
    composites: {}
  }

  type AppNotificationGetPayload<S extends boolean | null | undefined | AppNotificationDefaultArgs> = $Result.GetResult<Prisma.$AppNotificationPayload, S>

  type AppNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppNotificationCountAggregateInputType | true
    }

  export interface AppNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppNotification'], meta: { name: 'AppNotification' } }
    /**
     * Find zero or one AppNotification that matches the filter.
     * @param {AppNotificationFindUniqueArgs} args - Arguments to find a AppNotification
     * @example
     * // Get one AppNotification
     * const appNotification = await prisma.appNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppNotificationFindUniqueArgs>(args: SelectSubset<T, AppNotificationFindUniqueArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppNotificationFindUniqueOrThrowArgs} args - Arguments to find a AppNotification
     * @example
     * // Get one AppNotification
     * const appNotification = await prisma.appNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, AppNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppNotificationFindFirstArgs} args - Arguments to find a AppNotification
     * @example
     * // Get one AppNotification
     * const appNotification = await prisma.appNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppNotificationFindFirstArgs>(args?: SelectSubset<T, AppNotificationFindFirstArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppNotificationFindFirstOrThrowArgs} args - Arguments to find a AppNotification
     * @example
     * // Get one AppNotification
     * const appNotification = await prisma.appNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, AppNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppNotifications
     * const appNotifications = await prisma.appNotification.findMany()
     * 
     * // Get first 10 AppNotifications
     * const appNotifications = await prisma.appNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appNotificationWithIdOnly = await prisma.appNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppNotificationFindManyArgs>(args?: SelectSubset<T, AppNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppNotification.
     * @param {AppNotificationCreateArgs} args - Arguments to create a AppNotification.
     * @example
     * // Create one AppNotification
     * const AppNotification = await prisma.appNotification.create({
     *   data: {
     *     // ... data to create a AppNotification
     *   }
     * })
     * 
     */
    create<T extends AppNotificationCreateArgs>(args: SelectSubset<T, AppNotificationCreateArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppNotifications.
     * @param {AppNotificationCreateManyArgs} args - Arguments to create many AppNotifications.
     * @example
     * // Create many AppNotifications
     * const appNotification = await prisma.appNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppNotificationCreateManyArgs>(args?: SelectSubset<T, AppNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppNotifications and returns the data saved in the database.
     * @param {AppNotificationCreateManyAndReturnArgs} args - Arguments to create many AppNotifications.
     * @example
     * // Create many AppNotifications
     * const appNotification = await prisma.appNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppNotifications and only return the `id`
     * const appNotificationWithIdOnly = await prisma.appNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, AppNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppNotification.
     * @param {AppNotificationDeleteArgs} args - Arguments to delete one AppNotification.
     * @example
     * // Delete one AppNotification
     * const AppNotification = await prisma.appNotification.delete({
     *   where: {
     *     // ... filter to delete one AppNotification
     *   }
     * })
     * 
     */
    delete<T extends AppNotificationDeleteArgs>(args: SelectSubset<T, AppNotificationDeleteArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppNotification.
     * @param {AppNotificationUpdateArgs} args - Arguments to update one AppNotification.
     * @example
     * // Update one AppNotification
     * const appNotification = await prisma.appNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppNotificationUpdateArgs>(args: SelectSubset<T, AppNotificationUpdateArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppNotifications.
     * @param {AppNotificationDeleteManyArgs} args - Arguments to filter AppNotifications to delete.
     * @example
     * // Delete a few AppNotifications
     * const { count } = await prisma.appNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppNotificationDeleteManyArgs>(args?: SelectSubset<T, AppNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppNotifications
     * const appNotification = await prisma.appNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppNotificationUpdateManyArgs>(args: SelectSubset<T, AppNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppNotifications and returns the data updated in the database.
     * @param {AppNotificationUpdateManyAndReturnArgs} args - Arguments to update many AppNotifications.
     * @example
     * // Update many AppNotifications
     * const appNotification = await prisma.appNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppNotifications and only return the `id`
     * const appNotificationWithIdOnly = await prisma.appNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, AppNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppNotification.
     * @param {AppNotificationUpsertArgs} args - Arguments to update or create a AppNotification.
     * @example
     * // Update or create a AppNotification
     * const appNotification = await prisma.appNotification.upsert({
     *   create: {
     *     // ... data to create a AppNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppNotification we want to update
     *   }
     * })
     */
    upsert<T extends AppNotificationUpsertArgs>(args: SelectSubset<T, AppNotificationUpsertArgs<ExtArgs>>): Prisma__AppNotificationClient<$Result.GetResult<Prisma.$AppNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppNotificationCountArgs} args - Arguments to filter AppNotifications to count.
     * @example
     * // Count the number of AppNotifications
     * const count = await prisma.appNotification.count({
     *   where: {
     *     // ... the filter for the AppNotifications we want to count
     *   }
     * })
    **/
    count<T extends AppNotificationCountArgs>(
      args?: Subset<T, AppNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppNotificationAggregateArgs>(args: Subset<T, AppNotificationAggregateArgs>): Prisma.PrismaPromise<GetAppNotificationAggregateType<T>>

    /**
     * Group by AppNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppNotificationGroupByArgs['orderBy'] }
        : { orderBy?: AppNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppNotification model
   */
  readonly fields: AppNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppNotification model
   */
  interface AppNotificationFieldRefs {
    readonly id: FieldRef<"AppNotification", 'String'>
    readonly userId: FieldRef<"AppNotification", 'String'>
    readonly type: FieldRef<"AppNotification", 'NotificationType'>
    readonly title: FieldRef<"AppNotification", 'String'>
    readonly body: FieldRef<"AppNotification", 'String'>
    readonly isRead: FieldRef<"AppNotification", 'Boolean'>
    readonly link: FieldRef<"AppNotification", 'String'>
    readonly createdAt: FieldRef<"AppNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppNotification findUnique
   */
  export type AppNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AppNotification to fetch.
     */
    where: AppNotificationWhereUniqueInput
  }

  /**
   * AppNotification findUniqueOrThrow
   */
  export type AppNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AppNotification to fetch.
     */
    where: AppNotificationWhereUniqueInput
  }

  /**
   * AppNotification findFirst
   */
  export type AppNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AppNotification to fetch.
     */
    where?: AppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppNotifications to fetch.
     */
    orderBy?: AppNotificationOrderByWithRelationInput | AppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppNotifications.
     */
    cursor?: AppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppNotifications.
     */
    distinct?: AppNotificationScalarFieldEnum | AppNotificationScalarFieldEnum[]
  }

  /**
   * AppNotification findFirstOrThrow
   */
  export type AppNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AppNotification to fetch.
     */
    where?: AppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppNotifications to fetch.
     */
    orderBy?: AppNotificationOrderByWithRelationInput | AppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppNotifications.
     */
    cursor?: AppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppNotifications.
     */
    distinct?: AppNotificationScalarFieldEnum | AppNotificationScalarFieldEnum[]
  }

  /**
   * AppNotification findMany
   */
  export type AppNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AppNotifications to fetch.
     */
    where?: AppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppNotifications to fetch.
     */
    orderBy?: AppNotificationOrderByWithRelationInput | AppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppNotifications.
     */
    cursor?: AppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppNotifications.
     */
    skip?: number
    distinct?: AppNotificationScalarFieldEnum | AppNotificationScalarFieldEnum[]
  }

  /**
   * AppNotification create
   */
  export type AppNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a AppNotification.
     */
    data: XOR<AppNotificationCreateInput, AppNotificationUncheckedCreateInput>
  }

  /**
   * AppNotification createMany
   */
  export type AppNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppNotifications.
     */
    data: AppNotificationCreateManyInput | AppNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppNotification createManyAndReturn
   */
  export type AppNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many AppNotifications.
     */
    data: AppNotificationCreateManyInput | AppNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppNotification update
   */
  export type AppNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a AppNotification.
     */
    data: XOR<AppNotificationUpdateInput, AppNotificationUncheckedUpdateInput>
    /**
     * Choose, which AppNotification to update.
     */
    where: AppNotificationWhereUniqueInput
  }

  /**
   * AppNotification updateMany
   */
  export type AppNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppNotifications.
     */
    data: XOR<AppNotificationUpdateManyMutationInput, AppNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AppNotifications to update
     */
    where?: AppNotificationWhereInput
    /**
     * Limit how many AppNotifications to update.
     */
    limit?: number
  }

  /**
   * AppNotification updateManyAndReturn
   */
  export type AppNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * The data used to update AppNotifications.
     */
    data: XOR<AppNotificationUpdateManyMutationInput, AppNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AppNotifications to update
     */
    where?: AppNotificationWhereInput
    /**
     * Limit how many AppNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppNotification upsert
   */
  export type AppNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the AppNotification to update in case it exists.
     */
    where: AppNotificationWhereUniqueInput
    /**
     * In case the AppNotification found by the `where` argument doesn't exist, create a new AppNotification with this data.
     */
    create: XOR<AppNotificationCreateInput, AppNotificationUncheckedCreateInput>
    /**
     * In case the AppNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppNotificationUpdateInput, AppNotificationUncheckedUpdateInput>
  }

  /**
   * AppNotification delete
   */
  export type AppNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
    /**
     * Filter which AppNotification to delete.
     */
    where: AppNotificationWhereUniqueInput
  }

  /**
   * AppNotification deleteMany
   */
  export type AppNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppNotifications to delete
     */
    where?: AppNotificationWhereInput
    /**
     * Limit how many AppNotifications to delete.
     */
    limit?: number
  }

  /**
   * AppNotification without action
   */
  export type AppNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppNotification
     */
    select?: AppNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppNotification
     */
    omit?: AppNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppNotificationInclude<ExtArgs> | null
  }


  /**
   * Model ViewProof
   */

  export type AggregateViewProof = {
    _count: ViewProofCountAggregateOutputType | null
    _min: ViewProofMinAggregateOutputType | null
    _max: ViewProofMaxAggregateOutputType | null
  }

  export type ViewProofMinAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    smartLinkId: string | null
    platform: $Enums.SocialPlatform | null
    screenshotUrl: string | null
    status: $Enums.ViewProofStatus | null
    reviewedById: string | null
    reviewedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViewProofMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    smartLinkId: string | null
    platform: $Enums.SocialPlatform | null
    screenshotUrl: string | null
    status: $Enums.ViewProofStatus | null
    reviewedById: string | null
    reviewedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViewProofCountAggregateOutputType = {
    id: number
    userId: number
    campaignId: number
    smartLinkId: number
    platform: number
    screenshotUrl: number
    status: number
    reviewedById: number
    reviewedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ViewProofMinAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    smartLinkId?: true
    platform?: true
    screenshotUrl?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViewProofMaxAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    smartLinkId?: true
    platform?: true
    screenshotUrl?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViewProofCountAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    smartLinkId?: true
    platform?: true
    screenshotUrl?: true
    status?: true
    reviewedById?: true
    reviewedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ViewProofAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewProof to aggregate.
     */
    where?: ViewProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewProofs to fetch.
     */
    orderBy?: ViewProofOrderByWithRelationInput | ViewProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewProofs
    **/
    _count?: true | ViewProofCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewProofMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewProofMaxAggregateInputType
  }

  export type GetViewProofAggregateType<T extends ViewProofAggregateArgs> = {
        [P in keyof T & keyof AggregateViewProof]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewProof[P]>
      : GetScalarType<T[P], AggregateViewProof[P]>
  }




  export type ViewProofGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewProofWhereInput
    orderBy?: ViewProofOrderByWithAggregationInput | ViewProofOrderByWithAggregationInput[]
    by: ViewProofScalarFieldEnum[] | ViewProofScalarFieldEnum
    having?: ViewProofScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewProofCountAggregateInputType | true
    _min?: ViewProofMinAggregateInputType
    _max?: ViewProofMaxAggregateInputType
  }

  export type ViewProofGroupByOutputType = {
    id: string
    userId: string
    campaignId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status: $Enums.ViewProofStatus
    reviewedById: string | null
    reviewedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ViewProofCountAggregateOutputType | null
    _min: ViewProofMinAggregateOutputType | null
    _max: ViewProofMaxAggregateOutputType | null
  }

  type GetViewProofGroupByPayload<T extends ViewProofGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewProofGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewProofGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewProofGroupByOutputType[P]>
            : GetScalarType<T[P], ViewProofGroupByOutputType[P]>
        }
      >
    >


  export type ViewProofSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    smartLinkId?: boolean
    platform?: boolean
    screenshotUrl?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ViewProof$reviewedByArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewProof"]>

  export type ViewProofSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    smartLinkId?: boolean
    platform?: boolean
    screenshotUrl?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ViewProof$reviewedByArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewProof"]>

  export type ViewProofSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    smartLinkId?: boolean
    platform?: boolean
    screenshotUrl?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ViewProof$reviewedByArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewProof"]>

  export type ViewProofSelectScalar = {
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    smartLinkId?: boolean
    platform?: boolean
    screenshotUrl?: boolean
    status?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ViewProofOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "campaignId" | "smartLinkId" | "platform" | "screenshotUrl" | "status" | "reviewedById" | "reviewedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["viewProof"]>
  export type ViewProofInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ViewProof$reviewedByArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ViewProofIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ViewProof$reviewedByArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ViewProofIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedBy?: boolean | ViewProof$reviewedByArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ViewProofPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewProof"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      reviewedBy: Prisma.$UserPayload<ExtArgs> | null
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      campaignId: string
      smartLinkId: string
      platform: $Enums.SocialPlatform
      screenshotUrl: string
      status: $Enums.ViewProofStatus
      reviewedById: string | null
      reviewedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["viewProof"]>
    composites: {}
  }

  type ViewProofGetPayload<S extends boolean | null | undefined | ViewProofDefaultArgs> = $Result.GetResult<Prisma.$ViewProofPayload, S>

  type ViewProofCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewProofFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewProofCountAggregateInputType | true
    }

  export interface ViewProofDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewProof'], meta: { name: 'ViewProof' } }
    /**
     * Find zero or one ViewProof that matches the filter.
     * @param {ViewProofFindUniqueArgs} args - Arguments to find a ViewProof
     * @example
     * // Get one ViewProof
     * const viewProof = await prisma.viewProof.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewProofFindUniqueArgs>(args: SelectSubset<T, ViewProofFindUniqueArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViewProof that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewProofFindUniqueOrThrowArgs} args - Arguments to find a ViewProof
     * @example
     * // Get one ViewProof
     * const viewProof = await prisma.viewProof.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewProofFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewProofFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewProof that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewProofFindFirstArgs} args - Arguments to find a ViewProof
     * @example
     * // Get one ViewProof
     * const viewProof = await prisma.viewProof.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewProofFindFirstArgs>(args?: SelectSubset<T, ViewProofFindFirstArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewProof that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewProofFindFirstOrThrowArgs} args - Arguments to find a ViewProof
     * @example
     * // Get one ViewProof
     * const viewProof = await prisma.viewProof.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewProofFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewProofFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViewProofs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewProofFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewProofs
     * const viewProofs = await prisma.viewProof.findMany()
     * 
     * // Get first 10 ViewProofs
     * const viewProofs = await prisma.viewProof.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewProofWithIdOnly = await prisma.viewProof.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewProofFindManyArgs>(args?: SelectSubset<T, ViewProofFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViewProof.
     * @param {ViewProofCreateArgs} args - Arguments to create a ViewProof.
     * @example
     * // Create one ViewProof
     * const ViewProof = await prisma.viewProof.create({
     *   data: {
     *     // ... data to create a ViewProof
     *   }
     * })
     * 
     */
    create<T extends ViewProofCreateArgs>(args: SelectSubset<T, ViewProofCreateArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViewProofs.
     * @param {ViewProofCreateManyArgs} args - Arguments to create many ViewProofs.
     * @example
     * // Create many ViewProofs
     * const viewProof = await prisma.viewProof.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewProofCreateManyArgs>(args?: SelectSubset<T, ViewProofCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewProofs and returns the data saved in the database.
     * @param {ViewProofCreateManyAndReturnArgs} args - Arguments to create many ViewProofs.
     * @example
     * // Create many ViewProofs
     * const viewProof = await prisma.viewProof.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewProofs and only return the `id`
     * const viewProofWithIdOnly = await prisma.viewProof.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewProofCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewProofCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViewProof.
     * @param {ViewProofDeleteArgs} args - Arguments to delete one ViewProof.
     * @example
     * // Delete one ViewProof
     * const ViewProof = await prisma.viewProof.delete({
     *   where: {
     *     // ... filter to delete one ViewProof
     *   }
     * })
     * 
     */
    delete<T extends ViewProofDeleteArgs>(args: SelectSubset<T, ViewProofDeleteArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViewProof.
     * @param {ViewProofUpdateArgs} args - Arguments to update one ViewProof.
     * @example
     * // Update one ViewProof
     * const viewProof = await prisma.viewProof.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewProofUpdateArgs>(args: SelectSubset<T, ViewProofUpdateArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViewProofs.
     * @param {ViewProofDeleteManyArgs} args - Arguments to filter ViewProofs to delete.
     * @example
     * // Delete a few ViewProofs
     * const { count } = await prisma.viewProof.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewProofDeleteManyArgs>(args?: SelectSubset<T, ViewProofDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewProofUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewProofs
     * const viewProof = await prisma.viewProof.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewProofUpdateManyArgs>(args: SelectSubset<T, ViewProofUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewProofs and returns the data updated in the database.
     * @param {ViewProofUpdateManyAndReturnArgs} args - Arguments to update many ViewProofs.
     * @example
     * // Update many ViewProofs
     * const viewProof = await prisma.viewProof.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViewProofs and only return the `id`
     * const viewProofWithIdOnly = await prisma.viewProof.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewProofUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewProofUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViewProof.
     * @param {ViewProofUpsertArgs} args - Arguments to update or create a ViewProof.
     * @example
     * // Update or create a ViewProof
     * const viewProof = await prisma.viewProof.upsert({
     *   create: {
     *     // ... data to create a ViewProof
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewProof we want to update
     *   }
     * })
     */
    upsert<T extends ViewProofUpsertArgs>(args: SelectSubset<T, ViewProofUpsertArgs<ExtArgs>>): Prisma__ViewProofClient<$Result.GetResult<Prisma.$ViewProofPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViewProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewProofCountArgs} args - Arguments to filter ViewProofs to count.
     * @example
     * // Count the number of ViewProofs
     * const count = await prisma.viewProof.count({
     *   where: {
     *     // ... the filter for the ViewProofs we want to count
     *   }
     * })
    **/
    count<T extends ViewProofCountArgs>(
      args?: Subset<T, ViewProofCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewProofCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewProofAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewProofAggregateArgs>(args: Subset<T, ViewProofAggregateArgs>): Prisma.PrismaPromise<GetViewProofAggregateType<T>>

    /**
     * Group by ViewProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewProofGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewProofGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewProofGroupByArgs['orderBy'] }
        : { orderBy?: ViewProofGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewProofGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewProofGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewProof model
   */
  readonly fields: ViewProofFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewProof.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewProofClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewedBy<T extends ViewProof$reviewedByArgs<ExtArgs> = {}>(args?: Subset<T, ViewProof$reviewedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewProof model
   */
  interface ViewProofFieldRefs {
    readonly id: FieldRef<"ViewProof", 'String'>
    readonly userId: FieldRef<"ViewProof", 'String'>
    readonly campaignId: FieldRef<"ViewProof", 'String'>
    readonly smartLinkId: FieldRef<"ViewProof", 'String'>
    readonly platform: FieldRef<"ViewProof", 'SocialPlatform'>
    readonly screenshotUrl: FieldRef<"ViewProof", 'String'>
    readonly status: FieldRef<"ViewProof", 'ViewProofStatus'>
    readonly reviewedById: FieldRef<"ViewProof", 'String'>
    readonly reviewedAt: FieldRef<"ViewProof", 'DateTime'>
    readonly notes: FieldRef<"ViewProof", 'String'>
    readonly createdAt: FieldRef<"ViewProof", 'DateTime'>
    readonly updatedAt: FieldRef<"ViewProof", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViewProof findUnique
   */
  export type ViewProofFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * Filter, which ViewProof to fetch.
     */
    where: ViewProofWhereUniqueInput
  }

  /**
   * ViewProof findUniqueOrThrow
   */
  export type ViewProofFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * Filter, which ViewProof to fetch.
     */
    where: ViewProofWhereUniqueInput
  }

  /**
   * ViewProof findFirst
   */
  export type ViewProofFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * Filter, which ViewProof to fetch.
     */
    where?: ViewProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewProofs to fetch.
     */
    orderBy?: ViewProofOrderByWithRelationInput | ViewProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewProofs.
     */
    cursor?: ViewProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewProofs.
     */
    distinct?: ViewProofScalarFieldEnum | ViewProofScalarFieldEnum[]
  }

  /**
   * ViewProof findFirstOrThrow
   */
  export type ViewProofFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * Filter, which ViewProof to fetch.
     */
    where?: ViewProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewProofs to fetch.
     */
    orderBy?: ViewProofOrderByWithRelationInput | ViewProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewProofs.
     */
    cursor?: ViewProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewProofs.
     */
    distinct?: ViewProofScalarFieldEnum | ViewProofScalarFieldEnum[]
  }

  /**
   * ViewProof findMany
   */
  export type ViewProofFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * Filter, which ViewProofs to fetch.
     */
    where?: ViewProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewProofs to fetch.
     */
    orderBy?: ViewProofOrderByWithRelationInput | ViewProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewProofs.
     */
    cursor?: ViewProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewProofs.
     */
    skip?: number
    distinct?: ViewProofScalarFieldEnum | ViewProofScalarFieldEnum[]
  }

  /**
   * ViewProof create
   */
  export type ViewProofCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * The data needed to create a ViewProof.
     */
    data: XOR<ViewProofCreateInput, ViewProofUncheckedCreateInput>
  }

  /**
   * ViewProof createMany
   */
  export type ViewProofCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewProofs.
     */
    data: ViewProofCreateManyInput | ViewProofCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewProof createManyAndReturn
   */
  export type ViewProofCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * The data used to create many ViewProofs.
     */
    data: ViewProofCreateManyInput | ViewProofCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewProof update
   */
  export type ViewProofUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * The data needed to update a ViewProof.
     */
    data: XOR<ViewProofUpdateInput, ViewProofUncheckedUpdateInput>
    /**
     * Choose, which ViewProof to update.
     */
    where: ViewProofWhereUniqueInput
  }

  /**
   * ViewProof updateMany
   */
  export type ViewProofUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewProofs.
     */
    data: XOR<ViewProofUpdateManyMutationInput, ViewProofUncheckedUpdateManyInput>
    /**
     * Filter which ViewProofs to update
     */
    where?: ViewProofWhereInput
    /**
     * Limit how many ViewProofs to update.
     */
    limit?: number
  }

  /**
   * ViewProof updateManyAndReturn
   */
  export type ViewProofUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * The data used to update ViewProofs.
     */
    data: XOR<ViewProofUpdateManyMutationInput, ViewProofUncheckedUpdateManyInput>
    /**
     * Filter which ViewProofs to update
     */
    where?: ViewProofWhereInput
    /**
     * Limit how many ViewProofs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewProof upsert
   */
  export type ViewProofUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * The filter to search for the ViewProof to update in case it exists.
     */
    where: ViewProofWhereUniqueInput
    /**
     * In case the ViewProof found by the `where` argument doesn't exist, create a new ViewProof with this data.
     */
    create: XOR<ViewProofCreateInput, ViewProofUncheckedCreateInput>
    /**
     * In case the ViewProof was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewProofUpdateInput, ViewProofUncheckedUpdateInput>
  }

  /**
   * ViewProof delete
   */
  export type ViewProofDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
    /**
     * Filter which ViewProof to delete.
     */
    where: ViewProofWhereUniqueInput
  }

  /**
   * ViewProof deleteMany
   */
  export type ViewProofDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewProofs to delete
     */
    where?: ViewProofWhereInput
    /**
     * Limit how many ViewProofs to delete.
     */
    limit?: number
  }

  /**
   * ViewProof.reviewedBy
   */
  export type ViewProof$reviewedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ViewProof without action
   */
  export type ViewProofDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewProof
     */
    select?: ViewProofSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewProof
     */
    omit?: ViewProofOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewProofInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    maxTeams: number | null
  }

  export type GroupSumAggregateOutputType = {
    maxTeams: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    maxTeams: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    maxTeams: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    maxTeams: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    maxTeams?: true
  }

  export type GroupSumAggregateInputType = {
    maxTeams?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxTeams?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxTeams?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxTeams?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    maxTeams: number
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    maxTeams?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teams?: boolean | Group$teamsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    maxTeams?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    maxTeams?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    maxTeams?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "maxTeams" | "createdAt" | "updatedAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | Group$teamsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      teams: Prisma.$TeamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      maxTeams: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teams<T extends Group$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Group$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly maxTeams: FieldRef<"Group", 'Int'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.teams
   */
  export type Group$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    maxMembers: number | null
  }

  export type TeamSumAggregateOutputType = {
    maxMembers: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    groupId: string | null
    teamLeadId: string | null
    maxMembers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    groupId: string | null
    teamLeadId: string | null
    maxMembers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    groupId: number
    teamLeadId: number
    maxMembers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    maxMembers?: true
  }

  export type TeamSumAggregateInputType = {
    maxMembers?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    groupId?: true
    teamLeadId?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    groupId?: true
    teamLeadId?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    groupId?: true
    teamLeadId?: true
    maxMembers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    groupId: string
    teamLeadId: string | null
    maxMembers: number
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    groupId?: boolean
    teamLeadId?: boolean
    maxMembers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    teamInviteLinks?: boolean | Team$teamInviteLinksArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    groupId?: boolean
    teamLeadId?: boolean
    maxMembers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    groupId?: boolean
    teamLeadId?: boolean
    maxMembers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    groupId?: boolean
    teamLeadId?: boolean
    maxMembers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "groupId" | "teamLeadId" | "maxMembers" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    teamInviteLinks?: boolean | Team$teamInviteLinksArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      members: Prisma.$UserPayload<ExtArgs>[]
      teamInviteLinks: Prisma.$TeamInviteLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      groupId: string
      teamLeadId: string | null
      maxMembers: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamInviteLinks<T extends Team$teamInviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamInviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly groupId: FieldRef<"Team", 'String'>
    readonly teamLeadId: FieldRef<"Team", 'String'>
    readonly maxMembers: FieldRef<"Team", 'Int'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Team.teamInviteLinks
   */
  export type Team$teamInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    where?: TeamInviteLinkWhereInput
    orderBy?: TeamInviteLinkOrderByWithRelationInput | TeamInviteLinkOrderByWithRelationInput[]
    cursor?: TeamInviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamInviteLinkScalarFieldEnum | TeamInviteLinkScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamInviteLink
   */

  export type AggregateTeamInviteLink = {
    _count: TeamInviteLinkCountAggregateOutputType | null
    _avg: TeamInviteLinkAvgAggregateOutputType | null
    _sum: TeamInviteLinkSumAggregateOutputType | null
    _min: TeamInviteLinkMinAggregateOutputType | null
    _max: TeamInviteLinkMaxAggregateOutputType | null
  }

  export type TeamInviteLinkAvgAggregateOutputType = {
    usedCount: number | null
    maxUses: number | null
  }

  export type TeamInviteLinkSumAggregateOutputType = {
    usedCount: number | null
    maxUses: number | null
  }

  export type TeamInviteLinkMinAggregateOutputType = {
    id: string | null
    token: string | null
    teamId: string | null
    targetRole: string | null
    createdById: string | null
    usedCount: number | null
    maxUses: number | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type TeamInviteLinkMaxAggregateOutputType = {
    id: string | null
    token: string | null
    teamId: string | null
    targetRole: string | null
    createdById: string | null
    usedCount: number | null
    maxUses: number | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type TeamInviteLinkCountAggregateOutputType = {
    id: number
    token: number
    teamId: number
    targetRole: number
    createdById: number
    usedCount: number
    maxUses: number
    expiresAt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type TeamInviteLinkAvgAggregateInputType = {
    usedCount?: true
    maxUses?: true
  }

  export type TeamInviteLinkSumAggregateInputType = {
    usedCount?: true
    maxUses?: true
  }

  export type TeamInviteLinkMinAggregateInputType = {
    id?: true
    token?: true
    teamId?: true
    targetRole?: true
    createdById?: true
    usedCount?: true
    maxUses?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type TeamInviteLinkMaxAggregateInputType = {
    id?: true
    token?: true
    teamId?: true
    targetRole?: true
    createdById?: true
    usedCount?: true
    maxUses?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type TeamInviteLinkCountAggregateInputType = {
    id?: true
    token?: true
    teamId?: true
    targetRole?: true
    createdById?: true
    usedCount?: true
    maxUses?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type TeamInviteLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamInviteLink to aggregate.
     */
    where?: TeamInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInviteLinks to fetch.
     */
    orderBy?: TeamInviteLinkOrderByWithRelationInput | TeamInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamInviteLinks
    **/
    _count?: true | TeamInviteLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamInviteLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamInviteLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamInviteLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamInviteLinkMaxAggregateInputType
  }

  export type GetTeamInviteLinkAggregateType<T extends TeamInviteLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamInviteLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamInviteLink[P]>
      : GetScalarType<T[P], AggregateTeamInviteLink[P]>
  }




  export type TeamInviteLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInviteLinkWhereInput
    orderBy?: TeamInviteLinkOrderByWithAggregationInput | TeamInviteLinkOrderByWithAggregationInput[]
    by: TeamInviteLinkScalarFieldEnum[] | TeamInviteLinkScalarFieldEnum
    having?: TeamInviteLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamInviteLinkCountAggregateInputType | true
    _avg?: TeamInviteLinkAvgAggregateInputType
    _sum?: TeamInviteLinkSumAggregateInputType
    _min?: TeamInviteLinkMinAggregateInputType
    _max?: TeamInviteLinkMaxAggregateInputType
  }

  export type TeamInviteLinkGroupByOutputType = {
    id: string
    token: string
    teamId: string
    targetRole: string
    createdById: string
    usedCount: number
    maxUses: number
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    _count: TeamInviteLinkCountAggregateOutputType | null
    _avg: TeamInviteLinkAvgAggregateOutputType | null
    _sum: TeamInviteLinkSumAggregateOutputType | null
    _min: TeamInviteLinkMinAggregateOutputType | null
    _max: TeamInviteLinkMaxAggregateOutputType | null
  }

  type GetTeamInviteLinkGroupByPayload<T extends TeamInviteLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamInviteLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamInviteLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamInviteLinkGroupByOutputType[P]>
            : GetScalarType<T[P], TeamInviteLinkGroupByOutputType[P]>
        }
      >
    >


  export type TeamInviteLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    teamId?: boolean
    targetRole?: boolean
    createdById?: boolean
    usedCount?: boolean
    maxUses?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamInviteLink"]>

  export type TeamInviteLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    teamId?: boolean
    targetRole?: boolean
    createdById?: boolean
    usedCount?: boolean
    maxUses?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamInviteLink"]>

  export type TeamInviteLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    teamId?: boolean
    targetRole?: boolean
    createdById?: boolean
    usedCount?: boolean
    maxUses?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamInviteLink"]>

  export type TeamInviteLinkSelectScalar = {
    id?: boolean
    token?: boolean
    teamId?: boolean
    targetRole?: boolean
    createdById?: boolean
    usedCount?: boolean
    maxUses?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type TeamInviteLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "teamId" | "targetRole" | "createdById" | "usedCount" | "maxUses" | "expiresAt" | "isActive" | "createdAt", ExtArgs["result"]["teamInviteLink"]>
  export type TeamInviteLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamInviteLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamInviteLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamInviteLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamInviteLink"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      teamId: string
      targetRole: string
      createdById: string
      usedCount: number
      maxUses: number
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["teamInviteLink"]>
    composites: {}
  }

  type TeamInviteLinkGetPayload<S extends boolean | null | undefined | TeamInviteLinkDefaultArgs> = $Result.GetResult<Prisma.$TeamInviteLinkPayload, S>

  type TeamInviteLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamInviteLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamInviteLinkCountAggregateInputType | true
    }

  export interface TeamInviteLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamInviteLink'], meta: { name: 'TeamInviteLink' } }
    /**
     * Find zero or one TeamInviteLink that matches the filter.
     * @param {TeamInviteLinkFindUniqueArgs} args - Arguments to find a TeamInviteLink
     * @example
     * // Get one TeamInviteLink
     * const teamInviteLink = await prisma.teamInviteLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamInviteLinkFindUniqueArgs>(args: SelectSubset<T, TeamInviteLinkFindUniqueArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamInviteLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamInviteLinkFindUniqueOrThrowArgs} args - Arguments to find a TeamInviteLink
     * @example
     * // Get one TeamInviteLink
     * const teamInviteLink = await prisma.teamInviteLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamInviteLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamInviteLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamInviteLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteLinkFindFirstArgs} args - Arguments to find a TeamInviteLink
     * @example
     * // Get one TeamInviteLink
     * const teamInviteLink = await prisma.teamInviteLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamInviteLinkFindFirstArgs>(args?: SelectSubset<T, TeamInviteLinkFindFirstArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamInviteLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteLinkFindFirstOrThrowArgs} args - Arguments to find a TeamInviteLink
     * @example
     * // Get one TeamInviteLink
     * const teamInviteLink = await prisma.teamInviteLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamInviteLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamInviteLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamInviteLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamInviteLinks
     * const teamInviteLinks = await prisma.teamInviteLink.findMany()
     * 
     * // Get first 10 TeamInviteLinks
     * const teamInviteLinks = await prisma.teamInviteLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamInviteLinkWithIdOnly = await prisma.teamInviteLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamInviteLinkFindManyArgs>(args?: SelectSubset<T, TeamInviteLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamInviteLink.
     * @param {TeamInviteLinkCreateArgs} args - Arguments to create a TeamInviteLink.
     * @example
     * // Create one TeamInviteLink
     * const TeamInviteLink = await prisma.teamInviteLink.create({
     *   data: {
     *     // ... data to create a TeamInviteLink
     *   }
     * })
     * 
     */
    create<T extends TeamInviteLinkCreateArgs>(args: SelectSubset<T, TeamInviteLinkCreateArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamInviteLinks.
     * @param {TeamInviteLinkCreateManyArgs} args - Arguments to create many TeamInviteLinks.
     * @example
     * // Create many TeamInviteLinks
     * const teamInviteLink = await prisma.teamInviteLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamInviteLinkCreateManyArgs>(args?: SelectSubset<T, TeamInviteLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamInviteLinks and returns the data saved in the database.
     * @param {TeamInviteLinkCreateManyAndReturnArgs} args - Arguments to create many TeamInviteLinks.
     * @example
     * // Create many TeamInviteLinks
     * const teamInviteLink = await prisma.teamInviteLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamInviteLinks and only return the `id`
     * const teamInviteLinkWithIdOnly = await prisma.teamInviteLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamInviteLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamInviteLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamInviteLink.
     * @param {TeamInviteLinkDeleteArgs} args - Arguments to delete one TeamInviteLink.
     * @example
     * // Delete one TeamInviteLink
     * const TeamInviteLink = await prisma.teamInviteLink.delete({
     *   where: {
     *     // ... filter to delete one TeamInviteLink
     *   }
     * })
     * 
     */
    delete<T extends TeamInviteLinkDeleteArgs>(args: SelectSubset<T, TeamInviteLinkDeleteArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamInviteLink.
     * @param {TeamInviteLinkUpdateArgs} args - Arguments to update one TeamInviteLink.
     * @example
     * // Update one TeamInviteLink
     * const teamInviteLink = await prisma.teamInviteLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamInviteLinkUpdateArgs>(args: SelectSubset<T, TeamInviteLinkUpdateArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamInviteLinks.
     * @param {TeamInviteLinkDeleteManyArgs} args - Arguments to filter TeamInviteLinks to delete.
     * @example
     * // Delete a few TeamInviteLinks
     * const { count } = await prisma.teamInviteLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamInviteLinkDeleteManyArgs>(args?: SelectSubset<T, TeamInviteLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamInviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamInviteLinks
     * const teamInviteLink = await prisma.teamInviteLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamInviteLinkUpdateManyArgs>(args: SelectSubset<T, TeamInviteLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamInviteLinks and returns the data updated in the database.
     * @param {TeamInviteLinkUpdateManyAndReturnArgs} args - Arguments to update many TeamInviteLinks.
     * @example
     * // Update many TeamInviteLinks
     * const teamInviteLink = await prisma.teamInviteLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamInviteLinks and only return the `id`
     * const teamInviteLinkWithIdOnly = await prisma.teamInviteLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamInviteLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamInviteLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamInviteLink.
     * @param {TeamInviteLinkUpsertArgs} args - Arguments to update or create a TeamInviteLink.
     * @example
     * // Update or create a TeamInviteLink
     * const teamInviteLink = await prisma.teamInviteLink.upsert({
     *   create: {
     *     // ... data to create a TeamInviteLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamInviteLink we want to update
     *   }
     * })
     */
    upsert<T extends TeamInviteLinkUpsertArgs>(args: SelectSubset<T, TeamInviteLinkUpsertArgs<ExtArgs>>): Prisma__TeamInviteLinkClient<$Result.GetResult<Prisma.$TeamInviteLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamInviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteLinkCountArgs} args - Arguments to filter TeamInviteLinks to count.
     * @example
     * // Count the number of TeamInviteLinks
     * const count = await prisma.teamInviteLink.count({
     *   where: {
     *     // ... the filter for the TeamInviteLinks we want to count
     *   }
     * })
    **/
    count<T extends TeamInviteLinkCountArgs>(
      args?: Subset<T, TeamInviteLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamInviteLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamInviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamInviteLinkAggregateArgs>(args: Subset<T, TeamInviteLinkAggregateArgs>): Prisma.PrismaPromise<GetTeamInviteLinkAggregateType<T>>

    /**
     * Group by TeamInviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamInviteLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamInviteLinkGroupByArgs['orderBy'] }
        : { orderBy?: TeamInviteLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamInviteLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamInviteLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamInviteLink model
   */
  readonly fields: TeamInviteLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamInviteLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamInviteLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamInviteLink model
   */
  interface TeamInviteLinkFieldRefs {
    readonly id: FieldRef<"TeamInviteLink", 'String'>
    readonly token: FieldRef<"TeamInviteLink", 'String'>
    readonly teamId: FieldRef<"TeamInviteLink", 'String'>
    readonly targetRole: FieldRef<"TeamInviteLink", 'String'>
    readonly createdById: FieldRef<"TeamInviteLink", 'String'>
    readonly usedCount: FieldRef<"TeamInviteLink", 'Int'>
    readonly maxUses: FieldRef<"TeamInviteLink", 'Int'>
    readonly expiresAt: FieldRef<"TeamInviteLink", 'DateTime'>
    readonly isActive: FieldRef<"TeamInviteLink", 'Boolean'>
    readonly createdAt: FieldRef<"TeamInviteLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamInviteLink findUnique
   */
  export type TeamInviteLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamInviteLink to fetch.
     */
    where: TeamInviteLinkWhereUniqueInput
  }

  /**
   * TeamInviteLink findUniqueOrThrow
   */
  export type TeamInviteLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamInviteLink to fetch.
     */
    where: TeamInviteLinkWhereUniqueInput
  }

  /**
   * TeamInviteLink findFirst
   */
  export type TeamInviteLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamInviteLink to fetch.
     */
    where?: TeamInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInviteLinks to fetch.
     */
    orderBy?: TeamInviteLinkOrderByWithRelationInput | TeamInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamInviteLinks.
     */
    cursor?: TeamInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamInviteLinks.
     */
    distinct?: TeamInviteLinkScalarFieldEnum | TeamInviteLinkScalarFieldEnum[]
  }

  /**
   * TeamInviteLink findFirstOrThrow
   */
  export type TeamInviteLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamInviteLink to fetch.
     */
    where?: TeamInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInviteLinks to fetch.
     */
    orderBy?: TeamInviteLinkOrderByWithRelationInput | TeamInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamInviteLinks.
     */
    cursor?: TeamInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamInviteLinks.
     */
    distinct?: TeamInviteLinkScalarFieldEnum | TeamInviteLinkScalarFieldEnum[]
  }

  /**
   * TeamInviteLink findMany
   */
  export type TeamInviteLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which TeamInviteLinks to fetch.
     */
    where?: TeamInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInviteLinks to fetch.
     */
    orderBy?: TeamInviteLinkOrderByWithRelationInput | TeamInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamInviteLinks.
     */
    cursor?: TeamInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInviteLinks.
     */
    skip?: number
    distinct?: TeamInviteLinkScalarFieldEnum | TeamInviteLinkScalarFieldEnum[]
  }

  /**
   * TeamInviteLink create
   */
  export type TeamInviteLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamInviteLink.
     */
    data: XOR<TeamInviteLinkCreateInput, TeamInviteLinkUncheckedCreateInput>
  }

  /**
   * TeamInviteLink createMany
   */
  export type TeamInviteLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamInviteLinks.
     */
    data: TeamInviteLinkCreateManyInput | TeamInviteLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamInviteLink createManyAndReturn
   */
  export type TeamInviteLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * The data used to create many TeamInviteLinks.
     */
    data: TeamInviteLinkCreateManyInput | TeamInviteLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamInviteLink update
   */
  export type TeamInviteLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamInviteLink.
     */
    data: XOR<TeamInviteLinkUpdateInput, TeamInviteLinkUncheckedUpdateInput>
    /**
     * Choose, which TeamInviteLink to update.
     */
    where: TeamInviteLinkWhereUniqueInput
  }

  /**
   * TeamInviteLink updateMany
   */
  export type TeamInviteLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamInviteLinks.
     */
    data: XOR<TeamInviteLinkUpdateManyMutationInput, TeamInviteLinkUncheckedUpdateManyInput>
    /**
     * Filter which TeamInviteLinks to update
     */
    where?: TeamInviteLinkWhereInput
    /**
     * Limit how many TeamInviteLinks to update.
     */
    limit?: number
  }

  /**
   * TeamInviteLink updateManyAndReturn
   */
  export type TeamInviteLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * The data used to update TeamInviteLinks.
     */
    data: XOR<TeamInviteLinkUpdateManyMutationInput, TeamInviteLinkUncheckedUpdateManyInput>
    /**
     * Filter which TeamInviteLinks to update
     */
    where?: TeamInviteLinkWhereInput
    /**
     * Limit how many TeamInviteLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamInviteLink upsert
   */
  export type TeamInviteLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamInviteLink to update in case it exists.
     */
    where: TeamInviteLinkWhereUniqueInput
    /**
     * In case the TeamInviteLink found by the `where` argument doesn't exist, create a new TeamInviteLink with this data.
     */
    create: XOR<TeamInviteLinkCreateInput, TeamInviteLinkUncheckedCreateInput>
    /**
     * In case the TeamInviteLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamInviteLinkUpdateInput, TeamInviteLinkUncheckedUpdateInput>
  }

  /**
   * TeamInviteLink delete
   */
  export type TeamInviteLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
    /**
     * Filter which TeamInviteLink to delete.
     */
    where: TeamInviteLinkWhereUniqueInput
  }

  /**
   * TeamInviteLink deleteMany
   */
  export type TeamInviteLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamInviteLinks to delete
     */
    where?: TeamInviteLinkWhereInput
    /**
     * Limit how many TeamInviteLinks to delete.
     */
    limit?: number
  }

  /**
   * TeamInviteLink without action
   */
  export type TeamInviteLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInviteLink
     */
    select?: TeamInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInviteLink
     */
    omit?: TeamInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteLinkInclude<ExtArgs> | null
  }


  /**
   * Model CampaignAuditEvent
   */

  export type AggregateCampaignAuditEvent = {
    _count: CampaignAuditEventCountAggregateOutputType | null
    _min: CampaignAuditEventMinAggregateOutputType | null
    _max: CampaignAuditEventMaxAggregateOutputType | null
  }

  export type CampaignAuditEventMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    actorId: string | null
    actorRole: string | null
    eventType: $Enums.CampaignAuditEventType | null
    note: string | null
    createdAt: Date | null
  }

  export type CampaignAuditEventMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    actorId: string | null
    actorRole: string | null
    eventType: $Enums.CampaignAuditEventType | null
    note: string | null
    createdAt: Date | null
  }

  export type CampaignAuditEventCountAggregateOutputType = {
    id: number
    campaignId: number
    actorId: number
    actorRole: number
    eventType: number
    before: number
    after: number
    note: number
    createdAt: number
    _all: number
  }


  export type CampaignAuditEventMinAggregateInputType = {
    id?: true
    campaignId?: true
    actorId?: true
    actorRole?: true
    eventType?: true
    note?: true
    createdAt?: true
  }

  export type CampaignAuditEventMaxAggregateInputType = {
    id?: true
    campaignId?: true
    actorId?: true
    actorRole?: true
    eventType?: true
    note?: true
    createdAt?: true
  }

  export type CampaignAuditEventCountAggregateInputType = {
    id?: true
    campaignId?: true
    actorId?: true
    actorRole?: true
    eventType?: true
    before?: true
    after?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignAuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAuditEvent to aggregate.
     */
    where?: CampaignAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAuditEvents to fetch.
     */
    orderBy?: CampaignAuditEventOrderByWithRelationInput | CampaignAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignAuditEvents
    **/
    _count?: true | CampaignAuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignAuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignAuditEventMaxAggregateInputType
  }

  export type GetCampaignAuditEventAggregateType<T extends CampaignAuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignAuditEvent[P]>
      : GetScalarType<T[P], AggregateCampaignAuditEvent[P]>
  }




  export type CampaignAuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAuditEventWhereInput
    orderBy?: CampaignAuditEventOrderByWithAggregationInput | CampaignAuditEventOrderByWithAggregationInput[]
    by: CampaignAuditEventScalarFieldEnum[] | CampaignAuditEventScalarFieldEnum
    having?: CampaignAuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignAuditEventCountAggregateInputType | true
    _min?: CampaignAuditEventMinAggregateInputType
    _max?: CampaignAuditEventMaxAggregateInputType
  }

  export type CampaignAuditEventGroupByOutputType = {
    id: string
    campaignId: string
    actorId: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before: JsonValue | null
    after: JsonValue | null
    note: string | null
    createdAt: Date
    _count: CampaignAuditEventCountAggregateOutputType | null
    _min: CampaignAuditEventMinAggregateOutputType | null
    _max: CampaignAuditEventMaxAggregateOutputType | null
  }

  type GetCampaignAuditEventGroupByPayload<T extends CampaignAuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignAuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignAuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignAuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignAuditEventGroupByOutputType[P]>
        }
      >
    >


  export type CampaignAuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    actorId?: boolean
    actorRole?: boolean
    eventType?: boolean
    before?: boolean
    after?: boolean
    note?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAuditEvent"]>

  export type CampaignAuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    actorId?: boolean
    actorRole?: boolean
    eventType?: boolean
    before?: boolean
    after?: boolean
    note?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAuditEvent"]>

  export type CampaignAuditEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    actorId?: boolean
    actorRole?: boolean
    eventType?: boolean
    before?: boolean
    after?: boolean
    note?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAuditEvent"]>

  export type CampaignAuditEventSelectScalar = {
    id?: boolean
    campaignId?: boolean
    actorId?: boolean
    actorRole?: boolean
    eventType?: boolean
    before?: boolean
    after?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type CampaignAuditEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "actorId" | "actorRole" | "eventType" | "before" | "after" | "note" | "createdAt", ExtArgs["result"]["campaignAuditEvent"]>
  export type CampaignAuditEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignAuditEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignAuditEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignAuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignAuditEvent"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      actor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      actorId: string
      actorRole: string
      eventType: $Enums.CampaignAuditEventType
      before: Prisma.JsonValue | null
      after: Prisma.JsonValue | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["campaignAuditEvent"]>
    composites: {}
  }

  type CampaignAuditEventGetPayload<S extends boolean | null | undefined | CampaignAuditEventDefaultArgs> = $Result.GetResult<Prisma.$CampaignAuditEventPayload, S>

  type CampaignAuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignAuditEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignAuditEventCountAggregateInputType | true
    }

  export interface CampaignAuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignAuditEvent'], meta: { name: 'CampaignAuditEvent' } }
    /**
     * Find zero or one CampaignAuditEvent that matches the filter.
     * @param {CampaignAuditEventFindUniqueArgs} args - Arguments to find a CampaignAuditEvent
     * @example
     * // Get one CampaignAuditEvent
     * const campaignAuditEvent = await prisma.campaignAuditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignAuditEventFindUniqueArgs>(args: SelectSubset<T, CampaignAuditEventFindUniqueArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignAuditEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignAuditEventFindUniqueOrThrowArgs} args - Arguments to find a CampaignAuditEvent
     * @example
     * // Get one CampaignAuditEvent
     * const campaignAuditEvent = await prisma.campaignAuditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignAuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignAuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignAuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAuditEventFindFirstArgs} args - Arguments to find a CampaignAuditEvent
     * @example
     * // Get one CampaignAuditEvent
     * const campaignAuditEvent = await prisma.campaignAuditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignAuditEventFindFirstArgs>(args?: SelectSubset<T, CampaignAuditEventFindFirstArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignAuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAuditEventFindFirstOrThrowArgs} args - Arguments to find a CampaignAuditEvent
     * @example
     * // Get one CampaignAuditEvent
     * const campaignAuditEvent = await prisma.campaignAuditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignAuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignAuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignAuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignAuditEvents
     * const campaignAuditEvents = await prisma.campaignAuditEvent.findMany()
     * 
     * // Get first 10 CampaignAuditEvents
     * const campaignAuditEvents = await prisma.campaignAuditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignAuditEventWithIdOnly = await prisma.campaignAuditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignAuditEventFindManyArgs>(args?: SelectSubset<T, CampaignAuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignAuditEvent.
     * @param {CampaignAuditEventCreateArgs} args - Arguments to create a CampaignAuditEvent.
     * @example
     * // Create one CampaignAuditEvent
     * const CampaignAuditEvent = await prisma.campaignAuditEvent.create({
     *   data: {
     *     // ... data to create a CampaignAuditEvent
     *   }
     * })
     * 
     */
    create<T extends CampaignAuditEventCreateArgs>(args: SelectSubset<T, CampaignAuditEventCreateArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignAuditEvents.
     * @param {CampaignAuditEventCreateManyArgs} args - Arguments to create many CampaignAuditEvents.
     * @example
     * // Create many CampaignAuditEvents
     * const campaignAuditEvent = await prisma.campaignAuditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignAuditEventCreateManyArgs>(args?: SelectSubset<T, CampaignAuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignAuditEvents and returns the data saved in the database.
     * @param {CampaignAuditEventCreateManyAndReturnArgs} args - Arguments to create many CampaignAuditEvents.
     * @example
     * // Create many CampaignAuditEvents
     * const campaignAuditEvent = await prisma.campaignAuditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignAuditEvents and only return the `id`
     * const campaignAuditEventWithIdOnly = await prisma.campaignAuditEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignAuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignAuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignAuditEvent.
     * @param {CampaignAuditEventDeleteArgs} args - Arguments to delete one CampaignAuditEvent.
     * @example
     * // Delete one CampaignAuditEvent
     * const CampaignAuditEvent = await prisma.campaignAuditEvent.delete({
     *   where: {
     *     // ... filter to delete one CampaignAuditEvent
     *   }
     * })
     * 
     */
    delete<T extends CampaignAuditEventDeleteArgs>(args: SelectSubset<T, CampaignAuditEventDeleteArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignAuditEvent.
     * @param {CampaignAuditEventUpdateArgs} args - Arguments to update one CampaignAuditEvent.
     * @example
     * // Update one CampaignAuditEvent
     * const campaignAuditEvent = await prisma.campaignAuditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignAuditEventUpdateArgs>(args: SelectSubset<T, CampaignAuditEventUpdateArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignAuditEvents.
     * @param {CampaignAuditEventDeleteManyArgs} args - Arguments to filter CampaignAuditEvents to delete.
     * @example
     * // Delete a few CampaignAuditEvents
     * const { count } = await prisma.campaignAuditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignAuditEventDeleteManyArgs>(args?: SelectSubset<T, CampaignAuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignAuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignAuditEvents
     * const campaignAuditEvent = await prisma.campaignAuditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignAuditEventUpdateManyArgs>(args: SelectSubset<T, CampaignAuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignAuditEvents and returns the data updated in the database.
     * @param {CampaignAuditEventUpdateManyAndReturnArgs} args - Arguments to update many CampaignAuditEvents.
     * @example
     * // Update many CampaignAuditEvents
     * const campaignAuditEvent = await prisma.campaignAuditEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignAuditEvents and only return the `id`
     * const campaignAuditEventWithIdOnly = await prisma.campaignAuditEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignAuditEventUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignAuditEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignAuditEvent.
     * @param {CampaignAuditEventUpsertArgs} args - Arguments to update or create a CampaignAuditEvent.
     * @example
     * // Update or create a CampaignAuditEvent
     * const campaignAuditEvent = await prisma.campaignAuditEvent.upsert({
     *   create: {
     *     // ... data to create a CampaignAuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignAuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends CampaignAuditEventUpsertArgs>(args: SelectSubset<T, CampaignAuditEventUpsertArgs<ExtArgs>>): Prisma__CampaignAuditEventClient<$Result.GetResult<Prisma.$CampaignAuditEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignAuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAuditEventCountArgs} args - Arguments to filter CampaignAuditEvents to count.
     * @example
     * // Count the number of CampaignAuditEvents
     * const count = await prisma.campaignAuditEvent.count({
     *   where: {
     *     // ... the filter for the CampaignAuditEvents we want to count
     *   }
     * })
    **/
    count<T extends CampaignAuditEventCountArgs>(
      args?: Subset<T, CampaignAuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignAuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignAuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAuditEventAggregateArgs>(args: Subset<T, CampaignAuditEventAggregateArgs>): Prisma.PrismaPromise<GetCampaignAuditEventAggregateType<T>>

    /**
     * Group by CampaignAuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignAuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignAuditEventGroupByArgs['orderBy'] }
        : { orderBy?: CampaignAuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignAuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignAuditEvent model
   */
  readonly fields: CampaignAuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignAuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignAuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignAuditEvent model
   */
  interface CampaignAuditEventFieldRefs {
    readonly id: FieldRef<"CampaignAuditEvent", 'String'>
    readonly campaignId: FieldRef<"CampaignAuditEvent", 'String'>
    readonly actorId: FieldRef<"CampaignAuditEvent", 'String'>
    readonly actorRole: FieldRef<"CampaignAuditEvent", 'String'>
    readonly eventType: FieldRef<"CampaignAuditEvent", 'CampaignAuditEventType'>
    readonly before: FieldRef<"CampaignAuditEvent", 'Json'>
    readonly after: FieldRef<"CampaignAuditEvent", 'Json'>
    readonly note: FieldRef<"CampaignAuditEvent", 'String'>
    readonly createdAt: FieldRef<"CampaignAuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignAuditEvent findUnique
   */
  export type CampaignAuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAuditEvent to fetch.
     */
    where: CampaignAuditEventWhereUniqueInput
  }

  /**
   * CampaignAuditEvent findUniqueOrThrow
   */
  export type CampaignAuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAuditEvent to fetch.
     */
    where: CampaignAuditEventWhereUniqueInput
  }

  /**
   * CampaignAuditEvent findFirst
   */
  export type CampaignAuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAuditEvent to fetch.
     */
    where?: CampaignAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAuditEvents to fetch.
     */
    orderBy?: CampaignAuditEventOrderByWithRelationInput | CampaignAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAuditEvents.
     */
    cursor?: CampaignAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAuditEvents.
     */
    distinct?: CampaignAuditEventScalarFieldEnum | CampaignAuditEventScalarFieldEnum[]
  }

  /**
   * CampaignAuditEvent findFirstOrThrow
   */
  export type CampaignAuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAuditEvent to fetch.
     */
    where?: CampaignAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAuditEvents to fetch.
     */
    orderBy?: CampaignAuditEventOrderByWithRelationInput | CampaignAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAuditEvents.
     */
    cursor?: CampaignAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAuditEvents.
     */
    distinct?: CampaignAuditEventScalarFieldEnum | CampaignAuditEventScalarFieldEnum[]
  }

  /**
   * CampaignAuditEvent findMany
   */
  export type CampaignAuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAuditEvents to fetch.
     */
    where?: CampaignAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAuditEvents to fetch.
     */
    orderBy?: CampaignAuditEventOrderByWithRelationInput | CampaignAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignAuditEvents.
     */
    cursor?: CampaignAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAuditEvents.
     */
    skip?: number
    distinct?: CampaignAuditEventScalarFieldEnum | CampaignAuditEventScalarFieldEnum[]
  }

  /**
   * CampaignAuditEvent create
   */
  export type CampaignAuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignAuditEvent.
     */
    data: XOR<CampaignAuditEventCreateInput, CampaignAuditEventUncheckedCreateInput>
  }

  /**
   * CampaignAuditEvent createMany
   */
  export type CampaignAuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignAuditEvents.
     */
    data: CampaignAuditEventCreateManyInput | CampaignAuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignAuditEvent createManyAndReturn
   */
  export type CampaignAuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignAuditEvents.
     */
    data: CampaignAuditEventCreateManyInput | CampaignAuditEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignAuditEvent update
   */
  export type CampaignAuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignAuditEvent.
     */
    data: XOR<CampaignAuditEventUpdateInput, CampaignAuditEventUncheckedUpdateInput>
    /**
     * Choose, which CampaignAuditEvent to update.
     */
    where: CampaignAuditEventWhereUniqueInput
  }

  /**
   * CampaignAuditEvent updateMany
   */
  export type CampaignAuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignAuditEvents.
     */
    data: XOR<CampaignAuditEventUpdateManyMutationInput, CampaignAuditEventUncheckedUpdateManyInput>
    /**
     * Filter which CampaignAuditEvents to update
     */
    where?: CampaignAuditEventWhereInput
    /**
     * Limit how many CampaignAuditEvents to update.
     */
    limit?: number
  }

  /**
   * CampaignAuditEvent updateManyAndReturn
   */
  export type CampaignAuditEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * The data used to update CampaignAuditEvents.
     */
    data: XOR<CampaignAuditEventUpdateManyMutationInput, CampaignAuditEventUncheckedUpdateManyInput>
    /**
     * Filter which CampaignAuditEvents to update
     */
    where?: CampaignAuditEventWhereInput
    /**
     * Limit how many CampaignAuditEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignAuditEvent upsert
   */
  export type CampaignAuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignAuditEvent to update in case it exists.
     */
    where: CampaignAuditEventWhereUniqueInput
    /**
     * In case the CampaignAuditEvent found by the `where` argument doesn't exist, create a new CampaignAuditEvent with this data.
     */
    create: XOR<CampaignAuditEventCreateInput, CampaignAuditEventUncheckedCreateInput>
    /**
     * In case the CampaignAuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignAuditEventUpdateInput, CampaignAuditEventUncheckedUpdateInput>
  }

  /**
   * CampaignAuditEvent delete
   */
  export type CampaignAuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
    /**
     * Filter which CampaignAuditEvent to delete.
     */
    where: CampaignAuditEventWhereUniqueInput
  }

  /**
   * CampaignAuditEvent deleteMany
   */
  export type CampaignAuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAuditEvents to delete
     */
    where?: CampaignAuditEventWhereInput
    /**
     * Limit how many CampaignAuditEvents to delete.
     */
    limit?: number
  }

  /**
   * CampaignAuditEvent without action
   */
  export type CampaignAuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAuditEvent
     */
    select?: CampaignAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignAuditEvent
     */
    omit?: CampaignAuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAuditEventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    profilePicture: 'profilePicture',
    whatsappNumber: 'whatsappNumber',
    teamId: 'teamId',
    trustScore: 'trustScore',
    isActive: 'isActive',
    weaponsOfChoice: 'weaponsOfChoice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    media: 'media',
    mediaType: 'mediaType',
    mediaUrl: 'mediaUrl',
    thumbnailUrl: 'thumbnailUrl',
    ctaText: 'ctaText',
    ctaUrl: 'ctaUrl',
    createdById: 'createdById',
    status: 'status',
    goalType: 'goalType',
    goalTarget: 'goalTarget',
    goalCurrent: 'goalCurrent',
    startDate: 'startDate',
    endDate: 'endDate',
    targetAudience: 'targetAudience',
    publishedAt: 'publishedAt',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaImage: 'metaImage',
    viewCount: 'viewCount',
    clickCount: 'clickCount',
    shareCount: 'shareCount',
    likeCount: 'likeCount',
    participantCount: 'participantCount',
    isMegaCampaign: 'isMegaCampaign',
    parentCampaignId: 'parentCampaignId',
    bankAccountIds: 'bankAccountIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignParticipationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    campaignId: 'campaignId',
    joinedAt: 'joinedAt',
    smartLinkId: 'smartLinkId'
  };

  export type CampaignParticipationScalarFieldEnum = (typeof CampaignParticipationScalarFieldEnum)[keyof typeof CampaignParticipationScalarFieldEnum]


  export const SmartLinkScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    userId: 'userId',
    campaignId: 'campaignId',
    originalUrl: 'originalUrl',
    clickCount: 'clickCount',
    uniqueClickCount: 'uniqueClickCount',
    conversionCount: 'conversionCount',
    isActive: 'isActive',
    isExpired: 'isExpired',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SmartLinkScalarFieldEnum = (typeof SmartLinkScalarFieldEnum)[keyof typeof SmartLinkScalarFieldEnum]


  export const LinkEventScalarFieldEnum: {
    id: 'id',
    linkId: 'linkId',
    smartLinkId: 'smartLinkId',
    slug: 'slug',
    eventType: 'eventType',
    type: 'type',
    userId: 'userId',
    ipAddress: 'ipAddress',
    ipHash: 'ipHash',
    userAgent: 'userAgent',
    referrer: 'referrer',
    referer: 'referer',
    country: 'country',
    createdAt: 'createdAt'
  };

  export type LinkEventScalarFieldEnum = (typeof LinkEventScalarFieldEnum)[keyof typeof LinkEventScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    inviterId: 'inviterId',
    inviteeId: 'inviteeId',
    campaignId: 'campaignId',
    slug: 'slug',
    createdAt: 'createdAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const DonationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    campaignId: 'campaignId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    reference: 'reference',
    bankAccountId: 'bankAccountId',
    proofScreenshotUrl: 'proofScreenshotUrl',
    verifiedById: 'verifiedById',
    verifiedAt: 'verifiedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


  export const PointsLedgerEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    campaignId: 'campaignId',
    type: 'type',
    value: 'value',
    description: 'description',
    referenceId: 'referenceId',
    createdAt: 'createdAt'
  };

  export type PointsLedgerEntryScalarFieldEnum = (typeof PointsLedgerEntryScalarFieldEnum)[keyof typeof PointsLedgerEntryScalarFieldEnum]


  export const LeaderboardSnapshotScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    campaignId: 'campaignId',
    period: 'period',
    rank: 'rank',
    score: 'score',
    createdAt: 'createdAt'
  };

  export type LeaderboardSnapshotScalarFieldEnum = (typeof LeaderboardSnapshotScalarFieldEnum)[keyof typeof LeaderboardSnapshotScalarFieldEnum]


  export const TrustScoreScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    score: 'score',
    flags: 'flags',
    lastReviewedAt: 'lastReviewedAt',
    updatedAt: 'updatedAt'
  };

  export type TrustScoreScalarFieldEnum = (typeof TrustScoreScalarFieldEnum)[keyof typeof TrustScoreScalarFieldEnum]


  export const AppNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    body: 'body',
    isRead: 'isRead',
    link: 'link',
    createdAt: 'createdAt'
  };

  export type AppNotificationScalarFieldEnum = (typeof AppNotificationScalarFieldEnum)[keyof typeof AppNotificationScalarFieldEnum]


  export const ViewProofScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    campaignId: 'campaignId',
    smartLinkId: 'smartLinkId',
    platform: 'platform',
    screenshotUrl: 'screenshotUrl',
    status: 'status',
    reviewedById: 'reviewedById',
    reviewedAt: 'reviewedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ViewProofScalarFieldEnum = (typeof ViewProofScalarFieldEnum)[keyof typeof ViewProofScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    maxTeams: 'maxTeams',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    groupId: 'groupId',
    teamLeadId: 'teamLeadId',
    maxMembers: 'maxMembers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamInviteLinkScalarFieldEnum: {
    id: 'id',
    token: 'token',
    teamId: 'teamId',
    targetRole: 'targetRole',
    createdById: 'createdById',
    usedCount: 'usedCount',
    maxUses: 'maxUses',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type TeamInviteLinkScalarFieldEnum = (typeof TeamInviteLinkScalarFieldEnum)[keyof typeof TeamInviteLinkScalarFieldEnum]


  export const CampaignAuditEventScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    actorId: 'actorId',
    actorRole: 'actorRole',
    eventType: 'eventType',
    before: 'before',
    after: 'after',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type CampaignAuditEventScalarFieldEnum = (typeof CampaignAuditEventScalarFieldEnum)[keyof typeof CampaignAuditEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SocialPlatform[]'
   */
  export type ListEnumSocialPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialPlatform[]'>
    


  /**
   * Reference to a field of type 'SocialPlatform'
   */
  export type EnumSocialPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialPlatform'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CampaignMediaType'
   */
  export type EnumCampaignMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignMediaType'>
    


  /**
   * Reference to a field of type 'CampaignMediaType[]'
   */
  export type ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignMediaType[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'GoalType'
   */
  export type EnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType'>
    


  /**
   * Reference to a field of type 'GoalType[]'
   */
  export type ListEnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType[]'>
    


  /**
   * Reference to a field of type 'LinkEventType'
   */
  export type EnumLinkEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LinkEventType'>
    


  /**
   * Reference to a field of type 'LinkEventType[]'
   */
  export type ListEnumLinkEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LinkEventType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DonationStatus'
   */
  export type EnumDonationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DonationStatus'>
    


  /**
   * Reference to a field of type 'DonationStatus[]'
   */
  export type ListEnumDonationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DonationStatus[]'>
    


  /**
   * Reference to a field of type 'PointType'
   */
  export type EnumPointTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PointType'>
    


  /**
   * Reference to a field of type 'PointType[]'
   */
  export type ListEnumPointTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PointType[]'>
    


  /**
   * Reference to a field of type 'TrustFlag[]'
   */
  export type ListEnumTrustFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrustFlag[]'>
    


  /**
   * Reference to a field of type 'TrustFlag'
   */
  export type EnumTrustFlagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrustFlag'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'ViewProofStatus'
   */
  export type EnumViewProofStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ViewProofStatus'>
    


  /**
   * Reference to a field of type 'ViewProofStatus[]'
   */
  export type ListEnumViewProofStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ViewProofStatus[]'>
    


  /**
   * Reference to a field of type 'CampaignAuditEventType'
   */
  export type EnumCampaignAuditEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignAuditEventType'>
    


  /**
   * Reference to a field of type 'CampaignAuditEventType[]'
   */
  export type ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignAuditEventType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profilePicture?: StringNullableFilter<"User"> | string | null
    whatsappNumber?: StringNullableFilter<"User"> | string | null
    teamId?: StringNullableFilter<"User"> | string | null
    trustScore?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    weaponsOfChoice?: EnumSocialPlatformNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    createdCampaigns?: CampaignListRelationFilter
    participations?: CampaignParticipationListRelationFilter
    smartLinks?: SmartLinkListRelationFilter
    referralsGiven?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    donations?: DonationListRelationFilter
    verifiedDonations?: DonationListRelationFilter
    pointsLedger?: PointsLedgerEntryListRelationFilter
    leaderboardEntries?: LeaderboardSnapshotListRelationFilter
    trustScoreRecord?: XOR<TrustScoreNullableScalarRelationFilter, TrustScoreWhereInput> | null
    notifications?: AppNotificationListRelationFilter
    viewProofs?: ViewProofListRelationFilter
    reviewedProofs?: ViewProofListRelationFilter
    teamInviteLinks?: TeamInviteLinkListRelationFilter
    auditEvents?: CampaignAuditEventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    isActive?: SortOrder
    weaponsOfChoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    createdCampaigns?: CampaignOrderByRelationAggregateInput
    participations?: CampaignParticipationOrderByRelationAggregateInput
    smartLinks?: SmartLinkOrderByRelationAggregateInput
    referralsGiven?: ReferralOrderByRelationAggregateInput
    referralsReceived?: ReferralOrderByRelationAggregateInput
    donations?: DonationOrderByRelationAggregateInput
    verifiedDonations?: DonationOrderByRelationAggregateInput
    pointsLedger?: PointsLedgerEntryOrderByRelationAggregateInput
    leaderboardEntries?: LeaderboardSnapshotOrderByRelationAggregateInput
    trustScoreRecord?: TrustScoreOrderByWithRelationInput
    notifications?: AppNotificationOrderByRelationAggregateInput
    viewProofs?: ViewProofOrderByRelationAggregateInput
    reviewedProofs?: ViewProofOrderByRelationAggregateInput
    teamInviteLinks?: TeamInviteLinkOrderByRelationAggregateInput
    auditEvents?: CampaignAuditEventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profilePicture?: StringNullableFilter<"User"> | string | null
    whatsappNumber?: StringNullableFilter<"User"> | string | null
    teamId?: StringNullableFilter<"User"> | string | null
    trustScore?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    weaponsOfChoice?: EnumSocialPlatformNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    createdCampaigns?: CampaignListRelationFilter
    participations?: CampaignParticipationListRelationFilter
    smartLinks?: SmartLinkListRelationFilter
    referralsGiven?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    donations?: DonationListRelationFilter
    verifiedDonations?: DonationListRelationFilter
    pointsLedger?: PointsLedgerEntryListRelationFilter
    leaderboardEntries?: LeaderboardSnapshotListRelationFilter
    trustScoreRecord?: XOR<TrustScoreNullableScalarRelationFilter, TrustScoreWhereInput> | null
    notifications?: AppNotificationListRelationFilter
    viewProofs?: ViewProofListRelationFilter
    reviewedProofs?: ViewProofListRelationFilter
    teamInviteLinks?: TeamInviteLinkListRelationFilter
    auditEvents?: CampaignAuditEventListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    isActive?: SortOrder
    weaponsOfChoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    whatsappNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"User"> | string | null
    trustScore?: IntWithAggregatesFilter<"User"> | number
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    weaponsOfChoice?: EnumSocialPlatformNullableListFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    title?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    content?: StringFilter<"Campaign"> | string
    media?: JsonFilter<"Campaign">
    mediaType?: EnumCampaignMediaTypeNullableFilter<"Campaign"> | $Enums.CampaignMediaType | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    thumbnailUrl?: StringNullableFilter<"Campaign"> | string | null
    ctaText?: StringNullableFilter<"Campaign"> | string | null
    ctaUrl?: StringNullableFilter<"Campaign"> | string | null
    createdById?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    goalType?: EnumGoalTypeNullableFilter<"Campaign"> | $Enums.GoalType | null
    goalTarget?: IntNullableFilter<"Campaign"> | number | null
    goalCurrent?: IntNullableFilter<"Campaign"> | number | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    targetAudience?: StringNullableListFilter<"Campaign">
    publishedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    metaTitle?: StringNullableFilter<"Campaign"> | string | null
    metaDescription?: StringNullableFilter<"Campaign"> | string | null
    metaImage?: StringNullableFilter<"Campaign"> | string | null
    viewCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    shareCount?: IntFilter<"Campaign"> | number
    likeCount?: IntNullableFilter<"Campaign"> | number | null
    participantCount?: IntNullableFilter<"Campaign"> | number | null
    isMegaCampaign?: BoolNullableFilter<"Campaign"> | boolean | null
    parentCampaignId?: StringNullableFilter<"Campaign"> | string | null
    bankAccountIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    parentCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    subCampaigns?: CampaignListRelationFilter
    participations?: CampaignParticipationListRelationFilter
    smartLinks?: SmartLinkListRelationFilter
    referrals?: ReferralListRelationFilter
    donations?: DonationListRelationFilter
    pointsLedger?: PointsLedgerEntryListRelationFilter
    leaderboard?: LeaderboardSnapshotListRelationFilter
    viewProofs?: ViewProofListRelationFilter
    auditEvents?: CampaignAuditEventListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    media?: SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    status?: SortOrder
    goalType?: SortOrderInput | SortOrder
    goalTarget?: SortOrderInput | SortOrder
    goalCurrent?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    targetAudience?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaImage?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    shareCount?: SortOrder
    likeCount?: SortOrderInput | SortOrder
    participantCount?: SortOrderInput | SortOrder
    isMegaCampaign?: SortOrderInput | SortOrder
    parentCampaignId?: SortOrderInput | SortOrder
    bankAccountIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    parentCampaign?: CampaignOrderByWithRelationInput
    subCampaigns?: CampaignOrderByRelationAggregateInput
    participations?: CampaignParticipationOrderByRelationAggregateInput
    smartLinks?: SmartLinkOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    donations?: DonationOrderByRelationAggregateInput
    pointsLedger?: PointsLedgerEntryOrderByRelationAggregateInput
    leaderboard?: LeaderboardSnapshotOrderByRelationAggregateInput
    viewProofs?: ViewProofOrderByRelationAggregateInput
    auditEvents?: CampaignAuditEventOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    title?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    content?: StringFilter<"Campaign"> | string
    media?: JsonFilter<"Campaign">
    mediaType?: EnumCampaignMediaTypeNullableFilter<"Campaign"> | $Enums.CampaignMediaType | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    thumbnailUrl?: StringNullableFilter<"Campaign"> | string | null
    ctaText?: StringNullableFilter<"Campaign"> | string | null
    ctaUrl?: StringNullableFilter<"Campaign"> | string | null
    createdById?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    goalType?: EnumGoalTypeNullableFilter<"Campaign"> | $Enums.GoalType | null
    goalTarget?: IntNullableFilter<"Campaign"> | number | null
    goalCurrent?: IntNullableFilter<"Campaign"> | number | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    targetAudience?: StringNullableListFilter<"Campaign">
    publishedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    metaTitle?: StringNullableFilter<"Campaign"> | string | null
    metaDescription?: StringNullableFilter<"Campaign"> | string | null
    metaImage?: StringNullableFilter<"Campaign"> | string | null
    viewCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    shareCount?: IntFilter<"Campaign"> | number
    likeCount?: IntNullableFilter<"Campaign"> | number | null
    participantCount?: IntNullableFilter<"Campaign"> | number | null
    isMegaCampaign?: BoolNullableFilter<"Campaign"> | boolean | null
    parentCampaignId?: StringNullableFilter<"Campaign"> | string | null
    bankAccountIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    parentCampaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
    subCampaigns?: CampaignListRelationFilter
    participations?: CampaignParticipationListRelationFilter
    smartLinks?: SmartLinkListRelationFilter
    referrals?: ReferralListRelationFilter
    donations?: DonationListRelationFilter
    pointsLedger?: PointsLedgerEntryListRelationFilter
    leaderboard?: LeaderboardSnapshotListRelationFilter
    viewProofs?: ViewProofListRelationFilter
    auditEvents?: CampaignAuditEventListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    media?: SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    status?: SortOrder
    goalType?: SortOrderInput | SortOrder
    goalTarget?: SortOrderInput | SortOrder
    goalCurrent?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    targetAudience?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaImage?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    shareCount?: SortOrder
    likeCount?: SortOrderInput | SortOrder
    participantCount?: SortOrderInput | SortOrder
    isMegaCampaign?: SortOrderInput | SortOrder
    parentCampaignId?: SortOrderInput | SortOrder
    bankAccountIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    title?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringWithAggregatesFilter<"Campaign"> | string
    content?: StringWithAggregatesFilter<"Campaign"> | string
    media?: JsonWithAggregatesFilter<"Campaign">
    mediaType?: EnumCampaignMediaTypeNullableWithAggregatesFilter<"Campaign"> | $Enums.CampaignMediaType | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    ctaText?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    ctaUrl?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdById?: StringWithAggregatesFilter<"Campaign"> | string
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    goalType?: EnumGoalTypeNullableWithAggregatesFilter<"Campaign"> | $Enums.GoalType | null
    goalTarget?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    goalCurrent?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    targetAudience?: StringNullableListFilter<"Campaign">
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    metaImage?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    viewCount?: IntWithAggregatesFilter<"Campaign"> | number
    clickCount?: IntWithAggregatesFilter<"Campaign"> | number
    shareCount?: IntWithAggregatesFilter<"Campaign"> | number
    likeCount?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    participantCount?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    isMegaCampaign?: BoolNullableWithAggregatesFilter<"Campaign"> | boolean | null
    parentCampaignId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    bankAccountIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignParticipationWhereInput = {
    AND?: CampaignParticipationWhereInput | CampaignParticipationWhereInput[]
    OR?: CampaignParticipationWhereInput[]
    NOT?: CampaignParticipationWhereInput | CampaignParticipationWhereInput[]
    id?: StringFilter<"CampaignParticipation"> | string
    userId?: StringFilter<"CampaignParticipation"> | string
    campaignId?: StringFilter<"CampaignParticipation"> | string
    joinedAt?: DateTimeFilter<"CampaignParticipation"> | Date | string
    smartLinkId?: StringNullableFilter<"CampaignParticipation"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignParticipationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    joinedAt?: SortOrder
    smartLinkId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_campaignId?: CampaignParticipationUserIdCampaignIdCompoundUniqueInput
    AND?: CampaignParticipationWhereInput | CampaignParticipationWhereInput[]
    OR?: CampaignParticipationWhereInput[]
    NOT?: CampaignParticipationWhereInput | CampaignParticipationWhereInput[]
    userId?: StringFilter<"CampaignParticipation"> | string
    campaignId?: StringFilter<"CampaignParticipation"> | string
    joinedAt?: DateTimeFilter<"CampaignParticipation"> | Date | string
    smartLinkId?: StringNullableFilter<"CampaignParticipation"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "userId_campaignId">

  export type CampaignParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    joinedAt?: SortOrder
    smartLinkId?: SortOrderInput | SortOrder
    _count?: CampaignParticipationCountOrderByAggregateInput
    _max?: CampaignParticipationMaxOrderByAggregateInput
    _min?: CampaignParticipationMinOrderByAggregateInput
  }

  export type CampaignParticipationScalarWhereWithAggregatesInput = {
    AND?: CampaignParticipationScalarWhereWithAggregatesInput | CampaignParticipationScalarWhereWithAggregatesInput[]
    OR?: CampaignParticipationScalarWhereWithAggregatesInput[]
    NOT?: CampaignParticipationScalarWhereWithAggregatesInput | CampaignParticipationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignParticipation"> | string
    userId?: StringWithAggregatesFilter<"CampaignParticipation"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignParticipation"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"CampaignParticipation"> | Date | string
    smartLinkId?: StringNullableWithAggregatesFilter<"CampaignParticipation"> | string | null
  }

  export type SmartLinkWhereInput = {
    AND?: SmartLinkWhereInput | SmartLinkWhereInput[]
    OR?: SmartLinkWhereInput[]
    NOT?: SmartLinkWhereInput | SmartLinkWhereInput[]
    id?: StringFilter<"SmartLink"> | string
    slug?: StringFilter<"SmartLink"> | string
    userId?: StringFilter<"SmartLink"> | string
    campaignId?: StringFilter<"SmartLink"> | string
    originalUrl?: StringFilter<"SmartLink"> | string
    clickCount?: IntFilter<"SmartLink"> | number
    uniqueClickCount?: IntFilter<"SmartLink"> | number
    conversionCount?: IntFilter<"SmartLink"> | number
    isActive?: BoolFilter<"SmartLink"> | boolean
    isExpired?: BoolFilter<"SmartLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"SmartLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SmartLink"> | Date | string
    updatedAt?: DateTimeFilter<"SmartLink"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    linkEvents?: LinkEventListRelationFilter
  }

  export type SmartLinkOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    uniqueClickCount?: SortOrder
    conversionCount?: SortOrder
    isActive?: SortOrder
    isExpired?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    linkEvents?: LinkEventOrderByRelationAggregateInput
  }

  export type SmartLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    userId_campaignId?: SmartLinkUserIdCampaignIdCompoundUniqueInput
    AND?: SmartLinkWhereInput | SmartLinkWhereInput[]
    OR?: SmartLinkWhereInput[]
    NOT?: SmartLinkWhereInput | SmartLinkWhereInput[]
    userId?: StringFilter<"SmartLink"> | string
    campaignId?: StringFilter<"SmartLink"> | string
    originalUrl?: StringFilter<"SmartLink"> | string
    clickCount?: IntFilter<"SmartLink"> | number
    uniqueClickCount?: IntFilter<"SmartLink"> | number
    conversionCount?: IntFilter<"SmartLink"> | number
    isActive?: BoolFilter<"SmartLink"> | boolean
    isExpired?: BoolFilter<"SmartLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"SmartLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SmartLink"> | Date | string
    updatedAt?: DateTimeFilter<"SmartLink"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    linkEvents?: LinkEventListRelationFilter
  }, "id" | "slug" | "userId_campaignId">

  export type SmartLinkOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    uniqueClickCount?: SortOrder
    conversionCount?: SortOrder
    isActive?: SortOrder
    isExpired?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SmartLinkCountOrderByAggregateInput
    _avg?: SmartLinkAvgOrderByAggregateInput
    _max?: SmartLinkMaxOrderByAggregateInput
    _min?: SmartLinkMinOrderByAggregateInput
    _sum?: SmartLinkSumOrderByAggregateInput
  }

  export type SmartLinkScalarWhereWithAggregatesInput = {
    AND?: SmartLinkScalarWhereWithAggregatesInput | SmartLinkScalarWhereWithAggregatesInput[]
    OR?: SmartLinkScalarWhereWithAggregatesInput[]
    NOT?: SmartLinkScalarWhereWithAggregatesInput | SmartLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SmartLink"> | string
    slug?: StringWithAggregatesFilter<"SmartLink"> | string
    userId?: StringWithAggregatesFilter<"SmartLink"> | string
    campaignId?: StringWithAggregatesFilter<"SmartLink"> | string
    originalUrl?: StringWithAggregatesFilter<"SmartLink"> | string
    clickCount?: IntWithAggregatesFilter<"SmartLink"> | number
    uniqueClickCount?: IntWithAggregatesFilter<"SmartLink"> | number
    conversionCount?: IntWithAggregatesFilter<"SmartLink"> | number
    isActive?: BoolWithAggregatesFilter<"SmartLink"> | boolean
    isExpired?: BoolWithAggregatesFilter<"SmartLink"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SmartLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SmartLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SmartLink"> | Date | string
  }

  export type LinkEventWhereInput = {
    AND?: LinkEventWhereInput | LinkEventWhereInput[]
    OR?: LinkEventWhereInput[]
    NOT?: LinkEventWhereInput | LinkEventWhereInput[]
    id?: StringFilter<"LinkEvent"> | string
    linkId?: StringFilter<"LinkEvent"> | string
    smartLinkId?: StringNullableFilter<"LinkEvent"> | string | null
    slug?: StringNullableFilter<"LinkEvent"> | string | null
    eventType?: EnumLinkEventTypeFilter<"LinkEvent"> | $Enums.LinkEventType
    type?: EnumLinkEventTypeNullableFilter<"LinkEvent"> | $Enums.LinkEventType | null
    userId?: StringNullableFilter<"LinkEvent"> | string | null
    ipAddress?: StringNullableFilter<"LinkEvent"> | string | null
    ipHash?: StringNullableFilter<"LinkEvent"> | string | null
    userAgent?: StringNullableFilter<"LinkEvent"> | string | null
    referrer?: StringNullableFilter<"LinkEvent"> | string | null
    referer?: StringNullableFilter<"LinkEvent"> | string | null
    country?: StringNullableFilter<"LinkEvent"> | string | null
    createdAt?: DateTimeFilter<"LinkEvent"> | Date | string
    smartLink?: XOR<SmartLinkScalarRelationFilter, SmartLinkWhereInput>
  }

  export type LinkEventOrderByWithRelationInput = {
    id?: SortOrder
    linkId?: SortOrder
    smartLinkId?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    eventType?: SortOrder
    type?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    smartLink?: SmartLinkOrderByWithRelationInput
  }

  export type LinkEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LinkEventWhereInput | LinkEventWhereInput[]
    OR?: LinkEventWhereInput[]
    NOT?: LinkEventWhereInput | LinkEventWhereInput[]
    linkId?: StringFilter<"LinkEvent"> | string
    smartLinkId?: StringNullableFilter<"LinkEvent"> | string | null
    slug?: StringNullableFilter<"LinkEvent"> | string | null
    eventType?: EnumLinkEventTypeFilter<"LinkEvent"> | $Enums.LinkEventType
    type?: EnumLinkEventTypeNullableFilter<"LinkEvent"> | $Enums.LinkEventType | null
    userId?: StringNullableFilter<"LinkEvent"> | string | null
    ipAddress?: StringNullableFilter<"LinkEvent"> | string | null
    ipHash?: StringNullableFilter<"LinkEvent"> | string | null
    userAgent?: StringNullableFilter<"LinkEvent"> | string | null
    referrer?: StringNullableFilter<"LinkEvent"> | string | null
    referer?: StringNullableFilter<"LinkEvent"> | string | null
    country?: StringNullableFilter<"LinkEvent"> | string | null
    createdAt?: DateTimeFilter<"LinkEvent"> | Date | string
    smartLink?: XOR<SmartLinkScalarRelationFilter, SmartLinkWhereInput>
  }, "id">

  export type LinkEventOrderByWithAggregationInput = {
    id?: SortOrder
    linkId?: SortOrder
    smartLinkId?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    eventType?: SortOrder
    type?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LinkEventCountOrderByAggregateInput
    _max?: LinkEventMaxOrderByAggregateInput
    _min?: LinkEventMinOrderByAggregateInput
  }

  export type LinkEventScalarWhereWithAggregatesInput = {
    AND?: LinkEventScalarWhereWithAggregatesInput | LinkEventScalarWhereWithAggregatesInput[]
    OR?: LinkEventScalarWhereWithAggregatesInput[]
    NOT?: LinkEventScalarWhereWithAggregatesInput | LinkEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinkEvent"> | string
    linkId?: StringWithAggregatesFilter<"LinkEvent"> | string
    smartLinkId?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    slug?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    eventType?: EnumLinkEventTypeWithAggregatesFilter<"LinkEvent"> | $Enums.LinkEventType
    type?: EnumLinkEventTypeNullableWithAggregatesFilter<"LinkEvent"> | $Enums.LinkEventType | null
    userId?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    ipHash?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    referer?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    country?: StringNullableWithAggregatesFilter<"LinkEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LinkEvent"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    inviterId?: StringFilter<"Referral"> | string
    inviteeId?: StringFilter<"Referral"> | string
    campaignId?: StringFilter<"Referral"> | string
    slug?: StringFilter<"Referral"> | string
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitee?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    campaignId?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    inviter?: UserOrderByWithRelationInput
    invitee?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inviteeId_slug?: ReferralInviteeIdSlugCompoundUniqueInput
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    inviterId?: StringFilter<"Referral"> | string
    inviteeId?: StringFilter<"Referral"> | string
    campaignId?: StringFilter<"Referral"> | string
    slug?: StringFilter<"Referral"> | string
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invitee?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "inviteeId_slug">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    campaignId?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    inviterId?: StringWithAggregatesFilter<"Referral"> | string
    inviteeId?: StringWithAggregatesFilter<"Referral"> | string
    campaignId?: StringWithAggregatesFilter<"Referral"> | string
    slug?: StringWithAggregatesFilter<"Referral"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type DonationWhereInput = {
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    id?: StringFilter<"Donation"> | string
    userId?: StringFilter<"Donation"> | string
    campaignId?: StringFilter<"Donation"> | string
    amount?: DecimalFilter<"Donation"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Donation"> | string
    status?: EnumDonationStatusFilter<"Donation"> | $Enums.DonationStatus
    reference?: StringFilter<"Donation"> | string
    bankAccountId?: StringNullableFilter<"Donation"> | string | null
    proofScreenshotUrl?: StringNullableFilter<"Donation"> | string | null
    verifiedById?: StringNullableFilter<"Donation"> | string | null
    verifiedAt?: DateTimeNullableFilter<"Donation"> | Date | string | null
    notes?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DonationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    bankAccountId?: SortOrderInput | SortOrder
    proofScreenshotUrl?: SortOrderInput | SortOrder
    verifiedById?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    verifiedBy?: UserOrderByWithRelationInput
  }

  export type DonationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    userId?: StringFilter<"Donation"> | string
    campaignId?: StringFilter<"Donation"> | string
    amount?: DecimalFilter<"Donation"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Donation"> | string
    status?: EnumDonationStatusFilter<"Donation"> | $Enums.DonationStatus
    bankAccountId?: StringNullableFilter<"Donation"> | string | null
    proofScreenshotUrl?: StringNullableFilter<"Donation"> | string | null
    verifiedById?: StringNullableFilter<"Donation"> | string | null
    verifiedAt?: DateTimeNullableFilter<"Donation"> | Date | string | null
    notes?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "reference">

  export type DonationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    bankAccountId?: SortOrderInput | SortOrder
    proofScreenshotUrl?: SortOrderInput | SortOrder
    verifiedById?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DonationCountOrderByAggregateInput
    _avg?: DonationAvgOrderByAggregateInput
    _max?: DonationMaxOrderByAggregateInput
    _min?: DonationMinOrderByAggregateInput
    _sum?: DonationSumOrderByAggregateInput
  }

  export type DonationScalarWhereWithAggregatesInput = {
    AND?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    OR?: DonationScalarWhereWithAggregatesInput[]
    NOT?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Donation"> | string
    userId?: StringWithAggregatesFilter<"Donation"> | string
    campaignId?: StringWithAggregatesFilter<"Donation"> | string
    amount?: DecimalWithAggregatesFilter<"Donation"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Donation"> | string
    status?: EnumDonationStatusWithAggregatesFilter<"Donation"> | $Enums.DonationStatus
    reference?: StringWithAggregatesFilter<"Donation"> | string
    bankAccountId?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    proofScreenshotUrl?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    verifiedById?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Donation"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
  }

  export type PointsLedgerEntryWhereInput = {
    AND?: PointsLedgerEntryWhereInput | PointsLedgerEntryWhereInput[]
    OR?: PointsLedgerEntryWhereInput[]
    NOT?: PointsLedgerEntryWhereInput | PointsLedgerEntryWhereInput[]
    id?: StringFilter<"PointsLedgerEntry"> | string
    userId?: StringFilter<"PointsLedgerEntry"> | string
    campaignId?: StringNullableFilter<"PointsLedgerEntry"> | string | null
    type?: EnumPointTypeFilter<"PointsLedgerEntry"> | $Enums.PointType
    value?: IntFilter<"PointsLedgerEntry"> | number
    description?: StringFilter<"PointsLedgerEntry"> | string
    referenceId?: StringNullableFilter<"PointsLedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"PointsLedgerEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
  }

  export type PointsLedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type PointsLedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointsLedgerEntryWhereInput | PointsLedgerEntryWhereInput[]
    OR?: PointsLedgerEntryWhereInput[]
    NOT?: PointsLedgerEntryWhereInput | PointsLedgerEntryWhereInput[]
    userId?: StringFilter<"PointsLedgerEntry"> | string
    campaignId?: StringNullableFilter<"PointsLedgerEntry"> | string | null
    type?: EnumPointTypeFilter<"PointsLedgerEntry"> | $Enums.PointType
    value?: IntFilter<"PointsLedgerEntry"> | number
    description?: StringFilter<"PointsLedgerEntry"> | string
    referenceId?: StringNullableFilter<"PointsLedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"PointsLedgerEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
  }, "id">

  export type PointsLedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PointsLedgerEntryCountOrderByAggregateInput
    _avg?: PointsLedgerEntryAvgOrderByAggregateInput
    _max?: PointsLedgerEntryMaxOrderByAggregateInput
    _min?: PointsLedgerEntryMinOrderByAggregateInput
    _sum?: PointsLedgerEntrySumOrderByAggregateInput
  }

  export type PointsLedgerEntryScalarWhereWithAggregatesInput = {
    AND?: PointsLedgerEntryScalarWhereWithAggregatesInput | PointsLedgerEntryScalarWhereWithAggregatesInput[]
    OR?: PointsLedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: PointsLedgerEntryScalarWhereWithAggregatesInput | PointsLedgerEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointsLedgerEntry"> | string
    userId?: StringWithAggregatesFilter<"PointsLedgerEntry"> | string
    campaignId?: StringNullableWithAggregatesFilter<"PointsLedgerEntry"> | string | null
    type?: EnumPointTypeWithAggregatesFilter<"PointsLedgerEntry"> | $Enums.PointType
    value?: IntWithAggregatesFilter<"PointsLedgerEntry"> | number
    description?: StringWithAggregatesFilter<"PointsLedgerEntry"> | string
    referenceId?: StringNullableWithAggregatesFilter<"PointsLedgerEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PointsLedgerEntry"> | Date | string
  }

  export type LeaderboardSnapshotWhereInput = {
    AND?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[]
    OR?: LeaderboardSnapshotWhereInput[]
    NOT?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[]
    id?: StringFilter<"LeaderboardSnapshot"> | string
    userId?: StringFilter<"LeaderboardSnapshot"> | string
    campaignId?: StringNullableFilter<"LeaderboardSnapshot"> | string | null
    period?: StringFilter<"LeaderboardSnapshot"> | string
    rank?: IntFilter<"LeaderboardSnapshot"> | number
    score?: IntFilter<"LeaderboardSnapshot"> | number
    createdAt?: DateTimeFilter<"LeaderboardSnapshot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
  }

  export type LeaderboardSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    period?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type LeaderboardSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[]
    OR?: LeaderboardSnapshotWhereInput[]
    NOT?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[]
    userId?: StringFilter<"LeaderboardSnapshot"> | string
    campaignId?: StringNullableFilter<"LeaderboardSnapshot"> | string | null
    period?: StringFilter<"LeaderboardSnapshot"> | string
    rank?: IntFilter<"LeaderboardSnapshot"> | number
    score?: IntFilter<"LeaderboardSnapshot"> | number
    createdAt?: DateTimeFilter<"LeaderboardSnapshot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableScalarRelationFilter, CampaignWhereInput> | null
  }, "id">

  export type LeaderboardSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    period?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    _count?: LeaderboardSnapshotCountOrderByAggregateInput
    _avg?: LeaderboardSnapshotAvgOrderByAggregateInput
    _max?: LeaderboardSnapshotMaxOrderByAggregateInput
    _min?: LeaderboardSnapshotMinOrderByAggregateInput
    _sum?: LeaderboardSnapshotSumOrderByAggregateInput
  }

  export type LeaderboardSnapshotScalarWhereWithAggregatesInput = {
    AND?: LeaderboardSnapshotScalarWhereWithAggregatesInput | LeaderboardSnapshotScalarWhereWithAggregatesInput[]
    OR?: LeaderboardSnapshotScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardSnapshotScalarWhereWithAggregatesInput | LeaderboardSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaderboardSnapshot"> | string
    userId?: StringWithAggregatesFilter<"LeaderboardSnapshot"> | string
    campaignId?: StringNullableWithAggregatesFilter<"LeaderboardSnapshot"> | string | null
    period?: StringWithAggregatesFilter<"LeaderboardSnapshot"> | string
    rank?: IntWithAggregatesFilter<"LeaderboardSnapshot"> | number
    score?: IntWithAggregatesFilter<"LeaderboardSnapshot"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LeaderboardSnapshot"> | Date | string
  }

  export type TrustScoreWhereInput = {
    AND?: TrustScoreWhereInput | TrustScoreWhereInput[]
    OR?: TrustScoreWhereInput[]
    NOT?: TrustScoreWhereInput | TrustScoreWhereInput[]
    id?: StringFilter<"TrustScore"> | string
    userId?: StringFilter<"TrustScore"> | string
    score?: IntFilter<"TrustScore"> | number
    flags?: EnumTrustFlagNullableListFilter<"TrustScore">
    lastReviewedAt?: DateTimeNullableFilter<"TrustScore"> | Date | string | null
    updatedAt?: DateTimeFilter<"TrustScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrustScoreOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    flags?: SortOrder
    lastReviewedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TrustScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TrustScoreWhereInput | TrustScoreWhereInput[]
    OR?: TrustScoreWhereInput[]
    NOT?: TrustScoreWhereInput | TrustScoreWhereInput[]
    score?: IntFilter<"TrustScore"> | number
    flags?: EnumTrustFlagNullableListFilter<"TrustScore">
    lastReviewedAt?: DateTimeNullableFilter<"TrustScore"> | Date | string | null
    updatedAt?: DateTimeFilter<"TrustScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TrustScoreOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    flags?: SortOrder
    lastReviewedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: TrustScoreCountOrderByAggregateInput
    _avg?: TrustScoreAvgOrderByAggregateInput
    _max?: TrustScoreMaxOrderByAggregateInput
    _min?: TrustScoreMinOrderByAggregateInput
    _sum?: TrustScoreSumOrderByAggregateInput
  }

  export type TrustScoreScalarWhereWithAggregatesInput = {
    AND?: TrustScoreScalarWhereWithAggregatesInput | TrustScoreScalarWhereWithAggregatesInput[]
    OR?: TrustScoreScalarWhereWithAggregatesInput[]
    NOT?: TrustScoreScalarWhereWithAggregatesInput | TrustScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrustScore"> | string
    userId?: StringWithAggregatesFilter<"TrustScore"> | string
    score?: IntWithAggregatesFilter<"TrustScore"> | number
    flags?: EnumTrustFlagNullableListFilter<"TrustScore">
    lastReviewedAt?: DateTimeNullableWithAggregatesFilter<"TrustScore"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"TrustScore"> | Date | string
  }

  export type AppNotificationWhereInput = {
    AND?: AppNotificationWhereInput | AppNotificationWhereInput[]
    OR?: AppNotificationWhereInput[]
    NOT?: AppNotificationWhereInput | AppNotificationWhereInput[]
    id?: StringFilter<"AppNotification"> | string
    userId?: StringFilter<"AppNotification"> | string
    type?: EnumNotificationTypeFilter<"AppNotification"> | $Enums.NotificationType
    title?: StringFilter<"AppNotification"> | string
    body?: StringFilter<"AppNotification"> | string
    isRead?: BoolFilter<"AppNotification"> | boolean
    link?: StringNullableFilter<"AppNotification"> | string | null
    createdAt?: DateTimeFilter<"AppNotification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AppNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AppNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppNotificationWhereInput | AppNotificationWhereInput[]
    OR?: AppNotificationWhereInput[]
    NOT?: AppNotificationWhereInput | AppNotificationWhereInput[]
    userId?: StringFilter<"AppNotification"> | string
    type?: EnumNotificationTypeFilter<"AppNotification"> | $Enums.NotificationType
    title?: StringFilter<"AppNotification"> | string
    body?: StringFilter<"AppNotification"> | string
    isRead?: BoolFilter<"AppNotification"> | boolean
    link?: StringNullableFilter<"AppNotification"> | string | null
    createdAt?: DateTimeFilter<"AppNotification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AppNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AppNotificationCountOrderByAggregateInput
    _max?: AppNotificationMaxOrderByAggregateInput
    _min?: AppNotificationMinOrderByAggregateInput
  }

  export type AppNotificationScalarWhereWithAggregatesInput = {
    AND?: AppNotificationScalarWhereWithAggregatesInput | AppNotificationScalarWhereWithAggregatesInput[]
    OR?: AppNotificationScalarWhereWithAggregatesInput[]
    NOT?: AppNotificationScalarWhereWithAggregatesInput | AppNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppNotification"> | string
    userId?: StringWithAggregatesFilter<"AppNotification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"AppNotification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"AppNotification"> | string
    body?: StringWithAggregatesFilter<"AppNotification"> | string
    isRead?: BoolWithAggregatesFilter<"AppNotification"> | boolean
    link?: StringNullableWithAggregatesFilter<"AppNotification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AppNotification"> | Date | string
  }

  export type ViewProofWhereInput = {
    AND?: ViewProofWhereInput | ViewProofWhereInput[]
    OR?: ViewProofWhereInput[]
    NOT?: ViewProofWhereInput | ViewProofWhereInput[]
    id?: StringFilter<"ViewProof"> | string
    userId?: StringFilter<"ViewProof"> | string
    campaignId?: StringFilter<"ViewProof"> | string
    smartLinkId?: StringFilter<"ViewProof"> | string
    platform?: EnumSocialPlatformFilter<"ViewProof"> | $Enums.SocialPlatform
    screenshotUrl?: StringFilter<"ViewProof"> | string
    status?: EnumViewProofStatusFilter<"ViewProof"> | $Enums.ViewProofStatus
    reviewedById?: StringNullableFilter<"ViewProof"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ViewProof"> | Date | string | null
    notes?: StringNullableFilter<"ViewProof"> | string | null
    createdAt?: DateTimeFilter<"ViewProof"> | Date | string
    updatedAt?: DateTimeFilter<"ViewProof"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type ViewProofOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    smartLinkId?: SortOrder
    platform?: SortOrder
    screenshotUrl?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    reviewedBy?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type ViewProofWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViewProofWhereInput | ViewProofWhereInput[]
    OR?: ViewProofWhereInput[]
    NOT?: ViewProofWhereInput | ViewProofWhereInput[]
    userId?: StringFilter<"ViewProof"> | string
    campaignId?: StringFilter<"ViewProof"> | string
    smartLinkId?: StringFilter<"ViewProof"> | string
    platform?: EnumSocialPlatformFilter<"ViewProof"> | $Enums.SocialPlatform
    screenshotUrl?: StringFilter<"ViewProof"> | string
    status?: EnumViewProofStatusFilter<"ViewProof"> | $Enums.ViewProofStatus
    reviewedById?: StringNullableFilter<"ViewProof"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ViewProof"> | Date | string | null
    notes?: StringNullableFilter<"ViewProof"> | string | null
    createdAt?: DateTimeFilter<"ViewProof"> | Date | string
    updatedAt?: DateTimeFilter<"ViewProof"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id">

  export type ViewProofOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    smartLinkId?: SortOrder
    platform?: SortOrder
    screenshotUrl?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ViewProofCountOrderByAggregateInput
    _max?: ViewProofMaxOrderByAggregateInput
    _min?: ViewProofMinOrderByAggregateInput
  }

  export type ViewProofScalarWhereWithAggregatesInput = {
    AND?: ViewProofScalarWhereWithAggregatesInput | ViewProofScalarWhereWithAggregatesInput[]
    OR?: ViewProofScalarWhereWithAggregatesInput[]
    NOT?: ViewProofScalarWhereWithAggregatesInput | ViewProofScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViewProof"> | string
    userId?: StringWithAggregatesFilter<"ViewProof"> | string
    campaignId?: StringWithAggregatesFilter<"ViewProof"> | string
    smartLinkId?: StringWithAggregatesFilter<"ViewProof"> | string
    platform?: EnumSocialPlatformWithAggregatesFilter<"ViewProof"> | $Enums.SocialPlatform
    screenshotUrl?: StringWithAggregatesFilter<"ViewProof"> | string
    status?: EnumViewProofStatusWithAggregatesFilter<"ViewProof"> | $Enums.ViewProofStatus
    reviewedById?: StringNullableWithAggregatesFilter<"ViewProof"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ViewProof"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ViewProof"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ViewProof"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViewProof"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    maxTeams?: IntFilter<"Group"> | number
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    teams?: TeamListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxTeams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teams?: TeamOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    maxTeams?: IntFilter<"Group"> | number
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    teams?: TeamListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxTeams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    maxTeams?: IntWithAggregatesFilter<"Group"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    groupId?: StringFilter<"Team"> | string
    teamLeadId?: StringNullableFilter<"Team"> | string | null
    maxMembers?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    members?: UserListRelationFilter
    teamInviteLinks?: TeamInviteLinkListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    teamLeadId?: SortOrderInput | SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    members?: UserOrderByRelationAggregateInput
    teamInviteLinks?: TeamInviteLinkOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    groupId?: StringFilter<"Team"> | string
    teamLeadId?: StringNullableFilter<"Team"> | string | null
    maxMembers?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    members?: UserListRelationFilter
    teamInviteLinks?: TeamInviteLinkListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    teamLeadId?: SortOrderInput | SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    groupId?: StringWithAggregatesFilter<"Team"> | string
    teamLeadId?: StringNullableWithAggregatesFilter<"Team"> | string | null
    maxMembers?: IntWithAggregatesFilter<"Team"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamInviteLinkWhereInput = {
    AND?: TeamInviteLinkWhereInput | TeamInviteLinkWhereInput[]
    OR?: TeamInviteLinkWhereInput[]
    NOT?: TeamInviteLinkWhereInput | TeamInviteLinkWhereInput[]
    id?: StringFilter<"TeamInviteLink"> | string
    token?: StringFilter<"TeamInviteLink"> | string
    teamId?: StringFilter<"TeamInviteLink"> | string
    targetRole?: StringFilter<"TeamInviteLink"> | string
    createdById?: StringFilter<"TeamInviteLink"> | string
    usedCount?: IntFilter<"TeamInviteLink"> | number
    maxUses?: IntFilter<"TeamInviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"TeamInviteLink"> | Date | string | null
    isActive?: BoolFilter<"TeamInviteLink"> | boolean
    createdAt?: DateTimeFilter<"TeamInviteLink"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamInviteLinkOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    teamId?: SortOrder
    targetRole?: SortOrder
    createdById?: SortOrder
    usedCount?: SortOrder
    maxUses?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type TeamInviteLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TeamInviteLinkWhereInput | TeamInviteLinkWhereInput[]
    OR?: TeamInviteLinkWhereInput[]
    NOT?: TeamInviteLinkWhereInput | TeamInviteLinkWhereInput[]
    teamId?: StringFilter<"TeamInviteLink"> | string
    targetRole?: StringFilter<"TeamInviteLink"> | string
    createdById?: StringFilter<"TeamInviteLink"> | string
    usedCount?: IntFilter<"TeamInviteLink"> | number
    maxUses?: IntFilter<"TeamInviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"TeamInviteLink"> | Date | string | null
    isActive?: BoolFilter<"TeamInviteLink"> | boolean
    createdAt?: DateTimeFilter<"TeamInviteLink"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type TeamInviteLinkOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    teamId?: SortOrder
    targetRole?: SortOrder
    createdById?: SortOrder
    usedCount?: SortOrder
    maxUses?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: TeamInviteLinkCountOrderByAggregateInput
    _avg?: TeamInviteLinkAvgOrderByAggregateInput
    _max?: TeamInviteLinkMaxOrderByAggregateInput
    _min?: TeamInviteLinkMinOrderByAggregateInput
    _sum?: TeamInviteLinkSumOrderByAggregateInput
  }

  export type TeamInviteLinkScalarWhereWithAggregatesInput = {
    AND?: TeamInviteLinkScalarWhereWithAggregatesInput | TeamInviteLinkScalarWhereWithAggregatesInput[]
    OR?: TeamInviteLinkScalarWhereWithAggregatesInput[]
    NOT?: TeamInviteLinkScalarWhereWithAggregatesInput | TeamInviteLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamInviteLink"> | string
    token?: StringWithAggregatesFilter<"TeamInviteLink"> | string
    teamId?: StringWithAggregatesFilter<"TeamInviteLink"> | string
    targetRole?: StringWithAggregatesFilter<"TeamInviteLink"> | string
    createdById?: StringWithAggregatesFilter<"TeamInviteLink"> | string
    usedCount?: IntWithAggregatesFilter<"TeamInviteLink"> | number
    maxUses?: IntWithAggregatesFilter<"TeamInviteLink"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TeamInviteLink"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"TeamInviteLink"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TeamInviteLink"> | Date | string
  }

  export type CampaignAuditEventWhereInput = {
    AND?: CampaignAuditEventWhereInput | CampaignAuditEventWhereInput[]
    OR?: CampaignAuditEventWhereInput[]
    NOT?: CampaignAuditEventWhereInput | CampaignAuditEventWhereInput[]
    id?: StringFilter<"CampaignAuditEvent"> | string
    campaignId?: StringFilter<"CampaignAuditEvent"> | string
    actorId?: StringFilter<"CampaignAuditEvent"> | string
    actorRole?: StringFilter<"CampaignAuditEvent"> | string
    eventType?: EnumCampaignAuditEventTypeFilter<"CampaignAuditEvent"> | $Enums.CampaignAuditEventType
    before?: JsonNullableFilter<"CampaignAuditEvent">
    after?: JsonNullableFilter<"CampaignAuditEvent">
    note?: StringNullableFilter<"CampaignAuditEvent"> | string | null
    createdAt?: DateTimeFilter<"CampaignAuditEvent"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    actor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CampaignAuditEventOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    eventType?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    actor?: UserOrderByWithRelationInput
  }

  export type CampaignAuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignAuditEventWhereInput | CampaignAuditEventWhereInput[]
    OR?: CampaignAuditEventWhereInput[]
    NOT?: CampaignAuditEventWhereInput | CampaignAuditEventWhereInput[]
    campaignId?: StringFilter<"CampaignAuditEvent"> | string
    actorId?: StringFilter<"CampaignAuditEvent"> | string
    actorRole?: StringFilter<"CampaignAuditEvent"> | string
    eventType?: EnumCampaignAuditEventTypeFilter<"CampaignAuditEvent"> | $Enums.CampaignAuditEventType
    before?: JsonNullableFilter<"CampaignAuditEvent">
    after?: JsonNullableFilter<"CampaignAuditEvent">
    note?: StringNullableFilter<"CampaignAuditEvent"> | string | null
    createdAt?: DateTimeFilter<"CampaignAuditEvent"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    actor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CampaignAuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    eventType?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignAuditEventCountOrderByAggregateInput
    _max?: CampaignAuditEventMaxOrderByAggregateInput
    _min?: CampaignAuditEventMinOrderByAggregateInput
  }

  export type CampaignAuditEventScalarWhereWithAggregatesInput = {
    AND?: CampaignAuditEventScalarWhereWithAggregatesInput | CampaignAuditEventScalarWhereWithAggregatesInput[]
    OR?: CampaignAuditEventScalarWhereWithAggregatesInput[]
    NOT?: CampaignAuditEventScalarWhereWithAggregatesInput | CampaignAuditEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignAuditEvent"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignAuditEvent"> | string
    actorId?: StringWithAggregatesFilter<"CampaignAuditEvent"> | string
    actorRole?: StringWithAggregatesFilter<"CampaignAuditEvent"> | string
    eventType?: EnumCampaignAuditEventTypeWithAggregatesFilter<"CampaignAuditEvent"> | $Enums.CampaignAuditEventType
    before?: JsonNullableWithAggregatesFilter<"CampaignAuditEvent">
    after?: JsonNullableWithAggregatesFilter<"CampaignAuditEvent">
    note?: StringNullableWithAggregatesFilter<"CampaignAuditEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignAuditEvent"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignParticipationCreateInput = {
    id?: string
    joinedAt?: Date | string
    smartLinkId?: string | null
    user: UserCreateNestedOneWithoutParticipationsInput
    campaign: CampaignCreateNestedOneWithoutParticipationsInput
  }

  export type CampaignParticipationUncheckedCreateInput = {
    id?: string
    userId: string
    campaignId: string
    joinedAt?: Date | string
    smartLinkId?: string | null
  }

  export type CampaignParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutParticipationsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type CampaignParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignParticipationCreateManyInput = {
    id?: string
    userId: string
    campaignId: string
    joinedAt?: Date | string
    smartLinkId?: string | null
  }

  export type CampaignParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SmartLinkCreateInput = {
    id?: string
    slug: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSmartLinksInput
    campaign: CampaignCreateNestedOneWithoutSmartLinksInput
    linkEvents?: LinkEventCreateNestedManyWithoutSmartLinkInput
  }

  export type SmartLinkUncheckedCreateInput = {
    id?: string
    slug: string
    userId: string
    campaignId: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkEvents?: LinkEventUncheckedCreateNestedManyWithoutSmartLinkInput
  }

  export type SmartLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSmartLinksNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutSmartLinksNestedInput
    linkEvents?: LinkEventUpdateManyWithoutSmartLinkNestedInput
  }

  export type SmartLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkEvents?: LinkEventUncheckedUpdateManyWithoutSmartLinkNestedInput
  }

  export type SmartLinkCreateManyInput = {
    id?: string
    slug: string
    userId: string
    campaignId: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SmartLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmartLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkEventCreateInput = {
    id?: string
    smartLinkId?: string | null
    slug?: string | null
    eventType: $Enums.LinkEventType
    type?: $Enums.LinkEventType | null
    userId?: string | null
    ipAddress?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    referer?: string | null
    country?: string | null
    createdAt?: Date | string
    smartLink: SmartLinkCreateNestedOneWithoutLinkEventsInput
  }

  export type LinkEventUncheckedCreateInput = {
    id?: string
    linkId: string
    smartLinkId?: string | null
    slug?: string | null
    eventType: $Enums.LinkEventType
    type?: $Enums.LinkEventType | null
    userId?: string | null
    ipAddress?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    referer?: string | null
    country?: string | null
    createdAt?: Date | string
  }

  export type LinkEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType
    type?: NullableEnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLink?: SmartLinkUpdateOneRequiredWithoutLinkEventsNestedInput
  }

  export type LinkEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType
    type?: NullableEnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkEventCreateManyInput = {
    id?: string
    linkId: string
    smartLinkId?: string | null
    slug?: string | null
    eventType: $Enums.LinkEventType
    type?: $Enums.LinkEventType | null
    userId?: string | null
    ipAddress?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    referer?: string | null
    country?: string | null
    createdAt?: Date | string
  }

  export type LinkEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType
    type?: NullableEnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType
    type?: NullableEnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    inviter: UserCreateNestedOneWithoutReferralsGivenInput
    invitee: UserCreateNestedOneWithoutReferralsReceivedInput
    campaign: CampaignCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    inviterId: string
    inviteeId: string
    campaignId: string
    slug: string
    createdAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutReferralsGivenNestedInput
    invitee?: UserUpdateOneRequiredWithoutReferralsReceivedNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    inviterId: string
    inviteeId: string
    campaignId: string
    slug: string
    createdAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDonationsInput
    campaign: CampaignCreateNestedOneWithoutDonationsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedDonationsInput
  }

  export type DonationUncheckedCreateInput = {
    id?: string
    userId: string
    campaignId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDonationsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutDonationsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedDonationsNestedInput
  }

  export type DonationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateManyInput = {
    id?: string
    userId: string
    campaignId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerEntryCreateInput = {
    id?: string
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPointsLedgerInput
    campaign?: CampaignCreateNestedOneWithoutPointsLedgerInput
  }

  export type PointsLedgerEntryUncheckedCreateInput = {
    id?: string
    userId: string
    campaignId?: string | null
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointsLedgerNestedInput
    campaign?: CampaignUpdateOneWithoutPointsLedgerNestedInput
  }

  export type PointsLedgerEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerEntryCreateManyInput = {
    id?: string
    userId: string
    campaignId?: string | null
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardSnapshotCreateInput = {
    id?: string
    period: string
    rank: number
    score: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
    campaign?: CampaignCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardSnapshotUncheckedCreateInput = {
    id?: string
    userId: string
    campaignId?: string | null
    period: string
    rank: number
    score: number
    createdAt?: Date | string
  }

  export type LeaderboardSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
    campaign?: CampaignUpdateOneWithoutLeaderboardNestedInput
  }

  export type LeaderboardSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardSnapshotCreateManyInput = {
    id?: string
    userId: string
    campaignId?: string | null
    period: string
    rank: number
    score: number
    createdAt?: Date | string
  }

  export type LeaderboardSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreCreateInput = {
    id?: string
    score?: number
    flags?: TrustScoreCreateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: Date | string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTrustScoreRecordInput
  }

  export type TrustScoreUncheckedCreateInput = {
    id?: string
    userId: string
    score?: number
    flags?: TrustScoreCreateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TrustScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    flags?: TrustScoreUpdateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrustScoreRecordNestedInput
  }

  export type TrustScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    flags?: TrustScoreUpdateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreCreateManyInput = {
    id?: string
    userId: string
    score?: number
    flags?: TrustScoreCreateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TrustScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    flags?: TrustScoreUpdateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    flags?: TrustScoreUpdateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppNotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type AppNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    body: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type AppNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type AppNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppNotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    body: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type AppNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofCreateInput = {
    id?: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutViewProofsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedProofsInput
    campaign: CampaignCreateNestedOneWithoutViewProofsInput
  }

  export type ViewProofUncheckedCreateInput = {
    id?: string
    userId: string
    campaignId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewProofUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutViewProofsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedProofsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutViewProofsNestedInput
  }

  export type ViewProofUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofCreateManyInput = {
    id?: string
    userId: string
    campaignId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewProofUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    maxTeams?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    maxTeams?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    maxTeams?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutTeamsInput
    members?: UserCreateNestedManyWithoutTeamInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    groupId: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutTeamInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutTeamsNestedInput
    members?: UserUpdateManyWithoutTeamNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutTeamNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    groupId: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInviteLinkCreateInput = {
    id?: string
    token: string
    targetRole: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamInviteLinksInput
    createdBy: UserCreateNestedOneWithoutTeamInviteLinksInput
  }

  export type TeamInviteLinkUncheckedCreateInput = {
    id?: string
    token: string
    teamId: string
    targetRole: string
    createdById: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TeamInviteLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamInviteLinksNestedInput
    createdBy?: UserUpdateOneRequiredWithoutTeamInviteLinksNestedInput
  }

  export type TeamInviteLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInviteLinkCreateManyInput = {
    id?: string
    token: string
    teamId: string
    targetRole: string
    createdById: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TeamInviteLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInviteLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAuditEventCreateInput = {
    id?: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAuditEventsInput
    actor: UserCreateNestedOneWithoutAuditEventsInput
  }

  export type CampaignAuditEventUncheckedCreateInput = {
    id?: string
    campaignId: string
    actorId: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type CampaignAuditEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAuditEventsNestedInput
    actor?: UserUpdateOneRequiredWithoutAuditEventsNestedInput
  }

  export type CampaignAuditEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAuditEventCreateManyInput = {
    id?: string
    campaignId: string
    actorId: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type CampaignAuditEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAuditEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumSocialPlatformNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel> | null
    has?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    hasSome?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CampaignParticipationListRelationFilter = {
    every?: CampaignParticipationWhereInput
    some?: CampaignParticipationWhereInput
    none?: CampaignParticipationWhereInput
  }

  export type SmartLinkListRelationFilter = {
    every?: SmartLinkWhereInput
    some?: SmartLinkWhereInput
    none?: SmartLinkWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type DonationListRelationFilter = {
    every?: DonationWhereInput
    some?: DonationWhereInput
    none?: DonationWhereInput
  }

  export type PointsLedgerEntryListRelationFilter = {
    every?: PointsLedgerEntryWhereInput
    some?: PointsLedgerEntryWhereInput
    none?: PointsLedgerEntryWhereInput
  }

  export type LeaderboardSnapshotListRelationFilter = {
    every?: LeaderboardSnapshotWhereInput
    some?: LeaderboardSnapshotWhereInput
    none?: LeaderboardSnapshotWhereInput
  }

  export type TrustScoreNullableScalarRelationFilter = {
    is?: TrustScoreWhereInput | null
    isNot?: TrustScoreWhereInput | null
  }

  export type AppNotificationListRelationFilter = {
    every?: AppNotificationWhereInput
    some?: AppNotificationWhereInput
    none?: AppNotificationWhereInput
  }

  export type ViewProofListRelationFilter = {
    every?: ViewProofWhereInput
    some?: ViewProofWhereInput
    none?: ViewProofWhereInput
  }

  export type TeamInviteLinkListRelationFilter = {
    every?: TeamInviteLinkWhereInput
    some?: TeamInviteLinkWhereInput
    none?: TeamInviteLinkWhereInput
  }

  export type CampaignAuditEventListRelationFilter = {
    every?: CampaignAuditEventWhereInput
    some?: CampaignAuditEventWhereInput
    none?: CampaignAuditEventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SmartLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointsLedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewProofOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamInviteLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignAuditEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrder
    whatsappNumber?: SortOrder
    teamId?: SortOrder
    trustScore?: SortOrder
    isActive?: SortOrder
    weaponsOfChoice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    trustScore?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrder
    whatsappNumber?: SortOrder
    teamId?: SortOrder
    trustScore?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrder
    whatsappNumber?: SortOrder
    teamId?: SortOrder
    trustScore?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    trustScore?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumCampaignMediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignMediaType | EnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignMediaTypeNullableFilter<$PrismaModel> | $Enums.CampaignMediaType | null
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type EnumGoalTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGoalTypeNullableFilter<$PrismaModel> | $Enums.GoalType | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CampaignNullableScalarRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    media?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    goalType?: SortOrder
    goalTarget?: SortOrder
    goalCurrent?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    targetAudience?: SortOrder
    publishedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaImage?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    shareCount?: SortOrder
    likeCount?: SortOrder
    participantCount?: SortOrder
    isMegaCampaign?: SortOrder
    parentCampaignId?: SortOrder
    bankAccountIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    goalTarget?: SortOrder
    goalCurrent?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    shareCount?: SortOrder
    likeCount?: SortOrder
    participantCount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    goalType?: SortOrder
    goalTarget?: SortOrder
    goalCurrent?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    publishedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaImage?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    shareCount?: SortOrder
    likeCount?: SortOrder
    participantCount?: SortOrder
    isMegaCampaign?: SortOrder
    parentCampaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    createdById?: SortOrder
    status?: SortOrder
    goalType?: SortOrder
    goalTarget?: SortOrder
    goalCurrent?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    publishedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaImage?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    shareCount?: SortOrder
    likeCount?: SortOrder
    participantCount?: SortOrder
    isMegaCampaign?: SortOrder
    parentCampaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    goalTarget?: SortOrder
    goalCurrent?: SortOrder
    viewCount?: SortOrder
    clickCount?: SortOrder
    shareCount?: SortOrder
    likeCount?: SortOrder
    participantCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumCampaignMediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignMediaType | EnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignMediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CampaignMediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCampaignMediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCampaignMediaTypeNullableFilter<$PrismaModel>
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type EnumGoalTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGoalTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.GoalType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGoalTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumGoalTypeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignParticipationUserIdCampaignIdCompoundUniqueInput = {
    userId: string
    campaignId: string
  }

  export type CampaignParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    joinedAt?: SortOrder
    smartLinkId?: SortOrder
  }

  export type CampaignParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    joinedAt?: SortOrder
    smartLinkId?: SortOrder
  }

  export type CampaignParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    joinedAt?: SortOrder
    smartLinkId?: SortOrder
  }

  export type LinkEventListRelationFilter = {
    every?: LinkEventWhereInput
    some?: LinkEventWhereInput
    none?: LinkEventWhereInput
  }

  export type LinkEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SmartLinkUserIdCampaignIdCompoundUniqueInput = {
    userId: string
    campaignId: string
  }

  export type SmartLinkCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    uniqueClickCount?: SortOrder
    conversionCount?: SortOrder
    isActive?: SortOrder
    isExpired?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SmartLinkAvgOrderByAggregateInput = {
    clickCount?: SortOrder
    uniqueClickCount?: SortOrder
    conversionCount?: SortOrder
  }

  export type SmartLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    uniqueClickCount?: SortOrder
    conversionCount?: SortOrder
    isActive?: SortOrder
    isExpired?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SmartLinkMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    uniqueClickCount?: SortOrder
    conversionCount?: SortOrder
    isActive?: SortOrder
    isExpired?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SmartLinkSumOrderByAggregateInput = {
    clickCount?: SortOrder
    uniqueClickCount?: SortOrder
    conversionCount?: SortOrder
  }

  export type EnumLinkEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLinkEventTypeFilter<$PrismaModel> | $Enums.LinkEventType
  }

  export type EnumLinkEventTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLinkEventTypeNullableFilter<$PrismaModel> | $Enums.LinkEventType | null
  }

  export type SmartLinkScalarRelationFilter = {
    is?: SmartLinkWhereInput
    isNot?: SmartLinkWhereInput
  }

  export type LinkEventCountOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    smartLinkId?: SortOrder
    slug?: SortOrder
    eventType?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    referer?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
  }

  export type LinkEventMaxOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    smartLinkId?: SortOrder
    slug?: SortOrder
    eventType?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    referer?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
  }

  export type LinkEventMinOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    smartLinkId?: SortOrder
    slug?: SortOrder
    eventType?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    referer?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLinkEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLinkEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.LinkEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLinkEventTypeFilter<$PrismaModel>
    _max?: NestedEnumLinkEventTypeFilter<$PrismaModel>
  }

  export type EnumLinkEventTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLinkEventTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.LinkEventType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLinkEventTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumLinkEventTypeNullableFilter<$PrismaModel>
  }

  export type ReferralInviteeIdSlugCompoundUniqueInput = {
    inviteeId: string
    slug: string
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    campaignId?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    campaignId?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    inviteeId?: SortOrder
    campaignId?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumDonationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DonationStatus | EnumDonationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDonationStatusFilter<$PrismaModel> | $Enums.DonationStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DonationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    bankAccountId?: SortOrder
    proofScreenshotUrl?: SortOrder
    verifiedById?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DonationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    bankAccountId?: SortOrder
    proofScreenshotUrl?: SortOrder
    verifiedById?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    bankAccountId?: SortOrder
    proofScreenshotUrl?: SortOrder
    verifiedById?: SortOrder
    verifiedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumDonationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DonationStatus | EnumDonationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDonationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DonationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDonationStatusFilter<$PrismaModel>
    _max?: NestedEnumDonationStatusFilter<$PrismaModel>
  }

  export type EnumPointTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointTypeFilter<$PrismaModel> | $Enums.PointType
  }

  export type PointsLedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsLedgerEntryAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PointsLedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsLedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
  }

  export type PointsLedgerEntrySumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumPointTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointTypeWithAggregatesFilter<$PrismaModel> | $Enums.PointType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPointTypeFilter<$PrismaModel>
    _max?: NestedEnumPointTypeFilter<$PrismaModel>
  }

  export type LeaderboardSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaderboardSnapshotAvgOrderByAggregateInput = {
    rank?: SortOrder
    score?: SortOrder
  }

  export type LeaderboardSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaderboardSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    period?: SortOrder
    rank?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaderboardSnapshotSumOrderByAggregateInput = {
    rank?: SortOrder
    score?: SortOrder
  }

  export type EnumTrustFlagNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.TrustFlag[] | ListEnumTrustFlagFieldRefInput<$PrismaModel> | null
    has?: $Enums.TrustFlag | EnumTrustFlagFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.TrustFlag[] | ListEnumTrustFlagFieldRefInput<$PrismaModel>
    hasSome?: $Enums.TrustFlag[] | ListEnumTrustFlagFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TrustScoreCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    flags?: SortOrder
    lastReviewedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrustScoreAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type TrustScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    lastReviewedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrustScoreMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    lastReviewedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrustScoreSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type AppNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type AppNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type AppNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumSocialPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformFilter<$PrismaModel> | $Enums.SocialPlatform
  }

  export type EnumViewProofStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewProofStatus | EnumViewProofStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumViewProofStatusFilter<$PrismaModel> | $Enums.ViewProofStatus
  }

  export type ViewProofCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    smartLinkId?: SortOrder
    platform?: SortOrder
    screenshotUrl?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViewProofMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    smartLinkId?: SortOrder
    platform?: SortOrder
    screenshotUrl?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViewProofMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    smartLinkId?: SortOrder
    platform?: SortOrder
    screenshotUrl?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSocialPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SocialPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialPlatformFilter<$PrismaModel>
    _max?: NestedEnumSocialPlatformFilter<$PrismaModel>
  }

  export type EnumViewProofStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewProofStatus | EnumViewProofStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumViewProofStatusWithAggregatesFilter<$PrismaModel> | $Enums.ViewProofStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumViewProofStatusFilter<$PrismaModel>
    _max?: NestedEnumViewProofStatusFilter<$PrismaModel>
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxTeams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    maxTeams?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxTeams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxTeams?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    maxTeams?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    teamLeadId?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    teamLeadId?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    teamLeadId?: SortOrder
    maxMembers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamInviteLinkCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    teamId?: SortOrder
    targetRole?: SortOrder
    createdById?: SortOrder
    usedCount?: SortOrder
    maxUses?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamInviteLinkAvgOrderByAggregateInput = {
    usedCount?: SortOrder
    maxUses?: SortOrder
  }

  export type TeamInviteLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    teamId?: SortOrder
    targetRole?: SortOrder
    createdById?: SortOrder
    usedCount?: SortOrder
    maxUses?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamInviteLinkMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    teamId?: SortOrder
    targetRole?: SortOrder
    createdById?: SortOrder
    usedCount?: SortOrder
    maxUses?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamInviteLinkSumOrderByAggregateInput = {
    usedCount?: SortOrder
    maxUses?: SortOrder
  }

  export type EnumCampaignAuditEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignAuditEventType | EnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignAuditEventTypeFilter<$PrismaModel> | $Enums.CampaignAuditEventType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CampaignAuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    eventType?: SortOrder
    before?: SortOrder
    after?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    eventType?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    eventType?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCampaignAuditEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignAuditEventType | EnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignAuditEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignAuditEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignAuditEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignAuditEventTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserCreateweaponsOfChoiceInput = {
    set: $Enums.SocialPlatform[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignParticipationCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignParticipationCreateWithoutUserInput, CampaignParticipationUncheckedCreateWithoutUserInput> | CampaignParticipationCreateWithoutUserInput[] | CampaignParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutUserInput | CampaignParticipationCreateOrConnectWithoutUserInput[]
    createMany?: CampaignParticipationCreateManyUserInputEnvelope
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
  }

  export type SmartLinkCreateNestedManyWithoutUserInput = {
    create?: XOR<SmartLinkCreateWithoutUserInput, SmartLinkUncheckedCreateWithoutUserInput> | SmartLinkCreateWithoutUserInput[] | SmartLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutUserInput | SmartLinkCreateOrConnectWithoutUserInput[]
    createMany?: SmartLinkCreateManyUserInputEnvelope
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutInviterInput = {
    create?: XOR<ReferralCreateWithoutInviterInput, ReferralUncheckedCreateWithoutInviterInput> | ReferralCreateWithoutInviterInput[] | ReferralUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviterInput | ReferralCreateOrConnectWithoutInviterInput[]
    createMany?: ReferralCreateManyInviterInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutInviteeInput = {
    create?: XOR<ReferralCreateWithoutInviteeInput, ReferralUncheckedCreateWithoutInviteeInput> | ReferralCreateWithoutInviteeInput[] | ReferralUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviteeInput | ReferralCreateOrConnectWithoutInviteeInput[]
    createMany?: ReferralCreateManyInviteeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type DonationCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type DonationCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<DonationCreateWithoutVerifiedByInput, DonationUncheckedCreateWithoutVerifiedByInput> | DonationCreateWithoutVerifiedByInput[] | DonationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutVerifiedByInput | DonationCreateOrConnectWithoutVerifiedByInput[]
    createMany?: DonationCreateManyVerifiedByInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PointsLedgerEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutUserInput, PointsLedgerEntryUncheckedCreateWithoutUserInput> | PointsLedgerEntryCreateWithoutUserInput[] | PointsLedgerEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutUserInput | PointsLedgerEntryCreateOrConnectWithoutUserInput[]
    createMany?: PointsLedgerEntryCreateManyUserInputEnvelope
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
  }

  export type LeaderboardSnapshotCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutUserInput, LeaderboardSnapshotUncheckedCreateWithoutUserInput> | LeaderboardSnapshotCreateWithoutUserInput[] | LeaderboardSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutUserInput | LeaderboardSnapshotCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardSnapshotCreateManyUserInputEnvelope
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
  }

  export type TrustScoreCreateNestedOneWithoutUserInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    connect?: TrustScoreWhereUniqueInput
  }

  export type AppNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<AppNotificationCreateWithoutUserInput, AppNotificationUncheckedCreateWithoutUserInput> | AppNotificationCreateWithoutUserInput[] | AppNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppNotificationCreateOrConnectWithoutUserInput | AppNotificationCreateOrConnectWithoutUserInput[]
    createMany?: AppNotificationCreateManyUserInputEnvelope
    connect?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
  }

  export type ViewProofCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewProofCreateWithoutUserInput, ViewProofUncheckedCreateWithoutUserInput> | ViewProofCreateWithoutUserInput[] | ViewProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutUserInput | ViewProofCreateOrConnectWithoutUserInput[]
    createMany?: ViewProofCreateManyUserInputEnvelope
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
  }

  export type ViewProofCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<ViewProofCreateWithoutReviewedByInput, ViewProofUncheckedCreateWithoutReviewedByInput> | ViewProofCreateWithoutReviewedByInput[] | ViewProofUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutReviewedByInput | ViewProofCreateOrConnectWithoutReviewedByInput[]
    createMany?: ViewProofCreateManyReviewedByInputEnvelope
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
  }

  export type TeamInviteLinkCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamInviteLinkCreateWithoutCreatedByInput, TeamInviteLinkUncheckedCreateWithoutCreatedByInput> | TeamInviteLinkCreateWithoutCreatedByInput[] | TeamInviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutCreatedByInput | TeamInviteLinkCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamInviteLinkCreateManyCreatedByInputEnvelope
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
  }

  export type CampaignAuditEventCreateNestedManyWithoutActorInput = {
    create?: XOR<CampaignAuditEventCreateWithoutActorInput, CampaignAuditEventUncheckedCreateWithoutActorInput> | CampaignAuditEventCreateWithoutActorInput[] | CampaignAuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutActorInput | CampaignAuditEventCreateOrConnectWithoutActorInput[]
    createMany?: CampaignAuditEventCreateManyActorInputEnvelope
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignParticipationCreateWithoutUserInput, CampaignParticipationUncheckedCreateWithoutUserInput> | CampaignParticipationCreateWithoutUserInput[] | CampaignParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutUserInput | CampaignParticipationCreateOrConnectWithoutUserInput[]
    createMany?: CampaignParticipationCreateManyUserInputEnvelope
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
  }

  export type SmartLinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SmartLinkCreateWithoutUserInput, SmartLinkUncheckedCreateWithoutUserInput> | SmartLinkCreateWithoutUserInput[] | SmartLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutUserInput | SmartLinkCreateOrConnectWithoutUserInput[]
    createMany?: SmartLinkCreateManyUserInputEnvelope
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<ReferralCreateWithoutInviterInput, ReferralUncheckedCreateWithoutInviterInput> | ReferralCreateWithoutInviterInput[] | ReferralUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviterInput | ReferralCreateOrConnectWithoutInviterInput[]
    createMany?: ReferralCreateManyInviterInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutInviteeInput = {
    create?: XOR<ReferralCreateWithoutInviteeInput, ReferralUncheckedCreateWithoutInviteeInput> | ReferralCreateWithoutInviteeInput[] | ReferralUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviteeInput | ReferralCreateOrConnectWithoutInviteeInput[]
    createMany?: ReferralCreateManyInviteeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<DonationCreateWithoutVerifiedByInput, DonationUncheckedCreateWithoutVerifiedByInput> | DonationCreateWithoutVerifiedByInput[] | DonationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutVerifiedByInput | DonationCreateOrConnectWithoutVerifiedByInput[]
    createMany?: DonationCreateManyVerifiedByInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutUserInput, PointsLedgerEntryUncheckedCreateWithoutUserInput> | PointsLedgerEntryCreateWithoutUserInput[] | PointsLedgerEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutUserInput | PointsLedgerEntryCreateOrConnectWithoutUserInput[]
    createMany?: PointsLedgerEntryCreateManyUserInputEnvelope
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
  }

  export type LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutUserInput, LeaderboardSnapshotUncheckedCreateWithoutUserInput> | LeaderboardSnapshotCreateWithoutUserInput[] | LeaderboardSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutUserInput | LeaderboardSnapshotCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardSnapshotCreateManyUserInputEnvelope
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
  }

  export type TrustScoreUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    connect?: TrustScoreWhereUniqueInput
  }

  export type AppNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AppNotificationCreateWithoutUserInput, AppNotificationUncheckedCreateWithoutUserInput> | AppNotificationCreateWithoutUserInput[] | AppNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppNotificationCreateOrConnectWithoutUserInput | AppNotificationCreateOrConnectWithoutUserInput[]
    createMany?: AppNotificationCreateManyUserInputEnvelope
    connect?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
  }

  export type ViewProofUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewProofCreateWithoutUserInput, ViewProofUncheckedCreateWithoutUserInput> | ViewProofCreateWithoutUserInput[] | ViewProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutUserInput | ViewProofCreateOrConnectWithoutUserInput[]
    createMany?: ViewProofCreateManyUserInputEnvelope
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
  }

  export type ViewProofUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<ViewProofCreateWithoutReviewedByInput, ViewProofUncheckedCreateWithoutReviewedByInput> | ViewProofCreateWithoutReviewedByInput[] | ViewProofUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutReviewedByInput | ViewProofCreateOrConnectWithoutReviewedByInput[]
    createMany?: ViewProofCreateManyReviewedByInputEnvelope
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
  }

  export type TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamInviteLinkCreateWithoutCreatedByInput, TeamInviteLinkUncheckedCreateWithoutCreatedByInput> | TeamInviteLinkCreateWithoutCreatedByInput[] | TeamInviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutCreatedByInput | TeamInviteLinkCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamInviteLinkCreateManyCreatedByInputEnvelope
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
  }

  export type CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<CampaignAuditEventCreateWithoutActorInput, CampaignAuditEventUncheckedCreateWithoutActorInput> | CampaignAuditEventCreateWithoutActorInput[] | CampaignAuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutActorInput | CampaignAuditEventCreateOrConnectWithoutActorInput[]
    createMany?: CampaignAuditEventCreateManyActorInputEnvelope
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateweaponsOfChoiceInput = {
    set?: $Enums.SocialPlatform[]
    push?: $Enums.SocialPlatform | $Enums.SocialPlatform[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TeamUpdateOneWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type CampaignUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatorInput | CampaignUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatorInput | CampaignUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatorInput | CampaignUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignParticipationUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignParticipationCreateWithoutUserInput, CampaignParticipationUncheckedCreateWithoutUserInput> | CampaignParticipationCreateWithoutUserInput[] | CampaignParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutUserInput | CampaignParticipationCreateOrConnectWithoutUserInput[]
    upsert?: CampaignParticipationUpsertWithWhereUniqueWithoutUserInput | CampaignParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignParticipationCreateManyUserInputEnvelope
    set?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    disconnect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    delete?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    update?: CampaignParticipationUpdateWithWhereUniqueWithoutUserInput | CampaignParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignParticipationUpdateManyWithWhereWithoutUserInput | CampaignParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignParticipationScalarWhereInput | CampaignParticipationScalarWhereInput[]
  }

  export type SmartLinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<SmartLinkCreateWithoutUserInput, SmartLinkUncheckedCreateWithoutUserInput> | SmartLinkCreateWithoutUserInput[] | SmartLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutUserInput | SmartLinkCreateOrConnectWithoutUserInput[]
    upsert?: SmartLinkUpsertWithWhereUniqueWithoutUserInput | SmartLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SmartLinkCreateManyUserInputEnvelope
    set?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    disconnect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    delete?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    update?: SmartLinkUpdateWithWhereUniqueWithoutUserInput | SmartLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SmartLinkUpdateManyWithWhereWithoutUserInput | SmartLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SmartLinkScalarWhereInput | SmartLinkScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutInviterNestedInput = {
    create?: XOR<ReferralCreateWithoutInviterInput, ReferralUncheckedCreateWithoutInviterInput> | ReferralCreateWithoutInviterInput[] | ReferralUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviterInput | ReferralCreateOrConnectWithoutInviterInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutInviterInput | ReferralUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: ReferralCreateManyInviterInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutInviterInput | ReferralUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutInviterInput | ReferralUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutInviteeNestedInput = {
    create?: XOR<ReferralCreateWithoutInviteeInput, ReferralUncheckedCreateWithoutInviteeInput> | ReferralCreateWithoutInviteeInput[] | ReferralUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviteeInput | ReferralCreateOrConnectWithoutInviteeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutInviteeInput | ReferralUpsertWithWhereUniqueWithoutInviteeInput[]
    createMany?: ReferralCreateManyInviteeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutInviteeInput | ReferralUpdateWithWhereUniqueWithoutInviteeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutInviteeInput | ReferralUpdateManyWithWhereWithoutInviteeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type DonationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type DonationUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<DonationCreateWithoutVerifiedByInput, DonationUncheckedCreateWithoutVerifiedByInput> | DonationCreateWithoutVerifiedByInput[] | DonationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutVerifiedByInput | DonationCreateOrConnectWithoutVerifiedByInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutVerifiedByInput | DonationUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: DonationCreateManyVerifiedByInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutVerifiedByInput | DonationUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutVerifiedByInput | DonationUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PointsLedgerEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutUserInput, PointsLedgerEntryUncheckedCreateWithoutUserInput> | PointsLedgerEntryCreateWithoutUserInput[] | PointsLedgerEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutUserInput | PointsLedgerEntryCreateOrConnectWithoutUserInput[]
    upsert?: PointsLedgerEntryUpsertWithWhereUniqueWithoutUserInput | PointsLedgerEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointsLedgerEntryCreateManyUserInputEnvelope
    set?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    disconnect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    delete?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    update?: PointsLedgerEntryUpdateWithWhereUniqueWithoutUserInput | PointsLedgerEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointsLedgerEntryUpdateManyWithWhereWithoutUserInput | PointsLedgerEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointsLedgerEntryScalarWhereInput | PointsLedgerEntryScalarWhereInput[]
  }

  export type LeaderboardSnapshotUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutUserInput, LeaderboardSnapshotUncheckedCreateWithoutUserInput> | LeaderboardSnapshotCreateWithoutUserInput[] | LeaderboardSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutUserInput | LeaderboardSnapshotCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardSnapshotUpsertWithWhereUniqueWithoutUserInput | LeaderboardSnapshotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardSnapshotCreateManyUserInputEnvelope
    set?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    disconnect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    delete?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    update?: LeaderboardSnapshotUpdateWithWhereUniqueWithoutUserInput | LeaderboardSnapshotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardSnapshotUpdateManyWithWhereWithoutUserInput | LeaderboardSnapshotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardSnapshotScalarWhereInput | LeaderboardSnapshotScalarWhereInput[]
  }

  export type TrustScoreUpdateOneWithoutUserNestedInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    upsert?: TrustScoreUpsertWithoutUserInput
    disconnect?: TrustScoreWhereInput | boolean
    delete?: TrustScoreWhereInput | boolean
    connect?: TrustScoreWhereUniqueInput
    update?: XOR<XOR<TrustScoreUpdateToOneWithWhereWithoutUserInput, TrustScoreUpdateWithoutUserInput>, TrustScoreUncheckedUpdateWithoutUserInput>
  }

  export type AppNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppNotificationCreateWithoutUserInput, AppNotificationUncheckedCreateWithoutUserInput> | AppNotificationCreateWithoutUserInput[] | AppNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppNotificationCreateOrConnectWithoutUserInput | AppNotificationCreateOrConnectWithoutUserInput[]
    upsert?: AppNotificationUpsertWithWhereUniqueWithoutUserInput | AppNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppNotificationCreateManyUserInputEnvelope
    set?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    disconnect?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    delete?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    connect?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    update?: AppNotificationUpdateWithWhereUniqueWithoutUserInput | AppNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppNotificationUpdateManyWithWhereWithoutUserInput | AppNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppNotificationScalarWhereInput | AppNotificationScalarWhereInput[]
  }

  export type ViewProofUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewProofCreateWithoutUserInput, ViewProofUncheckedCreateWithoutUserInput> | ViewProofCreateWithoutUserInput[] | ViewProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutUserInput | ViewProofCreateOrConnectWithoutUserInput[]
    upsert?: ViewProofUpsertWithWhereUniqueWithoutUserInput | ViewProofUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewProofCreateManyUserInputEnvelope
    set?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    disconnect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    delete?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    update?: ViewProofUpdateWithWhereUniqueWithoutUserInput | ViewProofUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewProofUpdateManyWithWhereWithoutUserInput | ViewProofUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
  }

  export type ViewProofUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<ViewProofCreateWithoutReviewedByInput, ViewProofUncheckedCreateWithoutReviewedByInput> | ViewProofCreateWithoutReviewedByInput[] | ViewProofUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutReviewedByInput | ViewProofCreateOrConnectWithoutReviewedByInput[]
    upsert?: ViewProofUpsertWithWhereUniqueWithoutReviewedByInput | ViewProofUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: ViewProofCreateManyReviewedByInputEnvelope
    set?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    disconnect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    delete?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    update?: ViewProofUpdateWithWhereUniqueWithoutReviewedByInput | ViewProofUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: ViewProofUpdateManyWithWhereWithoutReviewedByInput | ViewProofUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
  }

  export type TeamInviteLinkUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamInviteLinkCreateWithoutCreatedByInput, TeamInviteLinkUncheckedCreateWithoutCreatedByInput> | TeamInviteLinkCreateWithoutCreatedByInput[] | TeamInviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutCreatedByInput | TeamInviteLinkCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamInviteLinkUpsertWithWhereUniqueWithoutCreatedByInput | TeamInviteLinkUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamInviteLinkCreateManyCreatedByInputEnvelope
    set?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    disconnect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    delete?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    update?: TeamInviteLinkUpdateWithWhereUniqueWithoutCreatedByInput | TeamInviteLinkUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamInviteLinkUpdateManyWithWhereWithoutCreatedByInput | TeamInviteLinkUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamInviteLinkScalarWhereInput | TeamInviteLinkScalarWhereInput[]
  }

  export type CampaignAuditEventUpdateManyWithoutActorNestedInput = {
    create?: XOR<CampaignAuditEventCreateWithoutActorInput, CampaignAuditEventUncheckedCreateWithoutActorInput> | CampaignAuditEventCreateWithoutActorInput[] | CampaignAuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutActorInput | CampaignAuditEventCreateOrConnectWithoutActorInput[]
    upsert?: CampaignAuditEventUpsertWithWhereUniqueWithoutActorInput | CampaignAuditEventUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CampaignAuditEventCreateManyActorInputEnvelope
    set?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    disconnect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    delete?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    update?: CampaignAuditEventUpdateWithWhereUniqueWithoutActorInput | CampaignAuditEventUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CampaignAuditEventUpdateManyWithWhereWithoutActorInput | CampaignAuditEventUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CampaignAuditEventScalarWhereInput | CampaignAuditEventScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput> | CampaignCreateWithoutCreatorInput[] | CampaignUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatorInput | CampaignCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatorInput | CampaignUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignCreateManyCreatorInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatorInput | CampaignUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatorInput | CampaignUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignParticipationCreateWithoutUserInput, CampaignParticipationUncheckedCreateWithoutUserInput> | CampaignParticipationCreateWithoutUserInput[] | CampaignParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutUserInput | CampaignParticipationCreateOrConnectWithoutUserInput[]
    upsert?: CampaignParticipationUpsertWithWhereUniqueWithoutUserInput | CampaignParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignParticipationCreateManyUserInputEnvelope
    set?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    disconnect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    delete?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    update?: CampaignParticipationUpdateWithWhereUniqueWithoutUserInput | CampaignParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignParticipationUpdateManyWithWhereWithoutUserInput | CampaignParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignParticipationScalarWhereInput | CampaignParticipationScalarWhereInput[]
  }

  export type SmartLinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SmartLinkCreateWithoutUserInput, SmartLinkUncheckedCreateWithoutUserInput> | SmartLinkCreateWithoutUserInput[] | SmartLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutUserInput | SmartLinkCreateOrConnectWithoutUserInput[]
    upsert?: SmartLinkUpsertWithWhereUniqueWithoutUserInput | SmartLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SmartLinkCreateManyUserInputEnvelope
    set?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    disconnect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    delete?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    update?: SmartLinkUpdateWithWhereUniqueWithoutUserInput | SmartLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SmartLinkUpdateManyWithWhereWithoutUserInput | SmartLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SmartLinkScalarWhereInput | SmartLinkScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<ReferralCreateWithoutInviterInput, ReferralUncheckedCreateWithoutInviterInput> | ReferralCreateWithoutInviterInput[] | ReferralUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviterInput | ReferralCreateOrConnectWithoutInviterInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutInviterInput | ReferralUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: ReferralCreateManyInviterInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutInviterInput | ReferralUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutInviterInput | ReferralUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutInviteeNestedInput = {
    create?: XOR<ReferralCreateWithoutInviteeInput, ReferralUncheckedCreateWithoutInviteeInput> | ReferralCreateWithoutInviteeInput[] | ReferralUncheckedCreateWithoutInviteeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutInviteeInput | ReferralCreateOrConnectWithoutInviteeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutInviteeInput | ReferralUpsertWithWhereUniqueWithoutInviteeInput[]
    createMany?: ReferralCreateManyInviteeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutInviteeInput | ReferralUpdateWithWhereUniqueWithoutInviteeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutInviteeInput | ReferralUpdateManyWithWhereWithoutInviteeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<DonationCreateWithoutVerifiedByInput, DonationUncheckedCreateWithoutVerifiedByInput> | DonationCreateWithoutVerifiedByInput[] | DonationUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutVerifiedByInput | DonationCreateOrConnectWithoutVerifiedByInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutVerifiedByInput | DonationUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: DonationCreateManyVerifiedByInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutVerifiedByInput | DonationUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutVerifiedByInput | DonationUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutUserInput, PointsLedgerEntryUncheckedCreateWithoutUserInput> | PointsLedgerEntryCreateWithoutUserInput[] | PointsLedgerEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutUserInput | PointsLedgerEntryCreateOrConnectWithoutUserInput[]
    upsert?: PointsLedgerEntryUpsertWithWhereUniqueWithoutUserInput | PointsLedgerEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointsLedgerEntryCreateManyUserInputEnvelope
    set?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    disconnect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    delete?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    update?: PointsLedgerEntryUpdateWithWhereUniqueWithoutUserInput | PointsLedgerEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointsLedgerEntryUpdateManyWithWhereWithoutUserInput | PointsLedgerEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointsLedgerEntryScalarWhereInput | PointsLedgerEntryScalarWhereInput[]
  }

  export type LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutUserInput, LeaderboardSnapshotUncheckedCreateWithoutUserInput> | LeaderboardSnapshotCreateWithoutUserInput[] | LeaderboardSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutUserInput | LeaderboardSnapshotCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardSnapshotUpsertWithWhereUniqueWithoutUserInput | LeaderboardSnapshotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardSnapshotCreateManyUserInputEnvelope
    set?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    disconnect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    delete?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    update?: LeaderboardSnapshotUpdateWithWhereUniqueWithoutUserInput | LeaderboardSnapshotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardSnapshotUpdateManyWithWhereWithoutUserInput | LeaderboardSnapshotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardSnapshotScalarWhereInput | LeaderboardSnapshotScalarWhereInput[]
  }

  export type TrustScoreUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    upsert?: TrustScoreUpsertWithoutUserInput
    disconnect?: TrustScoreWhereInput | boolean
    delete?: TrustScoreWhereInput | boolean
    connect?: TrustScoreWhereUniqueInput
    update?: XOR<XOR<TrustScoreUpdateToOneWithWhereWithoutUserInput, TrustScoreUpdateWithoutUserInput>, TrustScoreUncheckedUpdateWithoutUserInput>
  }

  export type AppNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppNotificationCreateWithoutUserInput, AppNotificationUncheckedCreateWithoutUserInput> | AppNotificationCreateWithoutUserInput[] | AppNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppNotificationCreateOrConnectWithoutUserInput | AppNotificationCreateOrConnectWithoutUserInput[]
    upsert?: AppNotificationUpsertWithWhereUniqueWithoutUserInput | AppNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppNotificationCreateManyUserInputEnvelope
    set?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    disconnect?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    delete?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    connect?: AppNotificationWhereUniqueInput | AppNotificationWhereUniqueInput[]
    update?: AppNotificationUpdateWithWhereUniqueWithoutUserInput | AppNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppNotificationUpdateManyWithWhereWithoutUserInput | AppNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppNotificationScalarWhereInput | AppNotificationScalarWhereInput[]
  }

  export type ViewProofUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewProofCreateWithoutUserInput, ViewProofUncheckedCreateWithoutUserInput> | ViewProofCreateWithoutUserInput[] | ViewProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutUserInput | ViewProofCreateOrConnectWithoutUserInput[]
    upsert?: ViewProofUpsertWithWhereUniqueWithoutUserInput | ViewProofUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewProofCreateManyUserInputEnvelope
    set?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    disconnect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    delete?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    update?: ViewProofUpdateWithWhereUniqueWithoutUserInput | ViewProofUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewProofUpdateManyWithWhereWithoutUserInput | ViewProofUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
  }

  export type ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<ViewProofCreateWithoutReviewedByInput, ViewProofUncheckedCreateWithoutReviewedByInput> | ViewProofCreateWithoutReviewedByInput[] | ViewProofUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutReviewedByInput | ViewProofCreateOrConnectWithoutReviewedByInput[]
    upsert?: ViewProofUpsertWithWhereUniqueWithoutReviewedByInput | ViewProofUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: ViewProofCreateManyReviewedByInputEnvelope
    set?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    disconnect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    delete?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    update?: ViewProofUpdateWithWhereUniqueWithoutReviewedByInput | ViewProofUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: ViewProofUpdateManyWithWhereWithoutReviewedByInput | ViewProofUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
  }

  export type TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamInviteLinkCreateWithoutCreatedByInput, TeamInviteLinkUncheckedCreateWithoutCreatedByInput> | TeamInviteLinkCreateWithoutCreatedByInput[] | TeamInviteLinkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutCreatedByInput | TeamInviteLinkCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamInviteLinkUpsertWithWhereUniqueWithoutCreatedByInput | TeamInviteLinkUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamInviteLinkCreateManyCreatedByInputEnvelope
    set?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    disconnect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    delete?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    update?: TeamInviteLinkUpdateWithWhereUniqueWithoutCreatedByInput | TeamInviteLinkUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamInviteLinkUpdateManyWithWhereWithoutCreatedByInput | TeamInviteLinkUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamInviteLinkScalarWhereInput | TeamInviteLinkScalarWhereInput[]
  }

  export type CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<CampaignAuditEventCreateWithoutActorInput, CampaignAuditEventUncheckedCreateWithoutActorInput> | CampaignAuditEventCreateWithoutActorInput[] | CampaignAuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutActorInput | CampaignAuditEventCreateOrConnectWithoutActorInput[]
    upsert?: CampaignAuditEventUpsertWithWhereUniqueWithoutActorInput | CampaignAuditEventUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: CampaignAuditEventCreateManyActorInputEnvelope
    set?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    disconnect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    delete?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    update?: CampaignAuditEventUpdateWithWhereUniqueWithoutActorInput | CampaignAuditEventUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: CampaignAuditEventUpdateManyWithWhereWithoutActorInput | CampaignAuditEventUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: CampaignAuditEventScalarWhereInput | CampaignAuditEventScalarWhereInput[]
  }

  export type CampaignCreatetargetAudienceInput = {
    set: string[]
  }

  export type CampaignCreatebankAccountIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCreatedCampaignsInput = {
    create?: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutSubCampaignsInput = {
    create?: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSubCampaignsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutParentCampaignInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignParticipationCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignParticipationCreateWithoutCampaignInput, CampaignParticipationUncheckedCreateWithoutCampaignInput> | CampaignParticipationCreateWithoutCampaignInput[] | CampaignParticipationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutCampaignInput | CampaignParticipationCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignParticipationCreateManyCampaignInputEnvelope
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
  }

  export type SmartLinkCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SmartLinkCreateWithoutCampaignInput, SmartLinkUncheckedCreateWithoutCampaignInput> | SmartLinkCreateWithoutCampaignInput[] | SmartLinkUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutCampaignInput | SmartLinkCreateOrConnectWithoutCampaignInput[]
    createMany?: SmartLinkCreateManyCampaignInputEnvelope
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ReferralCreateWithoutCampaignInput, ReferralUncheckedCreateWithoutCampaignInput> | ReferralCreateWithoutCampaignInput[] | ReferralUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutCampaignInput | ReferralCreateOrConnectWithoutCampaignInput[]
    createMany?: ReferralCreateManyCampaignInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type DonationCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DonationCreateWithoutCampaignInput, DonationUncheckedCreateWithoutCampaignInput> | DonationCreateWithoutCampaignInput[] | DonationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutCampaignInput | DonationCreateOrConnectWithoutCampaignInput[]
    createMany?: DonationCreateManyCampaignInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PointsLedgerEntryCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutCampaignInput, PointsLedgerEntryUncheckedCreateWithoutCampaignInput> | PointsLedgerEntryCreateWithoutCampaignInput[] | PointsLedgerEntryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutCampaignInput | PointsLedgerEntryCreateOrConnectWithoutCampaignInput[]
    createMany?: PointsLedgerEntryCreateManyCampaignInputEnvelope
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
  }

  export type LeaderboardSnapshotCreateNestedManyWithoutCampaignInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutCampaignInput, LeaderboardSnapshotUncheckedCreateWithoutCampaignInput> | LeaderboardSnapshotCreateWithoutCampaignInput[] | LeaderboardSnapshotUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutCampaignInput | LeaderboardSnapshotCreateOrConnectWithoutCampaignInput[]
    createMany?: LeaderboardSnapshotCreateManyCampaignInputEnvelope
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
  }

  export type ViewProofCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ViewProofCreateWithoutCampaignInput, ViewProofUncheckedCreateWithoutCampaignInput> | ViewProofCreateWithoutCampaignInput[] | ViewProofUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutCampaignInput | ViewProofCreateOrConnectWithoutCampaignInput[]
    createMany?: ViewProofCreateManyCampaignInputEnvelope
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
  }

  export type CampaignAuditEventCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignAuditEventCreateWithoutCampaignInput, CampaignAuditEventUncheckedCreateWithoutCampaignInput> | CampaignAuditEventCreateWithoutCampaignInput[] | CampaignAuditEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutCampaignInput | CampaignAuditEventCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignAuditEventCreateManyCampaignInputEnvelope
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutParentCampaignInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignParticipationCreateWithoutCampaignInput, CampaignParticipationUncheckedCreateWithoutCampaignInput> | CampaignParticipationCreateWithoutCampaignInput[] | CampaignParticipationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutCampaignInput | CampaignParticipationCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignParticipationCreateManyCampaignInputEnvelope
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
  }

  export type SmartLinkUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SmartLinkCreateWithoutCampaignInput, SmartLinkUncheckedCreateWithoutCampaignInput> | SmartLinkCreateWithoutCampaignInput[] | SmartLinkUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutCampaignInput | SmartLinkCreateOrConnectWithoutCampaignInput[]
    createMany?: SmartLinkCreateManyCampaignInputEnvelope
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ReferralCreateWithoutCampaignInput, ReferralUncheckedCreateWithoutCampaignInput> | ReferralCreateWithoutCampaignInput[] | ReferralUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutCampaignInput | ReferralCreateOrConnectWithoutCampaignInput[]
    createMany?: ReferralCreateManyCampaignInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DonationCreateWithoutCampaignInput, DonationUncheckedCreateWithoutCampaignInput> | DonationCreateWithoutCampaignInput[] | DonationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutCampaignInput | DonationCreateOrConnectWithoutCampaignInput[]
    createMany?: DonationCreateManyCampaignInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutCampaignInput, PointsLedgerEntryUncheckedCreateWithoutCampaignInput> | PointsLedgerEntryCreateWithoutCampaignInput[] | PointsLedgerEntryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutCampaignInput | PointsLedgerEntryCreateOrConnectWithoutCampaignInput[]
    createMany?: PointsLedgerEntryCreateManyCampaignInputEnvelope
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
  }

  export type LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutCampaignInput, LeaderboardSnapshotUncheckedCreateWithoutCampaignInput> | LeaderboardSnapshotCreateWithoutCampaignInput[] | LeaderboardSnapshotUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutCampaignInput | LeaderboardSnapshotCreateOrConnectWithoutCampaignInput[]
    createMany?: LeaderboardSnapshotCreateManyCampaignInputEnvelope
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
  }

  export type ViewProofUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ViewProofCreateWithoutCampaignInput, ViewProofUncheckedCreateWithoutCampaignInput> | ViewProofCreateWithoutCampaignInput[] | ViewProofUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutCampaignInput | ViewProofCreateOrConnectWithoutCampaignInput[]
    createMany?: ViewProofCreateManyCampaignInputEnvelope
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
  }

  export type CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignAuditEventCreateWithoutCampaignInput, CampaignAuditEventUncheckedCreateWithoutCampaignInput> | CampaignAuditEventCreateWithoutCampaignInput[] | CampaignAuditEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutCampaignInput | CampaignAuditEventCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignAuditEventCreateManyCampaignInputEnvelope
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
  }

  export type NullableEnumCampaignMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.CampaignMediaType | null
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type NullableEnumGoalTypeFieldUpdateOperationsInput = {
    set?: $Enums.GoalType | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CampaignUpdatetargetAudienceInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CampaignUpdatebankAccountIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCampaignsInput
    upsert?: UserUpsertWithoutCreatedCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCampaignsInput, UserUpdateWithoutCreatedCampaignsInput>, UserUncheckedUpdateWithoutCreatedCampaignsInput>
  }

  export type CampaignUpdateOneWithoutSubCampaignsNestedInput = {
    create?: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSubCampaignsInput
    upsert?: CampaignUpsertWithoutSubCampaignsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSubCampaignsInput, CampaignUpdateWithoutSubCampaignsInput>, CampaignUncheckedUpdateWithoutSubCampaignsInput>
  }

  export type CampaignUpdateManyWithoutParentCampaignNestedInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutParentCampaignInput | CampaignUpsertWithWhereUniqueWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutParentCampaignInput | CampaignUpdateWithWhereUniqueWithoutParentCampaignInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutParentCampaignInput | CampaignUpdateManyWithWhereWithoutParentCampaignInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignParticipationUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignParticipationCreateWithoutCampaignInput, CampaignParticipationUncheckedCreateWithoutCampaignInput> | CampaignParticipationCreateWithoutCampaignInput[] | CampaignParticipationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutCampaignInput | CampaignParticipationCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignParticipationUpsertWithWhereUniqueWithoutCampaignInput | CampaignParticipationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignParticipationCreateManyCampaignInputEnvelope
    set?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    disconnect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    delete?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    update?: CampaignParticipationUpdateWithWhereUniqueWithoutCampaignInput | CampaignParticipationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignParticipationUpdateManyWithWhereWithoutCampaignInput | CampaignParticipationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignParticipationScalarWhereInput | CampaignParticipationScalarWhereInput[]
  }

  export type SmartLinkUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SmartLinkCreateWithoutCampaignInput, SmartLinkUncheckedCreateWithoutCampaignInput> | SmartLinkCreateWithoutCampaignInput[] | SmartLinkUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutCampaignInput | SmartLinkCreateOrConnectWithoutCampaignInput[]
    upsert?: SmartLinkUpsertWithWhereUniqueWithoutCampaignInput | SmartLinkUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SmartLinkCreateManyCampaignInputEnvelope
    set?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    disconnect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    delete?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    update?: SmartLinkUpdateWithWhereUniqueWithoutCampaignInput | SmartLinkUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SmartLinkUpdateManyWithWhereWithoutCampaignInput | SmartLinkUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SmartLinkScalarWhereInput | SmartLinkScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ReferralCreateWithoutCampaignInput, ReferralUncheckedCreateWithoutCampaignInput> | ReferralCreateWithoutCampaignInput[] | ReferralUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutCampaignInput | ReferralCreateOrConnectWithoutCampaignInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutCampaignInput | ReferralUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ReferralCreateManyCampaignInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutCampaignInput | ReferralUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutCampaignInput | ReferralUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type DonationUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DonationCreateWithoutCampaignInput, DonationUncheckedCreateWithoutCampaignInput> | DonationCreateWithoutCampaignInput[] | DonationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutCampaignInput | DonationCreateOrConnectWithoutCampaignInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutCampaignInput | DonationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DonationCreateManyCampaignInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutCampaignInput | DonationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutCampaignInput | DonationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PointsLedgerEntryUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutCampaignInput, PointsLedgerEntryUncheckedCreateWithoutCampaignInput> | PointsLedgerEntryCreateWithoutCampaignInput[] | PointsLedgerEntryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutCampaignInput | PointsLedgerEntryCreateOrConnectWithoutCampaignInput[]
    upsert?: PointsLedgerEntryUpsertWithWhereUniqueWithoutCampaignInput | PointsLedgerEntryUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PointsLedgerEntryCreateManyCampaignInputEnvelope
    set?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    disconnect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    delete?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    update?: PointsLedgerEntryUpdateWithWhereUniqueWithoutCampaignInput | PointsLedgerEntryUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PointsLedgerEntryUpdateManyWithWhereWithoutCampaignInput | PointsLedgerEntryUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PointsLedgerEntryScalarWhereInput | PointsLedgerEntryScalarWhereInput[]
  }

  export type LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutCampaignInput, LeaderboardSnapshotUncheckedCreateWithoutCampaignInput> | LeaderboardSnapshotCreateWithoutCampaignInput[] | LeaderboardSnapshotUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutCampaignInput | LeaderboardSnapshotCreateOrConnectWithoutCampaignInput[]
    upsert?: LeaderboardSnapshotUpsertWithWhereUniqueWithoutCampaignInput | LeaderboardSnapshotUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: LeaderboardSnapshotCreateManyCampaignInputEnvelope
    set?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    disconnect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    delete?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    update?: LeaderboardSnapshotUpdateWithWhereUniqueWithoutCampaignInput | LeaderboardSnapshotUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: LeaderboardSnapshotUpdateManyWithWhereWithoutCampaignInput | LeaderboardSnapshotUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: LeaderboardSnapshotScalarWhereInput | LeaderboardSnapshotScalarWhereInput[]
  }

  export type ViewProofUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ViewProofCreateWithoutCampaignInput, ViewProofUncheckedCreateWithoutCampaignInput> | ViewProofCreateWithoutCampaignInput[] | ViewProofUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutCampaignInput | ViewProofCreateOrConnectWithoutCampaignInput[]
    upsert?: ViewProofUpsertWithWhereUniqueWithoutCampaignInput | ViewProofUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ViewProofCreateManyCampaignInputEnvelope
    set?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    disconnect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    delete?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    update?: ViewProofUpdateWithWhereUniqueWithoutCampaignInput | ViewProofUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ViewProofUpdateManyWithWhereWithoutCampaignInput | ViewProofUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
  }

  export type CampaignAuditEventUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignAuditEventCreateWithoutCampaignInput, CampaignAuditEventUncheckedCreateWithoutCampaignInput> | CampaignAuditEventCreateWithoutCampaignInput[] | CampaignAuditEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutCampaignInput | CampaignAuditEventCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignAuditEventUpsertWithWhereUniqueWithoutCampaignInput | CampaignAuditEventUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignAuditEventCreateManyCampaignInputEnvelope
    set?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    disconnect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    delete?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    update?: CampaignAuditEventUpdateWithWhereUniqueWithoutCampaignInput | CampaignAuditEventUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignAuditEventUpdateManyWithWhereWithoutCampaignInput | CampaignAuditEventUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignAuditEventScalarWhereInput | CampaignAuditEventScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput = {
    create?: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput> | CampaignCreateWithoutParentCampaignInput[] | CampaignUncheckedCreateWithoutParentCampaignInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutParentCampaignInput | CampaignCreateOrConnectWithoutParentCampaignInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutParentCampaignInput | CampaignUpsertWithWhereUniqueWithoutParentCampaignInput[]
    createMany?: CampaignCreateManyParentCampaignInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutParentCampaignInput | CampaignUpdateWithWhereUniqueWithoutParentCampaignInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutParentCampaignInput | CampaignUpdateManyWithWhereWithoutParentCampaignInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignParticipationCreateWithoutCampaignInput, CampaignParticipationUncheckedCreateWithoutCampaignInput> | CampaignParticipationCreateWithoutCampaignInput[] | CampaignParticipationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignParticipationCreateOrConnectWithoutCampaignInput | CampaignParticipationCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignParticipationUpsertWithWhereUniqueWithoutCampaignInput | CampaignParticipationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignParticipationCreateManyCampaignInputEnvelope
    set?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    disconnect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    delete?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    connect?: CampaignParticipationWhereUniqueInput | CampaignParticipationWhereUniqueInput[]
    update?: CampaignParticipationUpdateWithWhereUniqueWithoutCampaignInput | CampaignParticipationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignParticipationUpdateManyWithWhereWithoutCampaignInput | CampaignParticipationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignParticipationScalarWhereInput | CampaignParticipationScalarWhereInput[]
  }

  export type SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SmartLinkCreateWithoutCampaignInput, SmartLinkUncheckedCreateWithoutCampaignInput> | SmartLinkCreateWithoutCampaignInput[] | SmartLinkUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SmartLinkCreateOrConnectWithoutCampaignInput | SmartLinkCreateOrConnectWithoutCampaignInput[]
    upsert?: SmartLinkUpsertWithWhereUniqueWithoutCampaignInput | SmartLinkUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SmartLinkCreateManyCampaignInputEnvelope
    set?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    disconnect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    delete?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    connect?: SmartLinkWhereUniqueInput | SmartLinkWhereUniqueInput[]
    update?: SmartLinkUpdateWithWhereUniqueWithoutCampaignInput | SmartLinkUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SmartLinkUpdateManyWithWhereWithoutCampaignInput | SmartLinkUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SmartLinkScalarWhereInput | SmartLinkScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ReferralCreateWithoutCampaignInput, ReferralUncheckedCreateWithoutCampaignInput> | ReferralCreateWithoutCampaignInput[] | ReferralUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutCampaignInput | ReferralCreateOrConnectWithoutCampaignInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutCampaignInput | ReferralUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ReferralCreateManyCampaignInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutCampaignInput | ReferralUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutCampaignInput | ReferralUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DonationCreateWithoutCampaignInput, DonationUncheckedCreateWithoutCampaignInput> | DonationCreateWithoutCampaignInput[] | DonationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutCampaignInput | DonationCreateOrConnectWithoutCampaignInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutCampaignInput | DonationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DonationCreateManyCampaignInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutCampaignInput | DonationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutCampaignInput | DonationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PointsLedgerEntryCreateWithoutCampaignInput, PointsLedgerEntryUncheckedCreateWithoutCampaignInput> | PointsLedgerEntryCreateWithoutCampaignInput[] | PointsLedgerEntryUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PointsLedgerEntryCreateOrConnectWithoutCampaignInput | PointsLedgerEntryCreateOrConnectWithoutCampaignInput[]
    upsert?: PointsLedgerEntryUpsertWithWhereUniqueWithoutCampaignInput | PointsLedgerEntryUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PointsLedgerEntryCreateManyCampaignInputEnvelope
    set?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    disconnect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    delete?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    connect?: PointsLedgerEntryWhereUniqueInput | PointsLedgerEntryWhereUniqueInput[]
    update?: PointsLedgerEntryUpdateWithWhereUniqueWithoutCampaignInput | PointsLedgerEntryUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PointsLedgerEntryUpdateManyWithWhereWithoutCampaignInput | PointsLedgerEntryUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PointsLedgerEntryScalarWhereInput | PointsLedgerEntryScalarWhereInput[]
  }

  export type LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<LeaderboardSnapshotCreateWithoutCampaignInput, LeaderboardSnapshotUncheckedCreateWithoutCampaignInput> | LeaderboardSnapshotCreateWithoutCampaignInput[] | LeaderboardSnapshotUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeaderboardSnapshotCreateOrConnectWithoutCampaignInput | LeaderboardSnapshotCreateOrConnectWithoutCampaignInput[]
    upsert?: LeaderboardSnapshotUpsertWithWhereUniqueWithoutCampaignInput | LeaderboardSnapshotUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: LeaderboardSnapshotCreateManyCampaignInputEnvelope
    set?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    disconnect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    delete?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    connect?: LeaderboardSnapshotWhereUniqueInput | LeaderboardSnapshotWhereUniqueInput[]
    update?: LeaderboardSnapshotUpdateWithWhereUniqueWithoutCampaignInput | LeaderboardSnapshotUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: LeaderboardSnapshotUpdateManyWithWhereWithoutCampaignInput | LeaderboardSnapshotUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: LeaderboardSnapshotScalarWhereInput | LeaderboardSnapshotScalarWhereInput[]
  }

  export type ViewProofUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ViewProofCreateWithoutCampaignInput, ViewProofUncheckedCreateWithoutCampaignInput> | ViewProofCreateWithoutCampaignInput[] | ViewProofUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ViewProofCreateOrConnectWithoutCampaignInput | ViewProofCreateOrConnectWithoutCampaignInput[]
    upsert?: ViewProofUpsertWithWhereUniqueWithoutCampaignInput | ViewProofUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ViewProofCreateManyCampaignInputEnvelope
    set?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    disconnect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    delete?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    connect?: ViewProofWhereUniqueInput | ViewProofWhereUniqueInput[]
    update?: ViewProofUpdateWithWhereUniqueWithoutCampaignInput | ViewProofUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ViewProofUpdateManyWithWhereWithoutCampaignInput | ViewProofUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
  }

  export type CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignAuditEventCreateWithoutCampaignInput, CampaignAuditEventUncheckedCreateWithoutCampaignInput> | CampaignAuditEventCreateWithoutCampaignInput[] | CampaignAuditEventUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAuditEventCreateOrConnectWithoutCampaignInput | CampaignAuditEventCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignAuditEventUpsertWithWhereUniqueWithoutCampaignInput | CampaignAuditEventUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignAuditEventCreateManyCampaignInputEnvelope
    set?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    disconnect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    delete?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    connect?: CampaignAuditEventWhereUniqueInput | CampaignAuditEventWhereUniqueInput[]
    update?: CampaignAuditEventUpdateWithWhereUniqueWithoutCampaignInput | CampaignAuditEventUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignAuditEventUpdateManyWithWhereWithoutCampaignInput | CampaignAuditEventUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignAuditEventScalarWhereInput | CampaignAuditEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipationsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<CampaignCreateWithoutParticipationsInput, CampaignUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutParticipationsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipationsInput
    upsert?: UserUpsertWithoutParticipationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParticipationsInput, UserUpdateWithoutParticipationsInput>, UserUncheckedUpdateWithoutParticipationsInput>
  }

  export type CampaignUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<CampaignCreateWithoutParticipationsInput, CampaignUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutParticipationsInput
    upsert?: CampaignUpsertWithoutParticipationsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutParticipationsInput, CampaignUpdateWithoutParticipationsInput>, CampaignUncheckedUpdateWithoutParticipationsInput>
  }

  export type UserCreateNestedOneWithoutSmartLinksInput = {
    create?: XOR<UserCreateWithoutSmartLinksInput, UserUncheckedCreateWithoutSmartLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmartLinksInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutSmartLinksInput = {
    create?: XOR<CampaignCreateWithoutSmartLinksInput, CampaignUncheckedCreateWithoutSmartLinksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSmartLinksInput
    connect?: CampaignWhereUniqueInput
  }

  export type LinkEventCreateNestedManyWithoutSmartLinkInput = {
    create?: XOR<LinkEventCreateWithoutSmartLinkInput, LinkEventUncheckedCreateWithoutSmartLinkInput> | LinkEventCreateWithoutSmartLinkInput[] | LinkEventUncheckedCreateWithoutSmartLinkInput[]
    connectOrCreate?: LinkEventCreateOrConnectWithoutSmartLinkInput | LinkEventCreateOrConnectWithoutSmartLinkInput[]
    createMany?: LinkEventCreateManySmartLinkInputEnvelope
    connect?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
  }

  export type LinkEventUncheckedCreateNestedManyWithoutSmartLinkInput = {
    create?: XOR<LinkEventCreateWithoutSmartLinkInput, LinkEventUncheckedCreateWithoutSmartLinkInput> | LinkEventCreateWithoutSmartLinkInput[] | LinkEventUncheckedCreateWithoutSmartLinkInput[]
    connectOrCreate?: LinkEventCreateOrConnectWithoutSmartLinkInput | LinkEventCreateOrConnectWithoutSmartLinkInput[]
    createMany?: LinkEventCreateManySmartLinkInputEnvelope
    connect?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSmartLinksNestedInput = {
    create?: XOR<UserCreateWithoutSmartLinksInput, UserUncheckedCreateWithoutSmartLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmartLinksInput
    upsert?: UserUpsertWithoutSmartLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSmartLinksInput, UserUpdateWithoutSmartLinksInput>, UserUncheckedUpdateWithoutSmartLinksInput>
  }

  export type CampaignUpdateOneRequiredWithoutSmartLinksNestedInput = {
    create?: XOR<CampaignCreateWithoutSmartLinksInput, CampaignUncheckedCreateWithoutSmartLinksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSmartLinksInput
    upsert?: CampaignUpsertWithoutSmartLinksInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSmartLinksInput, CampaignUpdateWithoutSmartLinksInput>, CampaignUncheckedUpdateWithoutSmartLinksInput>
  }

  export type LinkEventUpdateManyWithoutSmartLinkNestedInput = {
    create?: XOR<LinkEventCreateWithoutSmartLinkInput, LinkEventUncheckedCreateWithoutSmartLinkInput> | LinkEventCreateWithoutSmartLinkInput[] | LinkEventUncheckedCreateWithoutSmartLinkInput[]
    connectOrCreate?: LinkEventCreateOrConnectWithoutSmartLinkInput | LinkEventCreateOrConnectWithoutSmartLinkInput[]
    upsert?: LinkEventUpsertWithWhereUniqueWithoutSmartLinkInput | LinkEventUpsertWithWhereUniqueWithoutSmartLinkInput[]
    createMany?: LinkEventCreateManySmartLinkInputEnvelope
    set?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    disconnect?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    delete?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    connect?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    update?: LinkEventUpdateWithWhereUniqueWithoutSmartLinkInput | LinkEventUpdateWithWhereUniqueWithoutSmartLinkInput[]
    updateMany?: LinkEventUpdateManyWithWhereWithoutSmartLinkInput | LinkEventUpdateManyWithWhereWithoutSmartLinkInput[]
    deleteMany?: LinkEventScalarWhereInput | LinkEventScalarWhereInput[]
  }

  export type LinkEventUncheckedUpdateManyWithoutSmartLinkNestedInput = {
    create?: XOR<LinkEventCreateWithoutSmartLinkInput, LinkEventUncheckedCreateWithoutSmartLinkInput> | LinkEventCreateWithoutSmartLinkInput[] | LinkEventUncheckedCreateWithoutSmartLinkInput[]
    connectOrCreate?: LinkEventCreateOrConnectWithoutSmartLinkInput | LinkEventCreateOrConnectWithoutSmartLinkInput[]
    upsert?: LinkEventUpsertWithWhereUniqueWithoutSmartLinkInput | LinkEventUpsertWithWhereUniqueWithoutSmartLinkInput[]
    createMany?: LinkEventCreateManySmartLinkInputEnvelope
    set?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    disconnect?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    delete?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    connect?: LinkEventWhereUniqueInput | LinkEventWhereUniqueInput[]
    update?: LinkEventUpdateWithWhereUniqueWithoutSmartLinkInput | LinkEventUpdateWithWhereUniqueWithoutSmartLinkInput[]
    updateMany?: LinkEventUpdateManyWithWhereWithoutSmartLinkInput | LinkEventUpdateManyWithWhereWithoutSmartLinkInput[]
    deleteMany?: LinkEventScalarWhereInput | LinkEventScalarWhereInput[]
  }

  export type SmartLinkCreateNestedOneWithoutLinkEventsInput = {
    create?: XOR<SmartLinkCreateWithoutLinkEventsInput, SmartLinkUncheckedCreateWithoutLinkEventsInput>
    connectOrCreate?: SmartLinkCreateOrConnectWithoutLinkEventsInput
    connect?: SmartLinkWhereUniqueInput
  }

  export type EnumLinkEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.LinkEventType
  }

  export type NullableEnumLinkEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.LinkEventType | null
  }

  export type SmartLinkUpdateOneRequiredWithoutLinkEventsNestedInput = {
    create?: XOR<SmartLinkCreateWithoutLinkEventsInput, SmartLinkUncheckedCreateWithoutLinkEventsInput>
    connectOrCreate?: SmartLinkCreateOrConnectWithoutLinkEventsInput
    upsert?: SmartLinkUpsertWithoutLinkEventsInput
    connect?: SmartLinkWhereUniqueInput
    update?: XOR<XOR<SmartLinkUpdateToOneWithWhereWithoutLinkEventsInput, SmartLinkUpdateWithoutLinkEventsInput>, SmartLinkUncheckedUpdateWithoutLinkEventsInput>
  }

  export type UserCreateNestedOneWithoutReferralsGivenInput = {
    create?: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralsReceivedInput = {
    create?: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutReferralsInput = {
    create?: XOR<CampaignCreateWithoutReferralsInput, CampaignUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutReferralsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferralsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsGivenInput
    upsert?: UserUpsertWithoutReferralsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsGivenInput, UserUpdateWithoutReferralsGivenInput>, UserUncheckedUpdateWithoutReferralsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutReferralsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsReceivedInput
    upsert?: UserUpsertWithoutReferralsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsReceivedInput, UserUpdateWithoutReferralsReceivedInput>, UserUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type CampaignUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<CampaignCreateWithoutReferralsInput, CampaignUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutReferralsInput
    upsert?: CampaignUpsertWithoutReferralsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutReferralsInput, CampaignUpdateWithoutReferralsInput>, CampaignUncheckedUpdateWithoutReferralsInput>
  }

  export type UserCreateNestedOneWithoutDonationsInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutDonationsInput = {
    create?: XOR<CampaignCreateWithoutDonationsInput, CampaignUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDonationsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedDonationsInput = {
    create?: XOR<UserCreateWithoutVerifiedDonationsInput, UserUncheckedCreateWithoutVerifiedDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedDonationsInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumDonationStatusFieldUpdateOperationsInput = {
    set?: $Enums.DonationStatus
  }

  export type UserUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    upsert?: UserUpsertWithoutDonationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDonationsInput, UserUpdateWithoutDonationsInput>, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type CampaignUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<CampaignCreateWithoutDonationsInput, CampaignUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDonationsInput
    upsert?: CampaignUpsertWithoutDonationsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutDonationsInput, CampaignUpdateWithoutDonationsInput>, CampaignUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateOneWithoutVerifiedDonationsNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedDonationsInput, UserUncheckedCreateWithoutVerifiedDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedDonationsInput
    upsert?: UserUpsertWithoutVerifiedDonationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedDonationsInput, UserUpdateWithoutVerifiedDonationsInput>, UserUncheckedUpdateWithoutVerifiedDonationsInput>
  }

  export type UserCreateNestedOneWithoutPointsLedgerInput = {
    create?: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsLedgerInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutPointsLedgerInput = {
    create?: XOR<CampaignCreateWithoutPointsLedgerInput, CampaignUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPointsLedgerInput
    connect?: CampaignWhereUniqueInput
  }

  export type EnumPointTypeFieldUpdateOperationsInput = {
    set?: $Enums.PointType
  }

  export type UserUpdateOneRequiredWithoutPointsLedgerNestedInput = {
    create?: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointsLedgerInput
    upsert?: UserUpsertWithoutPointsLedgerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointsLedgerInput, UserUpdateWithoutPointsLedgerInput>, UserUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type CampaignUpdateOneWithoutPointsLedgerNestedInput = {
    create?: XOR<CampaignCreateWithoutPointsLedgerInput, CampaignUncheckedCreateWithoutPointsLedgerInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPointsLedgerInput
    upsert?: CampaignUpsertWithoutPointsLedgerInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutPointsLedgerInput, CampaignUpdateWithoutPointsLedgerInput>, CampaignUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type UserCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<CampaignCreateWithoutLeaderboardInput, CampaignUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeaderboardInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: UserUpsertWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput, UserUpdateWithoutLeaderboardEntriesInput>, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type CampaignUpdateOneWithoutLeaderboardNestedInput = {
    create?: XOR<CampaignCreateWithoutLeaderboardInput, CampaignUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeaderboardInput
    upsert?: CampaignUpsertWithoutLeaderboardInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutLeaderboardInput, CampaignUpdateWithoutLeaderboardInput>, CampaignUncheckedUpdateWithoutLeaderboardInput>
  }

  export type TrustScoreCreateflagsInput = {
    set: $Enums.TrustFlag[]
  }

  export type UserCreateNestedOneWithoutTrustScoreRecordInput = {
    create?: XOR<UserCreateWithoutTrustScoreRecordInput, UserUncheckedCreateWithoutTrustScoreRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustScoreRecordInput
    connect?: UserWhereUniqueInput
  }

  export type TrustScoreUpdateflagsInput = {
    set?: $Enums.TrustFlag[]
    push?: $Enums.TrustFlag | $Enums.TrustFlag[]
  }

  export type UserUpdateOneRequiredWithoutTrustScoreRecordNestedInput = {
    create?: XOR<UserCreateWithoutTrustScoreRecordInput, UserUncheckedCreateWithoutTrustScoreRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustScoreRecordInput
    upsert?: UserUpsertWithoutTrustScoreRecordInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrustScoreRecordInput, UserUpdateWithoutTrustScoreRecordInput>, UserUncheckedUpdateWithoutTrustScoreRecordInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutViewProofsInput = {
    create?: XOR<UserCreateWithoutViewProofsInput, UserUncheckedCreateWithoutViewProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewProofsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedProofsInput = {
    create?: XOR<UserCreateWithoutReviewedProofsInput, UserUncheckedCreateWithoutReviewedProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedProofsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutViewProofsInput = {
    create?: XOR<CampaignCreateWithoutViewProofsInput, CampaignUncheckedCreateWithoutViewProofsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutViewProofsInput
    connect?: CampaignWhereUniqueInput
  }

  export type EnumSocialPlatformFieldUpdateOperationsInput = {
    set?: $Enums.SocialPlatform
  }

  export type EnumViewProofStatusFieldUpdateOperationsInput = {
    set?: $Enums.ViewProofStatus
  }

  export type UserUpdateOneRequiredWithoutViewProofsNestedInput = {
    create?: XOR<UserCreateWithoutViewProofsInput, UserUncheckedCreateWithoutViewProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewProofsInput
    upsert?: UserUpsertWithoutViewProofsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewProofsInput, UserUpdateWithoutViewProofsInput>, UserUncheckedUpdateWithoutViewProofsInput>
  }

  export type UserUpdateOneWithoutReviewedProofsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedProofsInput, UserUncheckedCreateWithoutReviewedProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedProofsInput
    upsert?: UserUpsertWithoutReviewedProofsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedProofsInput, UserUpdateWithoutReviewedProofsInput>, UserUncheckedUpdateWithoutReviewedProofsInput>
  }

  export type CampaignUpdateOneRequiredWithoutViewProofsNestedInput = {
    create?: XOR<CampaignCreateWithoutViewProofsInput, CampaignUncheckedCreateWithoutViewProofsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutViewProofsInput
    upsert?: CampaignUpsertWithoutViewProofsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutViewProofsInput, CampaignUpdateWithoutViewProofsInput>, CampaignUncheckedUpdateWithoutViewProofsInput>
  }

  export type TeamCreateNestedManyWithoutGroupInput = {
    create?: XOR<TeamCreateWithoutGroupInput, TeamUncheckedCreateWithoutGroupInput> | TeamCreateWithoutGroupInput[] | TeamUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutGroupInput | TeamCreateOrConnectWithoutGroupInput[]
    createMany?: TeamCreateManyGroupInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<TeamCreateWithoutGroupInput, TeamUncheckedCreateWithoutGroupInput> | TeamCreateWithoutGroupInput[] | TeamUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutGroupInput | TeamCreateOrConnectWithoutGroupInput[]
    createMany?: TeamCreateManyGroupInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TeamCreateWithoutGroupInput, TeamUncheckedCreateWithoutGroupInput> | TeamCreateWithoutGroupInput[] | TeamUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutGroupInput | TeamCreateOrConnectWithoutGroupInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutGroupInput | TeamUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TeamCreateManyGroupInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutGroupInput | TeamUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutGroupInput | TeamUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TeamCreateWithoutGroupInput, TeamUncheckedCreateWithoutGroupInput> | TeamCreateWithoutGroupInput[] | TeamUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutGroupInput | TeamCreateOrConnectWithoutGroupInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutGroupInput | TeamUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TeamCreateManyGroupInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutGroupInput | TeamUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutGroupInput | TeamUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutTeamsInput = {
    create?: XOR<GroupCreateWithoutTeamsInput, GroupUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutTeamsInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamInviteLinkCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamInviteLinkCreateWithoutTeamInput, TeamInviteLinkUncheckedCreateWithoutTeamInput> | TeamInviteLinkCreateWithoutTeamInput[] | TeamInviteLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutTeamInput | TeamInviteLinkCreateOrConnectWithoutTeamInput[]
    createMany?: TeamInviteLinkCreateManyTeamInputEnvelope
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamInviteLinkUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamInviteLinkCreateWithoutTeamInput, TeamInviteLinkUncheckedCreateWithoutTeamInput> | TeamInviteLinkCreateWithoutTeamInput[] | TeamInviteLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutTeamInput | TeamInviteLinkCreateOrConnectWithoutTeamInput[]
    createMany?: TeamInviteLinkCreateManyTeamInputEnvelope
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
  }

  export type GroupUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<GroupCreateWithoutTeamsInput, GroupUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutTeamsInput
    upsert?: GroupUpsertWithoutTeamsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutTeamsInput, GroupUpdateWithoutTeamsInput>, GroupUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamInviteLinkUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamInviteLinkCreateWithoutTeamInput, TeamInviteLinkUncheckedCreateWithoutTeamInput> | TeamInviteLinkCreateWithoutTeamInput[] | TeamInviteLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutTeamInput | TeamInviteLinkCreateOrConnectWithoutTeamInput[]
    upsert?: TeamInviteLinkUpsertWithWhereUniqueWithoutTeamInput | TeamInviteLinkUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamInviteLinkCreateManyTeamInputEnvelope
    set?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    disconnect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    delete?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    update?: TeamInviteLinkUpdateWithWhereUniqueWithoutTeamInput | TeamInviteLinkUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamInviteLinkUpdateManyWithWhereWithoutTeamInput | TeamInviteLinkUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamInviteLinkScalarWhereInput | TeamInviteLinkScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamInviteLinkUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamInviteLinkCreateWithoutTeamInput, TeamInviteLinkUncheckedCreateWithoutTeamInput> | TeamInviteLinkCreateWithoutTeamInput[] | TeamInviteLinkUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInviteLinkCreateOrConnectWithoutTeamInput | TeamInviteLinkCreateOrConnectWithoutTeamInput[]
    upsert?: TeamInviteLinkUpsertWithWhereUniqueWithoutTeamInput | TeamInviteLinkUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamInviteLinkCreateManyTeamInputEnvelope
    set?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    disconnect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    delete?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    connect?: TeamInviteLinkWhereUniqueInput | TeamInviteLinkWhereUniqueInput[]
    update?: TeamInviteLinkUpdateWithWhereUniqueWithoutTeamInput | TeamInviteLinkUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamInviteLinkUpdateManyWithWhereWithoutTeamInput | TeamInviteLinkUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamInviteLinkScalarWhereInput | TeamInviteLinkScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutTeamInviteLinksInput = {
    create?: XOR<TeamCreateWithoutTeamInviteLinksInput, TeamUncheckedCreateWithoutTeamInviteLinksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamInviteLinksInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamInviteLinksInput = {
    create?: XOR<UserCreateWithoutTeamInviteLinksInput, UserUncheckedCreateWithoutTeamInviteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamInviteLinksInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutTeamInviteLinksNestedInput = {
    create?: XOR<TeamCreateWithoutTeamInviteLinksInput, TeamUncheckedCreateWithoutTeamInviteLinksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamInviteLinksInput
    upsert?: TeamUpsertWithoutTeamInviteLinksInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTeamInviteLinksInput, TeamUpdateWithoutTeamInviteLinksInput>, TeamUncheckedUpdateWithoutTeamInviteLinksInput>
  }

  export type UserUpdateOneRequiredWithoutTeamInviteLinksNestedInput = {
    create?: XOR<UserCreateWithoutTeamInviteLinksInput, UserUncheckedCreateWithoutTeamInviteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamInviteLinksInput
    upsert?: UserUpsertWithoutTeamInviteLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamInviteLinksInput, UserUpdateWithoutTeamInviteLinksInput>, UserUncheckedUpdateWithoutTeamInviteLinksInput>
  }

  export type CampaignCreateNestedOneWithoutAuditEventsInput = {
    create?: XOR<CampaignCreateWithoutAuditEventsInput, CampaignUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAuditEventsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditEventsInput = {
    create?: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCampaignAuditEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.CampaignAuditEventType
  }

  export type CampaignUpdateOneRequiredWithoutAuditEventsNestedInput = {
    create?: XOR<CampaignCreateWithoutAuditEventsInput, CampaignUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAuditEventsInput
    upsert?: CampaignUpsertWithoutAuditEventsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAuditEventsInput, CampaignUpdateWithoutAuditEventsInput>, CampaignUncheckedUpdateWithoutAuditEventsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditEventsNestedInput = {
    create?: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsInput
    upsert?: UserUpsertWithoutAuditEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditEventsInput, UserUpdateWithoutAuditEventsInput>, UserUncheckedUpdateWithoutAuditEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCampaignMediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignMediaType | EnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignMediaTypeNullableFilter<$PrismaModel> | $Enums.CampaignMediaType | null
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumGoalTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGoalTypeNullableFilter<$PrismaModel> | $Enums.GoalType | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCampaignMediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignMediaType | EnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CampaignMediaType[] | ListEnumCampaignMediaTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCampaignMediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CampaignMediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCampaignMediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCampaignMediaTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumGoalTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGoalTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.GoalType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGoalTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumGoalTypeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumLinkEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLinkEventTypeFilter<$PrismaModel> | $Enums.LinkEventType
  }

  export type NestedEnumLinkEventTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLinkEventTypeNullableFilter<$PrismaModel> | $Enums.LinkEventType | null
  }

  export type NestedEnumLinkEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLinkEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.LinkEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLinkEventTypeFilter<$PrismaModel>
    _max?: NestedEnumLinkEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumLinkEventTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LinkEventType | EnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LinkEventType[] | ListEnumLinkEventTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLinkEventTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.LinkEventType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLinkEventTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumLinkEventTypeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumDonationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DonationStatus | EnumDonationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDonationStatusFilter<$PrismaModel> | $Enums.DonationStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumDonationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DonationStatus | EnumDonationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DonationStatus[] | ListEnumDonationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDonationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DonationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDonationStatusFilter<$PrismaModel>
    _max?: NestedEnumDonationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPointTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointTypeFilter<$PrismaModel> | $Enums.PointType
  }

  export type NestedEnumPointTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PointType[] | ListEnumPointTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPointTypeWithAggregatesFilter<$PrismaModel> | $Enums.PointType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPointTypeFilter<$PrismaModel>
    _max?: NestedEnumPointTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumSocialPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformFilter<$PrismaModel> | $Enums.SocialPlatform
  }

  export type NestedEnumViewProofStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewProofStatus | EnumViewProofStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumViewProofStatusFilter<$PrismaModel> | $Enums.ViewProofStatus
  }

  export type NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SocialPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialPlatformFilter<$PrismaModel>
    _max?: NestedEnumSocialPlatformFilter<$PrismaModel>
  }

  export type NestedEnumViewProofStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ViewProofStatus | EnumViewProofStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ViewProofStatus[] | ListEnumViewProofStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumViewProofStatusWithAggregatesFilter<$PrismaModel> | $Enums.ViewProofStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumViewProofStatusFilter<$PrismaModel>
    _max?: NestedEnumViewProofStatusFilter<$PrismaModel>
  }

  export type NestedEnumCampaignAuditEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignAuditEventType | EnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignAuditEventTypeFilter<$PrismaModel> | $Enums.CampaignAuditEventType
  }

  export type NestedEnumCampaignAuditEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignAuditEventType | EnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignAuditEventType[] | ListEnumCampaignAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignAuditEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignAuditEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignAuditEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignAuditEventTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutTeamsInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    groupId: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type CampaignCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignCreateManyCreatorInputEnvelope = {
    data: CampaignCreateManyCreatorInput | CampaignCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CampaignParticipationCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    smartLinkId?: string | null
    campaign: CampaignCreateNestedOneWithoutParticipationsInput
  }

  export type CampaignParticipationUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    joinedAt?: Date | string
    smartLinkId?: string | null
  }

  export type CampaignParticipationCreateOrConnectWithoutUserInput = {
    where: CampaignParticipationWhereUniqueInput
    create: XOR<CampaignParticipationCreateWithoutUserInput, CampaignParticipationUncheckedCreateWithoutUserInput>
  }

  export type CampaignParticipationCreateManyUserInputEnvelope = {
    data: CampaignParticipationCreateManyUserInput | CampaignParticipationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SmartLinkCreateWithoutUserInput = {
    id?: string
    slug: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutSmartLinksInput
    linkEvents?: LinkEventCreateNestedManyWithoutSmartLinkInput
  }

  export type SmartLinkUncheckedCreateWithoutUserInput = {
    id?: string
    slug: string
    campaignId: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkEvents?: LinkEventUncheckedCreateNestedManyWithoutSmartLinkInput
  }

  export type SmartLinkCreateOrConnectWithoutUserInput = {
    where: SmartLinkWhereUniqueInput
    create: XOR<SmartLinkCreateWithoutUserInput, SmartLinkUncheckedCreateWithoutUserInput>
  }

  export type SmartLinkCreateManyUserInputEnvelope = {
    data: SmartLinkCreateManyUserInput | SmartLinkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutInviterInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    invitee: UserCreateNestedOneWithoutReferralsReceivedInput
    campaign: CampaignCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutInviterInput = {
    id?: string
    inviteeId: string
    campaignId: string
    slug: string
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutInviterInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutInviterInput, ReferralUncheckedCreateWithoutInviterInput>
  }

  export type ReferralCreateManyInviterInputEnvelope = {
    data: ReferralCreateManyInviterInput | ReferralCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutInviteeInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    inviter: UserCreateNestedOneWithoutReferralsGivenInput
    campaign: CampaignCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutInviteeInput = {
    id?: string
    inviterId: string
    campaignId: string
    slug: string
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutInviteeInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutInviteeInput, ReferralUncheckedCreateWithoutInviteeInput>
  }

  export type ReferralCreateManyInviteeInputEnvelope = {
    data: ReferralCreateManyInviteeInput | ReferralCreateManyInviteeInput[]
    skipDuplicates?: boolean
  }

  export type DonationCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutDonationsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedDonationsInput
  }

  export type DonationUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateOrConnectWithoutUserInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationCreateManyUserInputEnvelope = {
    data: DonationCreateManyUserInput | DonationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DonationCreateWithoutVerifiedByInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDonationsInput
    campaign: CampaignCreateNestedOneWithoutDonationsInput
  }

  export type DonationUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    userId: string
    campaignId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateOrConnectWithoutVerifiedByInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutVerifiedByInput, DonationUncheckedCreateWithoutVerifiedByInput>
  }

  export type DonationCreateManyVerifiedByInputEnvelope = {
    data: DonationCreateManyVerifiedByInput | DonationCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type PointsLedgerEntryCreateWithoutUserInput = {
    id?: string
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutPointsLedgerInput
  }

  export type PointsLedgerEntryUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId?: string | null
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerEntryCreateOrConnectWithoutUserInput = {
    where: PointsLedgerEntryWhereUniqueInput
    create: XOR<PointsLedgerEntryCreateWithoutUserInput, PointsLedgerEntryUncheckedCreateWithoutUserInput>
  }

  export type PointsLedgerEntryCreateManyUserInputEnvelope = {
    data: PointsLedgerEntryCreateManyUserInput | PointsLedgerEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardSnapshotCreateWithoutUserInput = {
    id?: string
    period: string
    rank: number
    score: number
    createdAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutLeaderboardInput
  }

  export type LeaderboardSnapshotUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId?: string | null
    period: string
    rank: number
    score: number
    createdAt?: Date | string
  }

  export type LeaderboardSnapshotCreateOrConnectWithoutUserInput = {
    where: LeaderboardSnapshotWhereUniqueInput
    create: XOR<LeaderboardSnapshotCreateWithoutUserInput, LeaderboardSnapshotUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardSnapshotCreateManyUserInputEnvelope = {
    data: LeaderboardSnapshotCreateManyUserInput | LeaderboardSnapshotCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrustScoreCreateWithoutUserInput = {
    id?: string
    score?: number
    flags?: TrustScoreCreateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TrustScoreUncheckedCreateWithoutUserInput = {
    id?: string
    score?: number
    flags?: TrustScoreCreateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TrustScoreCreateOrConnectWithoutUserInput = {
    where: TrustScoreWhereUniqueInput
    create: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
  }

  export type AppNotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type AppNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type AppNotificationCreateOrConnectWithoutUserInput = {
    where: AppNotificationWhereUniqueInput
    create: XOR<AppNotificationCreateWithoutUserInput, AppNotificationUncheckedCreateWithoutUserInput>
  }

  export type AppNotificationCreateManyUserInputEnvelope = {
    data: AppNotificationCreateManyUserInput | AppNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewProofCreateWithoutUserInput = {
    id?: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedBy?: UserCreateNestedOneWithoutReviewedProofsInput
    campaign: CampaignCreateNestedOneWithoutViewProofsInput
  }

  export type ViewProofUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewProofCreateOrConnectWithoutUserInput = {
    where: ViewProofWhereUniqueInput
    create: XOR<ViewProofCreateWithoutUserInput, ViewProofUncheckedCreateWithoutUserInput>
  }

  export type ViewProofCreateManyUserInputEnvelope = {
    data: ViewProofCreateManyUserInput | ViewProofCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewProofCreateWithoutReviewedByInput = {
    id?: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutViewProofsInput
    campaign: CampaignCreateNestedOneWithoutViewProofsInput
  }

  export type ViewProofUncheckedCreateWithoutReviewedByInput = {
    id?: string
    userId: string
    campaignId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewProofCreateOrConnectWithoutReviewedByInput = {
    where: ViewProofWhereUniqueInput
    create: XOR<ViewProofCreateWithoutReviewedByInput, ViewProofUncheckedCreateWithoutReviewedByInput>
  }

  export type ViewProofCreateManyReviewedByInputEnvelope = {
    data: ViewProofCreateManyReviewedByInput | ViewProofCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type TeamInviteLinkCreateWithoutCreatedByInput = {
    id?: string
    token: string
    targetRole: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamInviteLinksInput
  }

  export type TeamInviteLinkUncheckedCreateWithoutCreatedByInput = {
    id?: string
    token: string
    teamId: string
    targetRole: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TeamInviteLinkCreateOrConnectWithoutCreatedByInput = {
    where: TeamInviteLinkWhereUniqueInput
    create: XOR<TeamInviteLinkCreateWithoutCreatedByInput, TeamInviteLinkUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamInviteLinkCreateManyCreatedByInputEnvelope = {
    data: TeamInviteLinkCreateManyCreatedByInput | TeamInviteLinkCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CampaignAuditEventCreateWithoutActorInput = {
    id?: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAuditEventsInput
  }

  export type CampaignAuditEventUncheckedCreateWithoutActorInput = {
    id?: string
    campaignId: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type CampaignAuditEventCreateOrConnectWithoutActorInput = {
    where: CampaignAuditEventWhereUniqueInput
    create: XOR<CampaignAuditEventCreateWithoutActorInput, CampaignAuditEventUncheckedCreateWithoutActorInput>
  }

  export type CampaignAuditEventCreateManyActorInputEnvelope = {
    data: CampaignAuditEventCreateManyActorInput | CampaignAuditEventCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutTeamsNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCreatorInput, CampaignUncheckedUpdateWithoutCreatorInput>
    create: XOR<CampaignCreateWithoutCreatorInput, CampaignUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCreatorInput, CampaignUncheckedUpdateWithoutCreatorInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCreatorInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    title?: StringFilter<"Campaign"> | string
    description?: StringFilter<"Campaign"> | string
    content?: StringFilter<"Campaign"> | string
    media?: JsonFilter<"Campaign">
    mediaType?: EnumCampaignMediaTypeNullableFilter<"Campaign"> | $Enums.CampaignMediaType | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    thumbnailUrl?: StringNullableFilter<"Campaign"> | string | null
    ctaText?: StringNullableFilter<"Campaign"> | string | null
    ctaUrl?: StringNullableFilter<"Campaign"> | string | null
    createdById?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    goalType?: EnumGoalTypeNullableFilter<"Campaign"> | $Enums.GoalType | null
    goalTarget?: IntNullableFilter<"Campaign"> | number | null
    goalCurrent?: IntNullableFilter<"Campaign"> | number | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    targetAudience?: StringNullableListFilter<"Campaign">
    publishedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    metaTitle?: StringNullableFilter<"Campaign"> | string | null
    metaDescription?: StringNullableFilter<"Campaign"> | string | null
    metaImage?: StringNullableFilter<"Campaign"> | string | null
    viewCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    shareCount?: IntFilter<"Campaign"> | number
    likeCount?: IntNullableFilter<"Campaign"> | number | null
    participantCount?: IntNullableFilter<"Campaign"> | number | null
    isMegaCampaign?: BoolNullableFilter<"Campaign"> | boolean | null
    parentCampaignId?: StringNullableFilter<"Campaign"> | string | null
    bankAccountIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CampaignParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignParticipationWhereUniqueInput
    update: XOR<CampaignParticipationUpdateWithoutUserInput, CampaignParticipationUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignParticipationCreateWithoutUserInput, CampaignParticipationUncheckedCreateWithoutUserInput>
  }

  export type CampaignParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignParticipationWhereUniqueInput
    data: XOR<CampaignParticipationUpdateWithoutUserInput, CampaignParticipationUncheckedUpdateWithoutUserInput>
  }

  export type CampaignParticipationUpdateManyWithWhereWithoutUserInput = {
    where: CampaignParticipationScalarWhereInput
    data: XOR<CampaignParticipationUpdateManyMutationInput, CampaignParticipationUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignParticipationScalarWhereInput = {
    AND?: CampaignParticipationScalarWhereInput | CampaignParticipationScalarWhereInput[]
    OR?: CampaignParticipationScalarWhereInput[]
    NOT?: CampaignParticipationScalarWhereInput | CampaignParticipationScalarWhereInput[]
    id?: StringFilter<"CampaignParticipation"> | string
    userId?: StringFilter<"CampaignParticipation"> | string
    campaignId?: StringFilter<"CampaignParticipation"> | string
    joinedAt?: DateTimeFilter<"CampaignParticipation"> | Date | string
    smartLinkId?: StringNullableFilter<"CampaignParticipation"> | string | null
  }

  export type SmartLinkUpsertWithWhereUniqueWithoutUserInput = {
    where: SmartLinkWhereUniqueInput
    update: XOR<SmartLinkUpdateWithoutUserInput, SmartLinkUncheckedUpdateWithoutUserInput>
    create: XOR<SmartLinkCreateWithoutUserInput, SmartLinkUncheckedCreateWithoutUserInput>
  }

  export type SmartLinkUpdateWithWhereUniqueWithoutUserInput = {
    where: SmartLinkWhereUniqueInput
    data: XOR<SmartLinkUpdateWithoutUserInput, SmartLinkUncheckedUpdateWithoutUserInput>
  }

  export type SmartLinkUpdateManyWithWhereWithoutUserInput = {
    where: SmartLinkScalarWhereInput
    data: XOR<SmartLinkUpdateManyMutationInput, SmartLinkUncheckedUpdateManyWithoutUserInput>
  }

  export type SmartLinkScalarWhereInput = {
    AND?: SmartLinkScalarWhereInput | SmartLinkScalarWhereInput[]
    OR?: SmartLinkScalarWhereInput[]
    NOT?: SmartLinkScalarWhereInput | SmartLinkScalarWhereInput[]
    id?: StringFilter<"SmartLink"> | string
    slug?: StringFilter<"SmartLink"> | string
    userId?: StringFilter<"SmartLink"> | string
    campaignId?: StringFilter<"SmartLink"> | string
    originalUrl?: StringFilter<"SmartLink"> | string
    clickCount?: IntFilter<"SmartLink"> | number
    uniqueClickCount?: IntFilter<"SmartLink"> | number
    conversionCount?: IntFilter<"SmartLink"> | number
    isActive?: BoolFilter<"SmartLink"> | boolean
    isExpired?: BoolFilter<"SmartLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"SmartLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SmartLink"> | Date | string
    updatedAt?: DateTimeFilter<"SmartLink"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutInviterInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutInviterInput, ReferralUncheckedUpdateWithoutInviterInput>
    create: XOR<ReferralCreateWithoutInviterInput, ReferralUncheckedCreateWithoutInviterInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutInviterInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutInviterInput, ReferralUncheckedUpdateWithoutInviterInput>
  }

  export type ReferralUpdateManyWithWhereWithoutInviterInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutInviterInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    inviterId?: StringFilter<"Referral"> | string
    inviteeId?: StringFilter<"Referral"> | string
    campaignId?: StringFilter<"Referral"> | string
    slug?: StringFilter<"Referral"> | string
    createdAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutInviteeInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutInviteeInput, ReferralUncheckedUpdateWithoutInviteeInput>
    create: XOR<ReferralCreateWithoutInviteeInput, ReferralUncheckedCreateWithoutInviteeInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutInviteeInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutInviteeInput, ReferralUncheckedUpdateWithoutInviteeInput>
  }

  export type ReferralUpdateManyWithWhereWithoutInviteeInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutInviteeInput>
  }

  export type DonationUpsertWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
  }

  export type DonationUpdateManyWithWhereWithoutUserInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutUserInput>
  }

  export type DonationScalarWhereInput = {
    AND?: DonationScalarWhereInput | DonationScalarWhereInput[]
    OR?: DonationScalarWhereInput[]
    NOT?: DonationScalarWhereInput | DonationScalarWhereInput[]
    id?: StringFilter<"Donation"> | string
    userId?: StringFilter<"Donation"> | string
    campaignId?: StringFilter<"Donation"> | string
    amount?: DecimalFilter<"Donation"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Donation"> | string
    status?: EnumDonationStatusFilter<"Donation"> | $Enums.DonationStatus
    reference?: StringFilter<"Donation"> | string
    bankAccountId?: StringNullableFilter<"Donation"> | string | null
    proofScreenshotUrl?: StringNullableFilter<"Donation"> | string | null
    verifiedById?: StringNullableFilter<"Donation"> | string | null
    verifiedAt?: DateTimeNullableFilter<"Donation"> | Date | string | null
    notes?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
  }

  export type DonationUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutVerifiedByInput, DonationUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<DonationCreateWithoutVerifiedByInput, DonationUncheckedCreateWithoutVerifiedByInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutVerifiedByInput, DonationUncheckedUpdateWithoutVerifiedByInput>
  }

  export type DonationUpdateManyWithWhereWithoutVerifiedByInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type PointsLedgerEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: PointsLedgerEntryWhereUniqueInput
    update: XOR<PointsLedgerEntryUpdateWithoutUserInput, PointsLedgerEntryUncheckedUpdateWithoutUserInput>
    create: XOR<PointsLedgerEntryCreateWithoutUserInput, PointsLedgerEntryUncheckedCreateWithoutUserInput>
  }

  export type PointsLedgerEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: PointsLedgerEntryWhereUniqueInput
    data: XOR<PointsLedgerEntryUpdateWithoutUserInput, PointsLedgerEntryUncheckedUpdateWithoutUserInput>
  }

  export type PointsLedgerEntryUpdateManyWithWhereWithoutUserInput = {
    where: PointsLedgerEntryScalarWhereInput
    data: XOR<PointsLedgerEntryUpdateManyMutationInput, PointsLedgerEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type PointsLedgerEntryScalarWhereInput = {
    AND?: PointsLedgerEntryScalarWhereInput | PointsLedgerEntryScalarWhereInput[]
    OR?: PointsLedgerEntryScalarWhereInput[]
    NOT?: PointsLedgerEntryScalarWhereInput | PointsLedgerEntryScalarWhereInput[]
    id?: StringFilter<"PointsLedgerEntry"> | string
    userId?: StringFilter<"PointsLedgerEntry"> | string
    campaignId?: StringNullableFilter<"PointsLedgerEntry"> | string | null
    type?: EnumPointTypeFilter<"PointsLedgerEntry"> | $Enums.PointType
    value?: IntFilter<"PointsLedgerEntry"> | number
    description?: StringFilter<"PointsLedgerEntry"> | string
    referenceId?: StringNullableFilter<"PointsLedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"PointsLedgerEntry"> | Date | string
  }

  export type LeaderboardSnapshotUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardSnapshotWhereUniqueInput
    update: XOR<LeaderboardSnapshotUpdateWithoutUserInput, LeaderboardSnapshotUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardSnapshotCreateWithoutUserInput, LeaderboardSnapshotUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardSnapshotUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardSnapshotWhereUniqueInput
    data: XOR<LeaderboardSnapshotUpdateWithoutUserInput, LeaderboardSnapshotUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardSnapshotUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardSnapshotScalarWhereInput
    data: XOR<LeaderboardSnapshotUpdateManyMutationInput, LeaderboardSnapshotUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaderboardSnapshotScalarWhereInput = {
    AND?: LeaderboardSnapshotScalarWhereInput | LeaderboardSnapshotScalarWhereInput[]
    OR?: LeaderboardSnapshotScalarWhereInput[]
    NOT?: LeaderboardSnapshotScalarWhereInput | LeaderboardSnapshotScalarWhereInput[]
    id?: StringFilter<"LeaderboardSnapshot"> | string
    userId?: StringFilter<"LeaderboardSnapshot"> | string
    campaignId?: StringNullableFilter<"LeaderboardSnapshot"> | string | null
    period?: StringFilter<"LeaderboardSnapshot"> | string
    rank?: IntFilter<"LeaderboardSnapshot"> | number
    score?: IntFilter<"LeaderboardSnapshot"> | number
    createdAt?: DateTimeFilter<"LeaderboardSnapshot"> | Date | string
  }

  export type TrustScoreUpsertWithoutUserInput = {
    update: XOR<TrustScoreUpdateWithoutUserInput, TrustScoreUncheckedUpdateWithoutUserInput>
    create: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    where?: TrustScoreWhereInput
  }

  export type TrustScoreUpdateToOneWithWhereWithoutUserInput = {
    where?: TrustScoreWhereInput
    data: XOR<TrustScoreUpdateWithoutUserInput, TrustScoreUncheckedUpdateWithoutUserInput>
  }

  export type TrustScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    flags?: TrustScoreUpdateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    flags?: TrustScoreUpdateflagsInput | $Enums.TrustFlag[]
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: AppNotificationWhereUniqueInput
    update: XOR<AppNotificationUpdateWithoutUserInput, AppNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<AppNotificationCreateWithoutUserInput, AppNotificationUncheckedCreateWithoutUserInput>
  }

  export type AppNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: AppNotificationWhereUniqueInput
    data: XOR<AppNotificationUpdateWithoutUserInput, AppNotificationUncheckedUpdateWithoutUserInput>
  }

  export type AppNotificationUpdateManyWithWhereWithoutUserInput = {
    where: AppNotificationScalarWhereInput
    data: XOR<AppNotificationUpdateManyMutationInput, AppNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type AppNotificationScalarWhereInput = {
    AND?: AppNotificationScalarWhereInput | AppNotificationScalarWhereInput[]
    OR?: AppNotificationScalarWhereInput[]
    NOT?: AppNotificationScalarWhereInput | AppNotificationScalarWhereInput[]
    id?: StringFilter<"AppNotification"> | string
    userId?: StringFilter<"AppNotification"> | string
    type?: EnumNotificationTypeFilter<"AppNotification"> | $Enums.NotificationType
    title?: StringFilter<"AppNotification"> | string
    body?: StringFilter<"AppNotification"> | string
    isRead?: BoolFilter<"AppNotification"> | boolean
    link?: StringNullableFilter<"AppNotification"> | string | null
    createdAt?: DateTimeFilter<"AppNotification"> | Date | string
  }

  export type ViewProofUpsertWithWhereUniqueWithoutUserInput = {
    where: ViewProofWhereUniqueInput
    update: XOR<ViewProofUpdateWithoutUserInput, ViewProofUncheckedUpdateWithoutUserInput>
    create: XOR<ViewProofCreateWithoutUserInput, ViewProofUncheckedCreateWithoutUserInput>
  }

  export type ViewProofUpdateWithWhereUniqueWithoutUserInput = {
    where: ViewProofWhereUniqueInput
    data: XOR<ViewProofUpdateWithoutUserInput, ViewProofUncheckedUpdateWithoutUserInput>
  }

  export type ViewProofUpdateManyWithWhereWithoutUserInput = {
    where: ViewProofScalarWhereInput
    data: XOR<ViewProofUpdateManyMutationInput, ViewProofUncheckedUpdateManyWithoutUserInput>
  }

  export type ViewProofScalarWhereInput = {
    AND?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
    OR?: ViewProofScalarWhereInput[]
    NOT?: ViewProofScalarWhereInput | ViewProofScalarWhereInput[]
    id?: StringFilter<"ViewProof"> | string
    userId?: StringFilter<"ViewProof"> | string
    campaignId?: StringFilter<"ViewProof"> | string
    smartLinkId?: StringFilter<"ViewProof"> | string
    platform?: EnumSocialPlatformFilter<"ViewProof"> | $Enums.SocialPlatform
    screenshotUrl?: StringFilter<"ViewProof"> | string
    status?: EnumViewProofStatusFilter<"ViewProof"> | $Enums.ViewProofStatus
    reviewedById?: StringNullableFilter<"ViewProof"> | string | null
    reviewedAt?: DateTimeNullableFilter<"ViewProof"> | Date | string | null
    notes?: StringNullableFilter<"ViewProof"> | string | null
    createdAt?: DateTimeFilter<"ViewProof"> | Date | string
    updatedAt?: DateTimeFilter<"ViewProof"> | Date | string
  }

  export type ViewProofUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: ViewProofWhereUniqueInput
    update: XOR<ViewProofUpdateWithoutReviewedByInput, ViewProofUncheckedUpdateWithoutReviewedByInput>
    create: XOR<ViewProofCreateWithoutReviewedByInput, ViewProofUncheckedCreateWithoutReviewedByInput>
  }

  export type ViewProofUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: ViewProofWhereUniqueInput
    data: XOR<ViewProofUpdateWithoutReviewedByInput, ViewProofUncheckedUpdateWithoutReviewedByInput>
  }

  export type ViewProofUpdateManyWithWhereWithoutReviewedByInput = {
    where: ViewProofScalarWhereInput
    data: XOR<ViewProofUpdateManyMutationInput, ViewProofUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type TeamInviteLinkUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TeamInviteLinkWhereUniqueInput
    update: XOR<TeamInviteLinkUpdateWithoutCreatedByInput, TeamInviteLinkUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TeamInviteLinkCreateWithoutCreatedByInput, TeamInviteLinkUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamInviteLinkUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TeamInviteLinkWhereUniqueInput
    data: XOR<TeamInviteLinkUpdateWithoutCreatedByInput, TeamInviteLinkUncheckedUpdateWithoutCreatedByInput>
  }

  export type TeamInviteLinkUpdateManyWithWhereWithoutCreatedByInput = {
    where: TeamInviteLinkScalarWhereInput
    data: XOR<TeamInviteLinkUpdateManyMutationInput, TeamInviteLinkUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TeamInviteLinkScalarWhereInput = {
    AND?: TeamInviteLinkScalarWhereInput | TeamInviteLinkScalarWhereInput[]
    OR?: TeamInviteLinkScalarWhereInput[]
    NOT?: TeamInviteLinkScalarWhereInput | TeamInviteLinkScalarWhereInput[]
    id?: StringFilter<"TeamInviteLink"> | string
    token?: StringFilter<"TeamInviteLink"> | string
    teamId?: StringFilter<"TeamInviteLink"> | string
    targetRole?: StringFilter<"TeamInviteLink"> | string
    createdById?: StringFilter<"TeamInviteLink"> | string
    usedCount?: IntFilter<"TeamInviteLink"> | number
    maxUses?: IntFilter<"TeamInviteLink"> | number
    expiresAt?: DateTimeNullableFilter<"TeamInviteLink"> | Date | string | null
    isActive?: BoolFilter<"TeamInviteLink"> | boolean
    createdAt?: DateTimeFilter<"TeamInviteLink"> | Date | string
  }

  export type CampaignAuditEventUpsertWithWhereUniqueWithoutActorInput = {
    where: CampaignAuditEventWhereUniqueInput
    update: XOR<CampaignAuditEventUpdateWithoutActorInput, CampaignAuditEventUncheckedUpdateWithoutActorInput>
    create: XOR<CampaignAuditEventCreateWithoutActorInput, CampaignAuditEventUncheckedCreateWithoutActorInput>
  }

  export type CampaignAuditEventUpdateWithWhereUniqueWithoutActorInput = {
    where: CampaignAuditEventWhereUniqueInput
    data: XOR<CampaignAuditEventUpdateWithoutActorInput, CampaignAuditEventUncheckedUpdateWithoutActorInput>
  }

  export type CampaignAuditEventUpdateManyWithWhereWithoutActorInput = {
    where: CampaignAuditEventScalarWhereInput
    data: XOR<CampaignAuditEventUpdateManyMutationInput, CampaignAuditEventUncheckedUpdateManyWithoutActorInput>
  }

  export type CampaignAuditEventScalarWhereInput = {
    AND?: CampaignAuditEventScalarWhereInput | CampaignAuditEventScalarWhereInput[]
    OR?: CampaignAuditEventScalarWhereInput[]
    NOT?: CampaignAuditEventScalarWhereInput | CampaignAuditEventScalarWhereInput[]
    id?: StringFilter<"CampaignAuditEvent"> | string
    campaignId?: StringFilter<"CampaignAuditEvent"> | string
    actorId?: StringFilter<"CampaignAuditEvent"> | string
    actorRole?: StringFilter<"CampaignAuditEvent"> | string
    eventType?: EnumCampaignAuditEventTypeFilter<"CampaignAuditEvent"> | $Enums.CampaignAuditEventType
    before?: JsonNullableFilter<"CampaignAuditEvent">
    after?: JsonNullableFilter<"CampaignAuditEvent">
    note?: StringNullableFilter<"CampaignAuditEvent"> | string | null
    createdAt?: DateTimeFilter<"CampaignAuditEvent"> | Date | string
  }

  export type UserCreateWithoutCreatedCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCreatedCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCreatedCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
  }

  export type CampaignCreateWithoutSubCampaignsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSubCampaignsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSubCampaignsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
  }

  export type CampaignCreateWithoutParentCampaignInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutParentCampaignInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutParentCampaignInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput>
  }

  export type CampaignCreateManyParentCampaignInputEnvelope = {
    data: CampaignCreateManyParentCampaignInput | CampaignCreateManyParentCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignParticipationCreateWithoutCampaignInput = {
    id?: string
    joinedAt?: Date | string
    smartLinkId?: string | null
    user: UserCreateNestedOneWithoutParticipationsInput
  }

  export type CampaignParticipationUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    smartLinkId?: string | null
  }

  export type CampaignParticipationCreateOrConnectWithoutCampaignInput = {
    where: CampaignParticipationWhereUniqueInput
    create: XOR<CampaignParticipationCreateWithoutCampaignInput, CampaignParticipationUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignParticipationCreateManyCampaignInputEnvelope = {
    data: CampaignParticipationCreateManyCampaignInput | CampaignParticipationCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type SmartLinkCreateWithoutCampaignInput = {
    id?: string
    slug: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSmartLinksInput
    linkEvents?: LinkEventCreateNestedManyWithoutSmartLinkInput
  }

  export type SmartLinkUncheckedCreateWithoutCampaignInput = {
    id?: string
    slug: string
    userId: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkEvents?: LinkEventUncheckedCreateNestedManyWithoutSmartLinkInput
  }

  export type SmartLinkCreateOrConnectWithoutCampaignInput = {
    where: SmartLinkWhereUniqueInput
    create: XOR<SmartLinkCreateWithoutCampaignInput, SmartLinkUncheckedCreateWithoutCampaignInput>
  }

  export type SmartLinkCreateManyCampaignInputEnvelope = {
    data: SmartLinkCreateManyCampaignInput | SmartLinkCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutCampaignInput = {
    id?: string
    slug: string
    createdAt?: Date | string
    inviter: UserCreateNestedOneWithoutReferralsGivenInput
    invitee: UserCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateWithoutCampaignInput = {
    id?: string
    inviterId: string
    inviteeId: string
    slug: string
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutCampaignInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutCampaignInput, ReferralUncheckedCreateWithoutCampaignInput>
  }

  export type ReferralCreateManyCampaignInputEnvelope = {
    data: ReferralCreateManyCampaignInput | ReferralCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type DonationCreateWithoutCampaignInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDonationsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedDonationsInput
  }

  export type DonationUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateOrConnectWithoutCampaignInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutCampaignInput, DonationUncheckedCreateWithoutCampaignInput>
  }

  export type DonationCreateManyCampaignInputEnvelope = {
    data: DonationCreateManyCampaignInput | DonationCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type PointsLedgerEntryCreateWithoutCampaignInput = {
    id?: string
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPointsLedgerInput
  }

  export type PointsLedgerEntryUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
  }

  export type PointsLedgerEntryCreateOrConnectWithoutCampaignInput = {
    where: PointsLedgerEntryWhereUniqueInput
    create: XOR<PointsLedgerEntryCreateWithoutCampaignInput, PointsLedgerEntryUncheckedCreateWithoutCampaignInput>
  }

  export type PointsLedgerEntryCreateManyCampaignInputEnvelope = {
    data: PointsLedgerEntryCreateManyCampaignInput | PointsLedgerEntryCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardSnapshotCreateWithoutCampaignInput = {
    id?: string
    period: string
    rank: number
    score: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type LeaderboardSnapshotUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    period: string
    rank: number
    score: number
    createdAt?: Date | string
  }

  export type LeaderboardSnapshotCreateOrConnectWithoutCampaignInput = {
    where: LeaderboardSnapshotWhereUniqueInput
    create: XOR<LeaderboardSnapshotCreateWithoutCampaignInput, LeaderboardSnapshotUncheckedCreateWithoutCampaignInput>
  }

  export type LeaderboardSnapshotCreateManyCampaignInputEnvelope = {
    data: LeaderboardSnapshotCreateManyCampaignInput | LeaderboardSnapshotCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ViewProofCreateWithoutCampaignInput = {
    id?: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutViewProofsInput
    reviewedBy?: UserCreateNestedOneWithoutReviewedProofsInput
  }

  export type ViewProofUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewProofCreateOrConnectWithoutCampaignInput = {
    where: ViewProofWhereUniqueInput
    create: XOR<ViewProofCreateWithoutCampaignInput, ViewProofUncheckedCreateWithoutCampaignInput>
  }

  export type ViewProofCreateManyCampaignInputEnvelope = {
    data: ViewProofCreateManyCampaignInput | ViewProofCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignAuditEventCreateWithoutCampaignInput = {
    id?: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    actor: UserCreateNestedOneWithoutAuditEventsInput
  }

  export type CampaignAuditEventUncheckedCreateWithoutCampaignInput = {
    id?: string
    actorId: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type CampaignAuditEventCreateOrConnectWithoutCampaignInput = {
    where: CampaignAuditEventWhereUniqueInput
    create: XOR<CampaignAuditEventCreateWithoutCampaignInput, CampaignAuditEventUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAuditEventCreateManyCampaignInputEnvelope = {
    data: CampaignAuditEventCreateManyCampaignInput | CampaignAuditEventCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedCampaignsInput = {
    update: XOR<UserUpdateWithoutCreatedCampaignsInput, UserUncheckedUpdateWithoutCreatedCampaignsInput>
    create: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCampaignsInput, UserUncheckedUpdateWithoutCreatedCampaignsInput>
  }

  export type UserUpdateWithoutCreatedCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutSubCampaignsInput = {
    update: XOR<CampaignUpdateWithoutSubCampaignsInput, CampaignUncheckedUpdateWithoutSubCampaignsInput>
    create: XOR<CampaignCreateWithoutSubCampaignsInput, CampaignUncheckedCreateWithoutSubCampaignsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSubCampaignsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSubCampaignsInput, CampaignUncheckedUpdateWithoutSubCampaignsInput>
  }

  export type CampaignUpdateWithoutSubCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSubCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutParentCampaignInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutParentCampaignInput, CampaignUncheckedUpdateWithoutParentCampaignInput>
    create: XOR<CampaignCreateWithoutParentCampaignInput, CampaignUncheckedCreateWithoutParentCampaignInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutParentCampaignInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutParentCampaignInput, CampaignUncheckedUpdateWithoutParentCampaignInput>
  }

  export type CampaignUpdateManyWithWhereWithoutParentCampaignInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutParentCampaignInput>
  }

  export type CampaignParticipationUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignParticipationWhereUniqueInput
    update: XOR<CampaignParticipationUpdateWithoutCampaignInput, CampaignParticipationUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignParticipationCreateWithoutCampaignInput, CampaignParticipationUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignParticipationUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignParticipationWhereUniqueInput
    data: XOR<CampaignParticipationUpdateWithoutCampaignInput, CampaignParticipationUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignParticipationUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignParticipationScalarWhereInput
    data: XOR<CampaignParticipationUpdateManyMutationInput, CampaignParticipationUncheckedUpdateManyWithoutCampaignInput>
  }

  export type SmartLinkUpsertWithWhereUniqueWithoutCampaignInput = {
    where: SmartLinkWhereUniqueInput
    update: XOR<SmartLinkUpdateWithoutCampaignInput, SmartLinkUncheckedUpdateWithoutCampaignInput>
    create: XOR<SmartLinkCreateWithoutCampaignInput, SmartLinkUncheckedCreateWithoutCampaignInput>
  }

  export type SmartLinkUpdateWithWhereUniqueWithoutCampaignInput = {
    where: SmartLinkWhereUniqueInput
    data: XOR<SmartLinkUpdateWithoutCampaignInput, SmartLinkUncheckedUpdateWithoutCampaignInput>
  }

  export type SmartLinkUpdateManyWithWhereWithoutCampaignInput = {
    where: SmartLinkScalarWhereInput
    data: XOR<SmartLinkUpdateManyMutationInput, SmartLinkUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ReferralUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutCampaignInput, ReferralUncheckedUpdateWithoutCampaignInput>
    create: XOR<ReferralCreateWithoutCampaignInput, ReferralUncheckedCreateWithoutCampaignInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutCampaignInput, ReferralUncheckedUpdateWithoutCampaignInput>
  }

  export type ReferralUpdateManyWithWhereWithoutCampaignInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutCampaignInput>
  }

  export type DonationUpsertWithWhereUniqueWithoutCampaignInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutCampaignInput, DonationUncheckedUpdateWithoutCampaignInput>
    create: XOR<DonationCreateWithoutCampaignInput, DonationUncheckedCreateWithoutCampaignInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutCampaignInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutCampaignInput, DonationUncheckedUpdateWithoutCampaignInput>
  }

  export type DonationUpdateManyWithWhereWithoutCampaignInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutCampaignInput>
  }

  export type PointsLedgerEntryUpsertWithWhereUniqueWithoutCampaignInput = {
    where: PointsLedgerEntryWhereUniqueInput
    update: XOR<PointsLedgerEntryUpdateWithoutCampaignInput, PointsLedgerEntryUncheckedUpdateWithoutCampaignInput>
    create: XOR<PointsLedgerEntryCreateWithoutCampaignInput, PointsLedgerEntryUncheckedCreateWithoutCampaignInput>
  }

  export type PointsLedgerEntryUpdateWithWhereUniqueWithoutCampaignInput = {
    where: PointsLedgerEntryWhereUniqueInput
    data: XOR<PointsLedgerEntryUpdateWithoutCampaignInput, PointsLedgerEntryUncheckedUpdateWithoutCampaignInput>
  }

  export type PointsLedgerEntryUpdateManyWithWhereWithoutCampaignInput = {
    where: PointsLedgerEntryScalarWhereInput
    data: XOR<PointsLedgerEntryUpdateManyMutationInput, PointsLedgerEntryUncheckedUpdateManyWithoutCampaignInput>
  }

  export type LeaderboardSnapshotUpsertWithWhereUniqueWithoutCampaignInput = {
    where: LeaderboardSnapshotWhereUniqueInput
    update: XOR<LeaderboardSnapshotUpdateWithoutCampaignInput, LeaderboardSnapshotUncheckedUpdateWithoutCampaignInput>
    create: XOR<LeaderboardSnapshotCreateWithoutCampaignInput, LeaderboardSnapshotUncheckedCreateWithoutCampaignInput>
  }

  export type LeaderboardSnapshotUpdateWithWhereUniqueWithoutCampaignInput = {
    where: LeaderboardSnapshotWhereUniqueInput
    data: XOR<LeaderboardSnapshotUpdateWithoutCampaignInput, LeaderboardSnapshotUncheckedUpdateWithoutCampaignInput>
  }

  export type LeaderboardSnapshotUpdateManyWithWhereWithoutCampaignInput = {
    where: LeaderboardSnapshotScalarWhereInput
    data: XOR<LeaderboardSnapshotUpdateManyMutationInput, LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ViewProofUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ViewProofWhereUniqueInput
    update: XOR<ViewProofUpdateWithoutCampaignInput, ViewProofUncheckedUpdateWithoutCampaignInput>
    create: XOR<ViewProofCreateWithoutCampaignInput, ViewProofUncheckedCreateWithoutCampaignInput>
  }

  export type ViewProofUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ViewProofWhereUniqueInput
    data: XOR<ViewProofUpdateWithoutCampaignInput, ViewProofUncheckedUpdateWithoutCampaignInput>
  }

  export type ViewProofUpdateManyWithWhereWithoutCampaignInput = {
    where: ViewProofScalarWhereInput
    data: XOR<ViewProofUpdateManyMutationInput, ViewProofUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignAuditEventUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignAuditEventWhereUniqueInput
    update: XOR<CampaignAuditEventUpdateWithoutCampaignInput, CampaignAuditEventUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignAuditEventCreateWithoutCampaignInput, CampaignAuditEventUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAuditEventUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignAuditEventWhereUniqueInput
    data: XOR<CampaignAuditEventUpdateWithoutCampaignInput, CampaignAuditEventUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignAuditEventUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignAuditEventScalarWhereInput
    data: XOR<CampaignAuditEventUpdateManyMutationInput, CampaignAuditEventUncheckedUpdateManyWithoutCampaignInput>
  }

  export type UserCreateWithoutParticipationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutParticipationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutParticipationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
  }

  export type CampaignCreateWithoutParticipationsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutParticipationsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutParticipationsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutParticipationsInput, CampaignUncheckedCreateWithoutParticipationsInput>
  }

  export type UserUpsertWithoutParticipationsInput = {
    update: XOR<UserUpdateWithoutParticipationsInput, UserUncheckedUpdateWithoutParticipationsInput>
    create: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParticipationsInput, UserUncheckedUpdateWithoutParticipationsInput>
  }

  export type UserUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutParticipationsInput = {
    update: XOR<CampaignUpdateWithoutParticipationsInput, CampaignUncheckedUpdateWithoutParticipationsInput>
    create: XOR<CampaignCreateWithoutParticipationsInput, CampaignUncheckedCreateWithoutParticipationsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutParticipationsInput, CampaignUncheckedUpdateWithoutParticipationsInput>
  }

  export type CampaignUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutSmartLinksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutSmartLinksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutSmartLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSmartLinksInput, UserUncheckedCreateWithoutSmartLinksInput>
  }

  export type CampaignCreateWithoutSmartLinksInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSmartLinksInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSmartLinksInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSmartLinksInput, CampaignUncheckedCreateWithoutSmartLinksInput>
  }

  export type LinkEventCreateWithoutSmartLinkInput = {
    id?: string
    smartLinkId?: string | null
    slug?: string | null
    eventType: $Enums.LinkEventType
    type?: $Enums.LinkEventType | null
    userId?: string | null
    ipAddress?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    referer?: string | null
    country?: string | null
    createdAt?: Date | string
  }

  export type LinkEventUncheckedCreateWithoutSmartLinkInput = {
    id?: string
    smartLinkId?: string | null
    slug?: string | null
    eventType: $Enums.LinkEventType
    type?: $Enums.LinkEventType | null
    userId?: string | null
    ipAddress?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    referer?: string | null
    country?: string | null
    createdAt?: Date | string
  }

  export type LinkEventCreateOrConnectWithoutSmartLinkInput = {
    where: LinkEventWhereUniqueInput
    create: XOR<LinkEventCreateWithoutSmartLinkInput, LinkEventUncheckedCreateWithoutSmartLinkInput>
  }

  export type LinkEventCreateManySmartLinkInputEnvelope = {
    data: LinkEventCreateManySmartLinkInput | LinkEventCreateManySmartLinkInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSmartLinksInput = {
    update: XOR<UserUpdateWithoutSmartLinksInput, UserUncheckedUpdateWithoutSmartLinksInput>
    create: XOR<UserCreateWithoutSmartLinksInput, UserUncheckedCreateWithoutSmartLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSmartLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSmartLinksInput, UserUncheckedUpdateWithoutSmartLinksInput>
  }

  export type UserUpdateWithoutSmartLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutSmartLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutSmartLinksInput = {
    update: XOR<CampaignUpdateWithoutSmartLinksInput, CampaignUncheckedUpdateWithoutSmartLinksInput>
    create: XOR<CampaignCreateWithoutSmartLinksInput, CampaignUncheckedCreateWithoutSmartLinksInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSmartLinksInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSmartLinksInput, CampaignUncheckedUpdateWithoutSmartLinksInput>
  }

  export type CampaignUpdateWithoutSmartLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSmartLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type LinkEventUpsertWithWhereUniqueWithoutSmartLinkInput = {
    where: LinkEventWhereUniqueInput
    update: XOR<LinkEventUpdateWithoutSmartLinkInput, LinkEventUncheckedUpdateWithoutSmartLinkInput>
    create: XOR<LinkEventCreateWithoutSmartLinkInput, LinkEventUncheckedCreateWithoutSmartLinkInput>
  }

  export type LinkEventUpdateWithWhereUniqueWithoutSmartLinkInput = {
    where: LinkEventWhereUniqueInput
    data: XOR<LinkEventUpdateWithoutSmartLinkInput, LinkEventUncheckedUpdateWithoutSmartLinkInput>
  }

  export type LinkEventUpdateManyWithWhereWithoutSmartLinkInput = {
    where: LinkEventScalarWhereInput
    data: XOR<LinkEventUpdateManyMutationInput, LinkEventUncheckedUpdateManyWithoutSmartLinkInput>
  }

  export type LinkEventScalarWhereInput = {
    AND?: LinkEventScalarWhereInput | LinkEventScalarWhereInput[]
    OR?: LinkEventScalarWhereInput[]
    NOT?: LinkEventScalarWhereInput | LinkEventScalarWhereInput[]
    id?: StringFilter<"LinkEvent"> | string
    linkId?: StringFilter<"LinkEvent"> | string
    smartLinkId?: StringNullableFilter<"LinkEvent"> | string | null
    slug?: StringNullableFilter<"LinkEvent"> | string | null
    eventType?: EnumLinkEventTypeFilter<"LinkEvent"> | $Enums.LinkEventType
    type?: EnumLinkEventTypeNullableFilter<"LinkEvent"> | $Enums.LinkEventType | null
    userId?: StringNullableFilter<"LinkEvent"> | string | null
    ipAddress?: StringNullableFilter<"LinkEvent"> | string | null
    ipHash?: StringNullableFilter<"LinkEvent"> | string | null
    userAgent?: StringNullableFilter<"LinkEvent"> | string | null
    referrer?: StringNullableFilter<"LinkEvent"> | string | null
    referer?: StringNullableFilter<"LinkEvent"> | string | null
    country?: StringNullableFilter<"LinkEvent"> | string | null
    createdAt?: DateTimeFilter<"LinkEvent"> | Date | string
  }

  export type SmartLinkCreateWithoutLinkEventsInput = {
    id?: string
    slug: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSmartLinksInput
    campaign: CampaignCreateNestedOneWithoutSmartLinksInput
  }

  export type SmartLinkUncheckedCreateWithoutLinkEventsInput = {
    id?: string
    slug: string
    userId: string
    campaignId: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SmartLinkCreateOrConnectWithoutLinkEventsInput = {
    where: SmartLinkWhereUniqueInput
    create: XOR<SmartLinkCreateWithoutLinkEventsInput, SmartLinkUncheckedCreateWithoutLinkEventsInput>
  }

  export type SmartLinkUpsertWithoutLinkEventsInput = {
    update: XOR<SmartLinkUpdateWithoutLinkEventsInput, SmartLinkUncheckedUpdateWithoutLinkEventsInput>
    create: XOR<SmartLinkCreateWithoutLinkEventsInput, SmartLinkUncheckedCreateWithoutLinkEventsInput>
    where?: SmartLinkWhereInput
  }

  export type SmartLinkUpdateToOneWithWhereWithoutLinkEventsInput = {
    where?: SmartLinkWhereInput
    data: XOR<SmartLinkUpdateWithoutLinkEventsInput, SmartLinkUncheckedUpdateWithoutLinkEventsInput>
  }

  export type SmartLinkUpdateWithoutLinkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSmartLinksNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutSmartLinksNestedInput
  }

  export type SmartLinkUncheckedUpdateWithoutLinkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutReferralsGivenInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutReferralsGivenInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutReferralsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
  }

  export type UserCreateWithoutReferralsReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutReferralsReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutReferralsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
  }

  export type CampaignCreateWithoutReferralsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutReferralsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutReferralsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutReferralsInput, CampaignUncheckedCreateWithoutReferralsInput>
  }

  export type UserUpsertWithoutReferralsGivenInput = {
    update: XOR<UserUpdateWithoutReferralsGivenInput, UserUncheckedUpdateWithoutReferralsGivenInput>
    create: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsGivenInput, UserUncheckedUpdateWithoutReferralsGivenInput>
  }

  export type UserUpdateWithoutReferralsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithoutReferralsReceivedInput = {
    update: XOR<UserUpdateWithoutReferralsReceivedInput, UserUncheckedUpdateWithoutReferralsReceivedInput>
    create: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsReceivedInput, UserUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type UserUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutReferralsInput = {
    update: XOR<CampaignUpdateWithoutReferralsInput, CampaignUncheckedUpdateWithoutReferralsInput>
    create: XOR<CampaignCreateWithoutReferralsInput, CampaignUncheckedCreateWithoutReferralsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutReferralsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutReferralsInput, CampaignUncheckedUpdateWithoutReferralsInput>
  }

  export type CampaignUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutDonationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutDonationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutDonationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
  }

  export type CampaignCreateWithoutDonationsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutDonationsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutDonationsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutDonationsInput, CampaignUncheckedCreateWithoutDonationsInput>
  }

  export type UserCreateWithoutVerifiedDonationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutVerifiedDonationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutVerifiedDonationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedDonationsInput, UserUncheckedCreateWithoutVerifiedDonationsInput>
  }

  export type UserUpsertWithoutDonationsInput = {
    update: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDonationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutDonationsInput = {
    update: XOR<CampaignUpdateWithoutDonationsInput, CampaignUncheckedUpdateWithoutDonationsInput>
    create: XOR<CampaignCreateWithoutDonationsInput, CampaignUncheckedCreateWithoutDonationsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutDonationsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutDonationsInput, CampaignUncheckedUpdateWithoutDonationsInput>
  }

  export type CampaignUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutVerifiedDonationsInput = {
    update: XOR<UserUpdateWithoutVerifiedDonationsInput, UserUncheckedUpdateWithoutVerifiedDonationsInput>
    create: XOR<UserCreateWithoutVerifiedDonationsInput, UserUncheckedCreateWithoutVerifiedDonationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedDonationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedDonationsInput, UserUncheckedUpdateWithoutVerifiedDonationsInput>
  }

  export type UserUpdateWithoutVerifiedDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutPointsLedgerInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPointsLedgerInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPointsLedgerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
  }

  export type CampaignCreateWithoutPointsLedgerInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutPointsLedgerInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutPointsLedgerInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutPointsLedgerInput, CampaignUncheckedCreateWithoutPointsLedgerInput>
  }

  export type UserUpsertWithoutPointsLedgerInput = {
    update: XOR<UserUpdateWithoutPointsLedgerInput, UserUncheckedUpdateWithoutPointsLedgerInput>
    create: XOR<UserCreateWithoutPointsLedgerInput, UserUncheckedCreateWithoutPointsLedgerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointsLedgerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointsLedgerInput, UserUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type UserUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutPointsLedgerInput = {
    update: XOR<CampaignUpdateWithoutPointsLedgerInput, CampaignUncheckedUpdateWithoutPointsLedgerInput>
    create: XOR<CampaignCreateWithoutPointsLedgerInput, CampaignUncheckedCreateWithoutPointsLedgerInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutPointsLedgerInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutPointsLedgerInput, CampaignUncheckedUpdateWithoutPointsLedgerInput>
  }

  export type CampaignUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutPointsLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutLeaderboardEntriesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type CampaignCreateWithoutLeaderboardInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutLeaderboardInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutLeaderboardInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLeaderboardInput, CampaignUncheckedCreateWithoutLeaderboardInput>
  }

  export type UserUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutLeaderboardInput = {
    update: XOR<CampaignUpdateWithoutLeaderboardInput, CampaignUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<CampaignCreateWithoutLeaderboardInput, CampaignUncheckedCreateWithoutLeaderboardInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutLeaderboardInput, CampaignUncheckedUpdateWithoutLeaderboardInput>
  }

  export type CampaignUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutTrustScoreRecordInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutTrustScoreRecordInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutTrustScoreRecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrustScoreRecordInput, UserUncheckedCreateWithoutTrustScoreRecordInput>
  }

  export type UserUpsertWithoutTrustScoreRecordInput = {
    update: XOR<UserUpdateWithoutTrustScoreRecordInput, UserUncheckedUpdateWithoutTrustScoreRecordInput>
    create: XOR<UserCreateWithoutTrustScoreRecordInput, UserUncheckedCreateWithoutTrustScoreRecordInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrustScoreRecordInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrustScoreRecordInput, UserUncheckedUpdateWithoutTrustScoreRecordInput>
  }

  export type UserUpdateWithoutTrustScoreRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutTrustScoreRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutViewProofsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutViewProofsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutViewProofsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewProofsInput, UserUncheckedCreateWithoutViewProofsInput>
  }

  export type UserCreateWithoutReviewedProofsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutReviewedProofsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutReviewedProofsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedProofsInput, UserUncheckedCreateWithoutReviewedProofsInput>
  }

  export type CampaignCreateWithoutViewProofsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutViewProofsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutViewProofsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutViewProofsInput, CampaignUncheckedCreateWithoutViewProofsInput>
  }

  export type UserUpsertWithoutViewProofsInput = {
    update: XOR<UserUpdateWithoutViewProofsInput, UserUncheckedUpdateWithoutViewProofsInput>
    create: XOR<UserCreateWithoutViewProofsInput, UserUncheckedCreateWithoutViewProofsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewProofsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewProofsInput, UserUncheckedUpdateWithoutViewProofsInput>
  }

  export type UserUpdateWithoutViewProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutViewProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithoutReviewedProofsInput = {
    update: XOR<UserUpdateWithoutReviewedProofsInput, UserUncheckedUpdateWithoutReviewedProofsInput>
    create: XOR<UserCreateWithoutReviewedProofsInput, UserUncheckedCreateWithoutReviewedProofsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedProofsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedProofsInput, UserUncheckedUpdateWithoutReviewedProofsInput>
  }

  export type UserUpdateWithoutReviewedProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignUpsertWithoutViewProofsInput = {
    update: XOR<CampaignUpdateWithoutViewProofsInput, CampaignUncheckedUpdateWithoutViewProofsInput>
    create: XOR<CampaignCreateWithoutViewProofsInput, CampaignUncheckedCreateWithoutViewProofsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutViewProofsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutViewProofsInput, CampaignUncheckedUpdateWithoutViewProofsInput>
  }

  export type CampaignUpdateWithoutViewProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutViewProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type TeamCreateWithoutGroupInput = {
    id?: string
    name: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserCreateNestedManyWithoutTeamInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutGroupInput = {
    id?: string
    name: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutTeamInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutGroupInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutGroupInput, TeamUncheckedCreateWithoutGroupInput>
  }

  export type TeamCreateManyGroupInputEnvelope = {
    data: TeamCreateManyGroupInput | TeamCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithWhereUniqueWithoutGroupInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutGroupInput, TeamUncheckedUpdateWithoutGroupInput>
    create: XOR<TeamCreateWithoutGroupInput, TeamUncheckedCreateWithoutGroupInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutGroupInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutGroupInput, TeamUncheckedUpdateWithoutGroupInput>
  }

  export type TeamUpdateManyWithWhereWithoutGroupInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutGroupInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    groupId?: StringFilter<"Team"> | string
    teamLeadId?: StringNullableFilter<"Team"> | string | null
    maxMembers?: IntFilter<"Team"> | number
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type GroupCreateWithoutTeamsInput = {
    id?: string
    name: string
    description?: string | null
    maxTeams?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    description?: string | null
    maxTeams?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateOrConnectWithoutTeamsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutTeamsInput, GroupUncheckedCreateWithoutTeamsInput>
  }

  export type UserCreateWithoutTeamInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutTeamInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserCreateManyTeamInputEnvelope = {
    data: UserCreateManyTeamInput | UserCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamInviteLinkCreateWithoutTeamInput = {
    id?: string
    token: string
    targetRole: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutTeamInviteLinksInput
  }

  export type TeamInviteLinkUncheckedCreateWithoutTeamInput = {
    id?: string
    token: string
    targetRole: string
    createdById: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type TeamInviteLinkCreateOrConnectWithoutTeamInput = {
    where: TeamInviteLinkWhereUniqueInput
    create: XOR<TeamInviteLinkCreateWithoutTeamInput, TeamInviteLinkUncheckedCreateWithoutTeamInput>
  }

  export type TeamInviteLinkCreateManyTeamInputEnvelope = {
    data: TeamInviteLinkCreateManyTeamInput | TeamInviteLinkCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type GroupUpsertWithoutTeamsInput = {
    update: XOR<GroupUpdateWithoutTeamsInput, GroupUncheckedUpdateWithoutTeamsInput>
    create: XOR<GroupCreateWithoutTeamsInput, GroupUncheckedCreateWithoutTeamsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutTeamsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutTeamsInput, GroupUncheckedUpdateWithoutTeamsInput>
  }

  export type GroupUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
  }

  export type UserUpdateManyWithWhereWithoutTeamInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    profilePicture?: StringNullableFilter<"User"> | string | null
    whatsappNumber?: StringNullableFilter<"User"> | string | null
    teamId?: StringNullableFilter<"User"> | string | null
    trustScore?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    weaponsOfChoice?: EnumSocialPlatformNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type TeamInviteLinkUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamInviteLinkWhereUniqueInput
    update: XOR<TeamInviteLinkUpdateWithoutTeamInput, TeamInviteLinkUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamInviteLinkCreateWithoutTeamInput, TeamInviteLinkUncheckedCreateWithoutTeamInput>
  }

  export type TeamInviteLinkUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamInviteLinkWhereUniqueInput
    data: XOR<TeamInviteLinkUpdateWithoutTeamInput, TeamInviteLinkUncheckedUpdateWithoutTeamInput>
  }

  export type TeamInviteLinkUpdateManyWithWhereWithoutTeamInput = {
    where: TeamInviteLinkScalarWhereInput
    data: XOR<TeamInviteLinkUpdateManyMutationInput, TeamInviteLinkUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutTeamInviteLinksInput = {
    id?: string
    name: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutTeamsInput
    members?: UserCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamInviteLinksInput = {
    id?: string
    name: string
    groupId: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamInviteLinksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamInviteLinksInput, TeamUncheckedCreateWithoutTeamInviteLinksInput>
  }

  export type UserCreateWithoutTeamInviteLinksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    auditEvents?: CampaignAuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutTeamInviteLinksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    auditEvents?: CampaignAuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutTeamInviteLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamInviteLinksInput, UserUncheckedCreateWithoutTeamInviteLinksInput>
  }

  export type TeamUpsertWithoutTeamInviteLinksInput = {
    update: XOR<TeamUpdateWithoutTeamInviteLinksInput, TeamUncheckedUpdateWithoutTeamInviteLinksInput>
    create: XOR<TeamCreateWithoutTeamInviteLinksInput, TeamUncheckedCreateWithoutTeamInviteLinksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTeamInviteLinksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTeamInviteLinksInput, TeamUncheckedUpdateWithoutTeamInviteLinksInput>
  }

  export type TeamUpdateWithoutTeamInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutTeamsNestedInput
    members?: UserUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamInviteLinksInput = {
    update: XOR<UserUpdateWithoutTeamInviteLinksInput, UserUncheckedUpdateWithoutTeamInviteLinksInput>
    create: XOR<UserCreateWithoutTeamInviteLinksInput, UserUncheckedCreateWithoutTeamInviteLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamInviteLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamInviteLinksInput, UserUncheckedUpdateWithoutTeamInviteLinksInput>
  }

  export type UserUpdateWithoutTeamInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignCreateWithoutAuditEventsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCampaignsInput
    parentCampaign?: CampaignCreateNestedOneWithoutSubCampaignsInput
    subCampaigns?: CampaignCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkCreateNestedManyWithoutCampaignInput
    referrals?: ReferralCreateNestedManyWithoutCampaignInput
    donations?: DonationCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAuditEventsInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subCampaigns?: CampaignUncheckedCreateNestedManyWithoutParentCampaignInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutCampaignInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutCampaignInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutCampaignInput
    donations?: DonationUncheckedCreateNestedManyWithoutCampaignInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutCampaignInput
    leaderboard?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutCampaignInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAuditEventsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAuditEventsInput, CampaignUncheckedCreateWithoutAuditEventsInput>
  }

  export type UserCreateWithoutAuditEventsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutMembersInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralCreateNestedManyWithoutInviteeInput
    donations?: DonationCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreCreateNestedOneWithoutUserInput
    notifications?: AppNotificationCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAuditEventsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    teamId?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatorInput
    participations?: CampaignParticipationUncheckedCreateNestedManyWithoutUserInput
    smartLinks?: SmartLinkUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutInviterInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutInviteeInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    verifiedDonations?: DonationUncheckedCreateNestedManyWithoutVerifiedByInput
    pointsLedger?: PointsLedgerEntryUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedCreateNestedManyWithoutUserInput
    trustScoreRecord?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    notifications?: AppNotificationUncheckedCreateNestedManyWithoutUserInput
    viewProofs?: ViewProofUncheckedCreateNestedManyWithoutUserInput
    reviewedProofs?: ViewProofUncheckedCreateNestedManyWithoutReviewedByInput
    teamInviteLinks?: TeamInviteLinkUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAuditEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
  }

  export type CampaignUpsertWithoutAuditEventsInput = {
    update: XOR<CampaignUpdateWithoutAuditEventsInput, CampaignUncheckedUpdateWithoutAuditEventsInput>
    create: XOR<CampaignCreateWithoutAuditEventsInput, CampaignUncheckedCreateWithoutAuditEventsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAuditEventsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAuditEventsInput, CampaignUncheckedUpdateWithoutAuditEventsInput>
  }

  export type CampaignUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutAuditEventsInput = {
    update: XOR<UserUpdateWithoutAuditEventsInput, UserUncheckedUpdateWithoutAuditEventsInput>
    create: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditEventsInput, UserUncheckedUpdateWithoutAuditEventsInput>
  }

  export type UserUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutMembersNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CampaignCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    parentCampaignId?: string | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignParticipationCreateManyUserInput = {
    id?: string
    campaignId: string
    joinedAt?: Date | string
    smartLinkId?: string | null
  }

  export type SmartLinkCreateManyUserInput = {
    id?: string
    slug: string
    campaignId: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyInviterInput = {
    id?: string
    inviteeId: string
    campaignId: string
    slug: string
    createdAt?: Date | string
  }

  export type ReferralCreateManyInviteeInput = {
    id?: string
    inviterId: string
    campaignId: string
    slug: string
    createdAt?: Date | string
  }

  export type DonationCreateManyUserInput = {
    id?: string
    campaignId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateManyVerifiedByInput = {
    id?: string
    userId: string
    campaignId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsLedgerEntryCreateManyUserInput = {
    id?: string
    campaignId?: string | null
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
  }

  export type LeaderboardSnapshotCreateManyUserInput = {
    id?: string
    campaignId?: string | null
    period: string
    rank: number
    score: number
    createdAt?: Date | string
  }

  export type AppNotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    isRead?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type ViewProofCreateManyUserInput = {
    id?: string
    campaignId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewProofCreateManyReviewedByInput = {
    id?: string
    userId: string
    campaignId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamInviteLinkCreateManyCreatedByInput = {
    id?: string
    token: string
    teamId: string
    targetRole: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CampaignAuditEventCreateManyActorInput = {
    id?: string
    campaignId: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type CampaignUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCampaign?: CampaignUpdateOneWithoutSubCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: CampaignUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type CampaignParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SmartLinkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutSmartLinksNestedInput
    linkEvents?: LinkEventUpdateManyWithoutSmartLinkNestedInput
  }

  export type SmartLinkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkEvents?: LinkEventUncheckedUpdateManyWithoutSmartLinkNestedInput
  }

  export type SmartLinkUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitee?: UserUpdateOneRequiredWithoutReferralsReceivedNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutReferralsGivenNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutInviteeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutDonationsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedDonationsNestedInput
  }

  export type DonationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDonationsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutDonationsNestedInput
  }

  export type DonationUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutPointsLedgerNestedInput
  }

  export type PointsLedgerEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardSnapshotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutLeaderboardNestedInput
  }

  export type LeaderboardSnapshotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardSnapshotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: UserUpdateOneWithoutReviewedProofsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutViewProofsNestedInput
  }

  export type ViewProofUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutViewProofsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutViewProofsNestedInput
  }

  export type ViewProofUncheckedUpdateWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofUncheckedUpdateManyWithoutReviewedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInviteLinkUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamInviteLinksNestedInput
  }

  export type TeamInviteLinkUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInviteLinkUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAuditEventUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAuditEventsNestedInput
  }

  export type CampaignAuditEventUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAuditEventUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyParentCampaignInput = {
    id?: string
    title: string
    description: string
    content: string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: $Enums.CampaignMediaType | null
    mediaUrl?: string | null
    thumbnailUrl?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    createdById: string
    status?: $Enums.CampaignStatus
    goalType?: $Enums.GoalType | null
    goalTarget?: number | null
    goalCurrent?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetAudience?: CampaignCreatetargetAudienceInput | string[]
    publishedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaImage?: string | null
    viewCount?: number
    clickCount?: number
    shareCount?: number
    likeCount?: number | null
    participantCount?: number | null
    isMegaCampaign?: boolean | null
    bankAccountIds?: CampaignCreatebankAccountIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignParticipationCreateManyCampaignInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    smartLinkId?: string | null
  }

  export type SmartLinkCreateManyCampaignInput = {
    id?: string
    slug: string
    userId: string
    originalUrl: string
    clickCount?: number
    uniqueClickCount?: number
    conversionCount?: number
    isActive?: boolean
    isExpired?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyCampaignInput = {
    id?: string
    inviterId: string
    inviteeId: string
    slug: string
    createdAt?: Date | string
  }

  export type DonationCreateManyCampaignInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.DonationStatus
    reference: string
    bankAccountId?: string | null
    proofScreenshotUrl?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsLedgerEntryCreateManyCampaignInput = {
    id?: string
    userId: string
    type: $Enums.PointType
    value: number
    description: string
    referenceId?: string | null
    createdAt?: Date | string
  }

  export type LeaderboardSnapshotCreateManyCampaignInput = {
    id?: string
    userId: string
    period: string
    rank: number
    score: number
    createdAt?: Date | string
  }

  export type ViewProofCreateManyCampaignInput = {
    id?: string
    userId: string
    smartLinkId: string
    platform: $Enums.SocialPlatform
    screenshotUrl: string
    status?: $Enums.ViewProofStatus
    reviewedById?: string | null
    reviewedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignAuditEventCreateManyCampaignInput = {
    id?: string
    actorId: string
    actorRole: string
    eventType: $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type CampaignUpdateWithoutParentCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    subCampaigns?: CampaignUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUpdateManyWithoutCampaignNestedInput
    donations?: DonationUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutParentCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subCampaigns?: CampaignUncheckedUpdateManyWithoutParentCampaignNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutCampaignNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutCampaignNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutCampaignNestedInput
    donations?: DonationUncheckedUpdateManyWithoutCampaignNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutCampaignNestedInput
    leaderboard?: LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutCampaignNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutParentCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    mediaType?: NullableEnumCampaignMediaTypeFieldUpdateOperationsInput | $Enums.CampaignMediaType | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    goalType?: NullableEnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType | null
    goalTarget?: NullableIntFieldUpdateOperationsInput | number | null
    goalCurrent?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetAudience?: CampaignUpdatetargetAudienceInput | string[]
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaImage?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    likeCount?: NullableIntFieldUpdateOperationsInput | number | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    isMegaCampaign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bankAccountIds?: CampaignUpdatebankAccountIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignParticipationUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type CampaignParticipationUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignParticipationUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SmartLinkUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSmartLinksNestedInput
    linkEvents?: LinkEventUpdateManyWithoutSmartLinkNestedInput
  }

  export type SmartLinkUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkEvents?: LinkEventUncheckedUpdateManyWithoutSmartLinkNestedInput
  }

  export type SmartLinkUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    uniqueClickCount?: IntFieldUpdateOperationsInput | number
    conversionCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutReferralsGivenNestedInput
    invitee?: UserUpdateOneRequiredWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteeId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDonationsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedDonationsNestedInput
  }

  export type DonationUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDonationStatusFieldUpdateOperationsInput | $Enums.DonationStatus
    reference?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    proofScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerEntryUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointsLedgerNestedInput
  }

  export type PointsLedgerEntryUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsLedgerEntryUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardSnapshotUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type LeaderboardSnapshotUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardSnapshotUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutViewProofsNestedInput
    reviewedBy?: UserUpdateOneWithoutReviewedProofsNestedInput
  }

  export type ViewProofUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewProofUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    smartLinkId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    screenshotUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumViewProofStatusFieldUpdateOperationsInput | $Enums.ViewProofStatus
    reviewedById?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAuditEventUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutAuditEventsNestedInput
  }

  export type CampaignAuditEventUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAuditEventUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    actorRole?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCampaignAuditEventTypeFieldUpdateOperationsInput | $Enums.CampaignAuditEventType
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkEventCreateManySmartLinkInput = {
    id?: string
    smartLinkId?: string | null
    slug?: string | null
    eventType: $Enums.LinkEventType
    type?: $Enums.LinkEventType | null
    userId?: string | null
    ipAddress?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    referer?: string | null
    country?: string | null
    createdAt?: Date | string
  }

  export type LinkEventUpdateWithoutSmartLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType
    type?: NullableEnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkEventUncheckedUpdateWithoutSmartLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType
    type?: NullableEnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkEventUncheckedUpdateManyWithoutSmartLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    smartLinkId?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType
    type?: NullableEnumLinkEventTypeFieldUpdateOperationsInput | $Enums.LinkEventType | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyGroupInput = {
    id?: string
    name: string
    teamLeadId?: string | null
    maxMembers?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutTeamNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutTeamNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamLeadId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyTeamInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    profilePicture?: string | null
    whatsappNumber?: string | null
    trustScore?: number
    isActive?: boolean
    weaponsOfChoice?: UserCreateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamInviteLinkCreateManyTeamInput = {
    id?: string
    token: string
    targetRole: string
    createdById: string
    usedCount?: number
    maxUses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUpdateManyWithoutInviteeNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: CampaignParticipationUncheckedUpdateManyWithoutUserNestedInput
    smartLinks?: SmartLinkUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutInviterNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutInviteeNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    verifiedDonations?: DonationUncheckedUpdateManyWithoutVerifiedByNestedInput
    pointsLedger?: PointsLedgerEntryUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardSnapshotUncheckedUpdateManyWithoutUserNestedInput
    trustScoreRecord?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    notifications?: AppNotificationUncheckedUpdateManyWithoutUserNestedInput
    viewProofs?: ViewProofUncheckedUpdateManyWithoutUserNestedInput
    reviewedProofs?: ViewProofUncheckedUpdateManyWithoutReviewedByNestedInput
    teamInviteLinks?: TeamInviteLinkUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: CampaignAuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    weaponsOfChoice?: UserUpdateweaponsOfChoiceInput | $Enums.SocialPlatform[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInviteLinkUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutTeamInviteLinksNestedInput
  }

  export type TeamInviteLinkUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInviteLinkUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    targetRole?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    usedCount?: IntFieldUpdateOperationsInput | number
    maxUses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}